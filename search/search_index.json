{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"VEX V5 Robotics Tutorial Series","text":"<p>Welcome to the comprehensive tutorial series for VEX V5 robotics programming! This guide is designed for 8th-grade students with no prior coding experience.</p>"},{"location":"#your-learning-journey","title":"Your Learning Journey","text":"<pre><code>---\ntitle: Your Learning Journey\n---\nflowchart TD\n    subgraph Row1[\" \"]\n        direction LR\n        A[\"0. WELCOME&lt;br/&gt;Start here!\"] --&gt; B[\"1. PHYSICS&lt;br/&gt;How things move\"]\n        B --&gt; C[\"2. ROBOT ANATOMY&lt;br/&gt;Know your bot\"]\n    end\n    subgraph Row2[\" \"]\n        direction LR\n        D[\"3. PYTHON BASICS&lt;br/&gt;Learn to code\"] --&gt; E[\"4. DRIVE CONTROL&lt;br/&gt;You drive it\"]\n        E --&gt; F[\"5. AUTONOMOUS&lt;br/&gt;Robot drives itself!\"]\n    end\n    subgraph Row3[\" \"]\n        direction LR\n        G[\"6. COMPETITION STRATEGY&lt;br/&gt;Push Back 2026\"] --&gt; H[\"7. ADVANCED&lt;br/&gt;Level up!\"]\n    end\n    C --&gt; D\n    F --&gt; G</code></pre>"},{"location":"#quick-links","title":"Quick Links","text":"Section What You'll Learn Time 0. Welcome Introduction, setup, meet your code 15 min 1. Physics Foundations Forces, gears, friction 45 min 2. Robot Anatomy Brain, motors, sensors 30 min 3. Python Basics Variables, functions, loops 45 min 4. Drive Control Tank drive, arcade drive 30 min 5. Autonomous Programming movements 45 min 6. Competition Strategy Push Back game tactics 30 min 7. Advanced PID, sensors, skills auto 60 min Appendix Quick reference, troubleshooting Reference <p>Total Learning Time: ~5 hours (spread across multiple sessions)</p>"},{"location":"#before-you-start","title":"Before You Start","text":""},{"location":"#what-you-need","title":"What You Need","text":"<ul> <li>A computer (Windows, Mac, or Linux)</li> <li>VS Code installed</li> <li>VEX Robotics Extension installed</li> <li>This repository cloned to your computer</li> <li>Enthusiasm to learn! (No coding experience required)</li> </ul>"},{"location":"#optional-but-helpful","title":"Optional But Helpful","text":"<ul> <li>Access to a VEX V5 robot for hands-on practice</li> <li>A friend or teammate to learn with</li> </ul>"},{"location":"#how-these-tutorials-work","title":"How These Tutorials Work","text":""},{"location":"#each-tutorial-includes","title":"Each Tutorial Includes:","text":"<ol> <li>Real-World Analogy - We connect every concept to things you already know</li> <li>Explanation - Clear, step-by-step breakdown of the concept</li> <li>Code Connection - We show exactly where this applies in your robot code</li> <li>ASCII Diagram - Visual representation (works everywhere!)</li> <li>Exercise - Hands-on practice to cement your learning</li> </ol>"},{"location":"#symbols-youll-see","title":"Symbols You'll See","text":"Symbol Meaning <code>code</code> This is actual code you can run Bold Important term or concept Italic Emphasis or new vocabulary &gt; Quote Tips and helpful hints :warning: Watch out! Common mistake ahead"},{"location":"#the-push-back-game-2025-2026","title":"The Push Back Game (2025-2026)","text":"<p>This tutorial series prepares you for the Push Back competition:</p> <pre><code>    +----------------------------------------------------------+\n    |                    PUSH BACK FIELD                        |\n    |                      12' x 12'                            |\n    |                                                           |\n    |   [LONG GOAL]          [CENTER]          [LONG GOAL]     |\n    |   10 pts/zone           6-8 pts          10 pts/zone     |\n    |                                                           |\n    |              88 BLOCKS scattered on field                 |\n    |                                                           |\n    |   [PARK ZONE]                           [PARK ZONE]      |\n    |   RED 8-30 pts                          BLUE 8-30 pts    |\n    +----------------------------------------------------------+\n\n    AUTONOMOUS: 15 seconds (10 pt bonus available)\n    DRIVER:     1 minute 45 seconds\n</code></pre> <p>Key Game Elements: - Score blocks (3 pts each) - Control zones (6-10 pts each) - Park robots (8 pts one, 30 pts both!) - Descore opponent blocks (allowed!)</p>"},{"location":"#learning-path-options","title":"Learning Path Options","text":""},{"location":"#path-a-structured-learning-recommended","title":"Path A: Structured Learning (Recommended)","text":"<p>Follow tutorials 0 \u2192 1 \u2192 2 \u2192 3 \u2192 4 \u2192 5 \u2192 6 \u2192 7 in order</p>"},{"location":"#path-b-i-already-know-some-python","title":"Path B: I Already Know Some Python","text":"<p>Skip to 3. Python Basics to check your knowledge, then continue</p>"},{"location":"#path-c-just-here-for-competition","title":"Path C: Just Here for Competition","text":"<p>Jump to 6. Competition Strategy (but you may need to backtrack)</p>"},{"location":"#path-d-quick-reference","title":"Path D: Quick Reference","text":"<p>Go directly to Appendix for cheat sheets and troubleshooting</p>"},{"location":"#your-robots-code-files","title":"Your Robot's Code Files","text":"<p>Throughout these tutorials, you'll work with these files:</p> <pre><code>src/\n\u251c\u2500\u2500 main.py           \u2190 Entry point (runs on the Brain)\n\u251c\u2500\u2500 robot_config.py   \u2190 Motor and sensor setup\n\u251c\u2500\u2500 autonomous.py     \u2190 15-second autonomous routines\n\u251c\u2500\u2500 driver_control.py \u2190 Tank and arcade drive modes\n\u2514\u2500\u2500 utils.py          \u2190 Helper functions\n</code></pre> <p>You'll understand every line of these files by the end of this series!</p>"},{"location":"#getting-help","title":"Getting Help","text":""},{"location":"#stuck-on-something","title":"Stuck on Something?","text":"<ol> <li>Check the Troubleshooting Guide</li> <li>Look up terms in the Glossary</li> <li>Ask your coach or mentor</li> <li>Visit the VEX Forum</li> </ol>"},{"location":"#found-a-mistake","title":"Found a Mistake?","text":"<p>Let your instructor know so we can fix it!</p>"},{"location":"#ready-to-begin","title":"Ready to Begin?","text":"<p>Start with Tutorial 0: Welcome \u2192</p> <p>These tutorials were created to help 8th-grade students learn VEX V5 robotics programming from scratch. No prior experience required!</p>"},{"location":"00-welcome/","title":"Tutorial 0: Welcome to VEX V5 Robotics!","text":"<p>Time: ~15 minutes Prerequisites: None! Just bring your curiosity.</p>"},{"location":"00-welcome/#what-is-vex-v5-robotics","title":"What is VEX V5 Robotics?","text":"<p>Imagine building a robot from scratch, then telling it exactly what to do using code you write yourself. That's VEX V5 robotics!</p> <pre><code>---\ntitle: From Your Idea to Robot Action\n---\nflowchart TB\n    A[\"YOUR BRAIN&lt;br/&gt;You think of what the robot should do\"] --&gt; B[\"PYTHON CODE&lt;br/&gt;You write instructions in Python\"]\n    B --&gt; C[\"V5 BRAIN&lt;br/&gt;The robot's brain runs your code\"]\n    C --&gt; D[\"ROBOT MOVES!&lt;br/&gt;Motors, sensors, and wheels do the work\"]</code></pre> <p>VEX V5 is a robotics system used by students worldwide in competitions. You build robots from metal parts, motors, and sensors, then program them using Python (a beginner-friendly programming language).</p>"},{"location":"00-welcome/#you-already-know-more-than-you-think","title":"You Already Know More Than You Think!","text":"<p>Before you worry about coding being \"too hard,\" let's see what you already know:</p> What You Know How It Helps Video game controllers You know joysticks control movement! Pushing a shopping cart You understand force and resistance Riding a bicycle You've used gears (low gear for hills!) Following a recipe That's basically what coding is! Playing strategy games You can think ahead and plan <p>See? You're already halfway there!</p>"},{"location":"00-welcome/#what-youll-learn-in-this-tutorial-series","title":"What You'll Learn in This Tutorial Series","text":"<p>By the end of these tutorials, you will be able to:</p> <ul> <li>[ ] Understand basic physics concepts like force, torque, and friction</li> <li>[ ] Know every part of your VEX V5 robot</li> <li>[ ] Write Python code from scratch</li> <li>[ ] Control your robot with a game controller</li> <li>[ ] Program autonomous routines (robot drives itself!)</li> <li>[ ] Develop winning strategies for the Push Back competition</li> </ul>"},{"location":"00-welcome/#meet-your-robots-code-files","title":"Meet Your Robot's Code Files","text":"<p>Let's take a tour of the code files you'll be working with. They're all in the <code>src/</code> folder:</p> <pre><code>src/\n\u251c\u2500\u2500 main.py            \u2190 The starting point (like pressing \"Start\" in a game)\n\u251c\u2500\u2500 robot_config.py    \u2190 Where you tell the code about your motors\n\u251c\u2500\u2500 autonomous.py      \u2190 Code that runs WITHOUT a driver (15 seconds!)\n\u251c\u2500\u2500 driver_control.py  \u2190 Code that reads your joystick inputs\n\u2514\u2500\u2500 utils.py           \u2190 Helper functions (like a toolkit)\n</code></pre>"},{"location":"00-welcome/#mainpy-the-starting-point","title":"main.py - The Starting Point","text":"<p>When you download code to your robot, this is what runs first:</p> <pre><code># This is the FIRST thing that runs!\ndef main():\n    brain.screen.print(\"Robot Ready!\")\n    driver_control_loop()  # Start listening for controller\n</code></pre> <p>Think of it like the main menu of a video game - it sets everything up and then starts the action.</p>"},{"location":"00-welcome/#robot_configpy-your-robots-blueprint","title":"robot_config.py - Your Robot's Blueprint","text":"<p>This file describes your robot's hardware:</p> <pre><code># Left motors on ports 1 and 2\nleft_motor_front = Motor(Ports.PORT1)\nleft_motor_back = Motor(Ports.PORT2)\n\n# Right motors on ports 3 and 4 (reversed!)\nright_motor_front = Motor(Ports.PORT3, reversed=True)\nright_motor_back = Motor(Ports.PORT4, reversed=True)\n</code></pre> <p>Why are right motors \"reversed\"? We'll explain in the Robot Anatomy tutorial!</p>"},{"location":"00-welcome/#driver_controlpy-youre-the-driver","title":"driver_control.py - You're the Driver!","text":"<p>This is where joystick movements become motor movements:</p> <pre><code>while True:\n    # Read joystick positions\n    left_speed = controller.axis3.position()   # Left stick up/down\n    right_speed = controller.axis2.position()  # Right stick up/down\n\n    # Move the motors!\n    left_motors.spin(left_speed)\n    right_motors.spin(right_speed)\n</code></pre> <p>It's a continuous loop - constantly reading your inputs and moving motors.</p>"},{"location":"00-welcome/#autonomouspy-robot-drives-itself","title":"autonomous.py - Robot Drives Itself!","text":"<p>For the first 15 seconds of a match, no human control allowed:</p> <pre><code>def autonomous_routine():\n    # Drive forward 500mm\n    drivetrain.drive_for(FORWARD, 500, MM)\n\n    # Turn right 90 degrees\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n\n    # Drive forward again\n    drivetrain.drive_for(FORWARD, 300, MM)\n</code></pre> <p>You write these instructions BEFORE the match. The robot follows them exactly!</p>"},{"location":"00-welcome/#utilspy-your-toolkit","title":"utils.py - Your Toolkit","text":"<p>Helper functions that make coding easier:</p> <pre><code>def deadband(value, threshold=5):\n    \"\"\"\n    If joystick is barely moved, treat it as zero.\n    Prevents drift from joystick that's not perfectly centered.\n    \"\"\"\n    if abs(value) &lt; threshold:\n        return 0\n    return value\n</code></pre> <p>You'll learn to write functions like this yourself!</p>"},{"location":"00-welcome/#the-vex-v5-hardware","title":"The VEX V5 Hardware","text":"<p>Here's what you're working with:</p> <pre><code>---\ntitle: V5 Brain Hardware Layout\n---\nflowchart TB\n    subgraph Brain[\"V5 BRAIN\"]\n        direction TB\n        subgraph TopRow[\" \"]\n            direction LR\n            Screen[\"SCREEN\"]\n            Spacer1[\" \"]\n            Battery[\"BATTERY SLOT\"]\n        end\n        Ports[\"PORTS: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | ... | 21&lt;br/&gt;(21 ports for motors and sensors!)\"]\n    end\n    style Spacer1 fill:none,stroke:none</code></pre> <pre><code>    +--------------------------------------------------+\n    |                  V5 CONTROLLER                    |\n    |                                                   |\n    |        [L1]                        [R1]          |\n    |        [L2]                        [R2]          |\n    |                                                   |\n    |     +-------+                  +-------+          |\n    |     | LEFT  |    [BUTTONS]     | RIGHT |          |\n    |     | STICK |    [A][B]        | STICK |          |\n    |     +-------+    [X][Y]        +-------+          |\n    |                                                   |\n    |         [UP]                                      |\n    |   [LEFT] [X] [RIGHT]                             |\n    |         [DOWN]                                    |\n    +--------------------------------------------------+\n</code></pre> <p>V5 Brain: The robot's computer. Runs your code, displays info, connects to motors.</p> <p>V5 Controller: Your game controller. Joysticks, buttons, bumpers - just like Xbox or PlayStation!</p>"},{"location":"00-welcome/#setting-up-your-environment","title":"Setting Up Your Environment","text":""},{"location":"00-welcome/#step-1-open-vs-code","title":"Step 1: Open VS Code","text":"<ol> <li>Launch VS Code on your computer</li> <li>Go to File \u2192 Open Folder</li> <li>Navigate to this project folder (where you see <code>src/</code>, <code>tests/</code>, etc.)</li> <li>Click Open</li> </ol>"},{"location":"00-welcome/#step-2-check-the-vex-extension","title":"Step 2: Check the VEX Extension","text":"<p>Look in the left sidebar for the VEX icon:</p> <pre><code>    [Explorer]\n    [Search]\n    [Git]\n    [VEX]        &lt;-- You should see this!\n    [Extensions]\n</code></pre> <p>If you don't see it, install the \"VEX Robotics\" extension from the Extensions tab.</p>"},{"location":"00-welcome/#step-3-activate-the-virtual-environment","title":"Step 3: Activate the Virtual Environment","text":"<p>Open the terminal in VS Code (View \u2192 Terminal) and type:</p> <p>Mac/Linux: <pre><code>source venv/bin/activate\n</code></pre></p> <p>Windows: <pre><code>venv\\Scripts\\activate\n</code></pre></p> <p>You'll see <code>(venv)</code> at the start of your command line - that means it's working!</p>"},{"location":"00-welcome/#step-4-run-the-tests","title":"Step 4: Run the Tests","text":"<p>Let's make sure everything is set up correctly:</p> <pre><code>make test\n</code></pre> <p>You should see something like:</p> <pre><code>============= 48 passed in 0.04s =============\n</code></pre> <p>All 48 tests passing means your environment is ready!</p>"},{"location":"00-welcome/#whats-next","title":"What's Next?","text":"<p>Now that you've met your code files and set up your environment, you're ready to learn the fundamentals.</p>"},{"location":"00-welcome/#your-learning-path","title":"Your Learning Path","text":"<pre><code>[\u2713] Tutorial 0: Welcome (You are here!)\n[ ] Tutorial 1: Physics Foundations\n[ ] Tutorial 2: Robot Anatomy\n[ ] Tutorial 3: Python Basics\n[ ] Tutorial 4: Drive Control\n[ ] Tutorial 5: Autonomous Programming\n[ ] Tutorial 6: Competition Strategy\n[ ] Tutorial 7: Advanced Topics\n</code></pre>"},{"location":"00-welcome/#before-you-go-quick-quiz","title":"Before You Go: Quick Quiz","text":"<p>Test your understanding! (Answers at bottom)</p> <ol> <li>Which file runs first when you download code to the robot?</li> <li>How many ports does the V5 Brain have?</li> <li>What does <code>autonomous.py</code> do?</li> <li>Why might right motors be \"reversed\"?</li> </ol>"},{"location":"00-welcome/#exercise-explore-the-code","title":"Exercise: Explore the Code","text":"<p>Open each of these files in VS Code and just look around:</p> <ol> <li><code>src/main.py</code> - Can you find where it prints \"Robot Ready!\"?</li> <li><code>src/robot_config.py</code> - What port numbers are the motors on?</li> <li><code>src/utils.py</code> - Can you find the <code>deadband</code> function?</li> </ol> <p>Don't worry about understanding everything yet - that's what the next tutorials are for!</p> <p>Next: Tutorial 1 - Physics Foundations \u2192</p>"},{"location":"00-welcome/#quiz-answers","title":"Quiz Answers","text":"<ol> <li><code>main.py</code> - it's the entry point</li> <li>21 ports for motors and sensors</li> <li>Contains code that runs during the 15-second autonomous period (no driver!)</li> <li>Because right-side motors are mounted as a mirror of left-side motors, so they need to spin the opposite direction to move forward</li> </ol>"},{"location":"00-welcome/01-parents-guide/","title":"Parent's Guide to VEX V5 Robotics","text":"<p>A comprehensive guide to understanding your child's robotics journey and asking the right questions.</p>"},{"location":"00-welcome/01-parents-guide/#part-1-quick-overview","title":"Part 1: Quick Overview","text":""},{"location":"00-welcome/01-parents-guide/#what-your-child-will-learn","title":"What Your Child Will Learn","text":"<p>Your child is embarking on a hands-on journey into robotics, programming, and competitive strategy through the VEX V5 Push Back competition (2025-2026 season). This curriculum is designed for 8th-grade students with zero prior coding experience and takes approximately 5 hours across multiple sessions.</p> <p>By the end, your child will be able to: - Write Python code that controls a physical robot - Understand the physics behind robot movement (forces, gears, friction) - Design autonomous routines that run without human control - Develop strategic thinking for competitive matches - Work as part of an alliance team under time pressure</p>"},{"location":"00-welcome/01-parents-guide/#the-competition-vex-v5-push-back","title":"The Competition: VEX V5 Push Back","text":"<p>The basics: Two alliances (2 robots each) compete on a 12' \u00d7 12' field. The goal is to push colored blocks into scoring goals while defending your zones.</p> <p>Match structure:</p> Phase Duration What Happens Autonomous 15 seconds Robot runs pre-programmed code (no human control) Driver Control 1 min 45 sec Human driver controls the robot <p>Why it matters: Your child learns that robotics isn't just about building\u2014it's about strategy, timing, coding, and teamwork.</p>"},{"location":"00-welcome/01-parents-guide/#learning-roadmap","title":"Learning Roadmap","text":"Module Time What They Learn 0. Welcome 15 min Code structure, development setup 1. Physics Foundations 45 min Forces, gears, friction\u2014why robots move 2. Robot Anatomy 30 min Brain, motors, sensors\u2014what's inside 3. Python Basics 45 min Variables, functions, loops\u2014how to code 4. Drive Control 30 min Tank/arcade drive, driver skills 5. Autonomous 45 min Pre-programmed movements, timing 6. Competition Strategy 30 min Scoring, alliance coordination 7. Advanced Topics 60 min PID control, sensors (optional)"},{"location":"00-welcome/01-parents-guide/#milestones-to-celebrate","title":"Milestones to Celebrate","text":"<p>These are moments worth acknowledging:</p> <ol> <li>First successful code run - The robot responds to their code</li> <li>Understanding motor reversal - They can explain why right motors spin \"backward\"</li> <li>Tank vs. arcade explanation - They know the trade-offs of each control scheme</li> <li>First autonomous routine - Robot moves on its own following their code</li> <li>Strategic thinking - They discuss parking vs. scoring decisions</li> <li>Debugging success - They fix a problem without help</li> </ol>"},{"location":"00-welcome/01-parents-guide/#part-2-questions-to-ask-your-child","title":"Part 2: Questions to Ask Your Child","text":"<p>Use these questions to spark conversation and check understanding. Each includes a brief answer hint so you can follow along.</p>"},{"location":"00-welcome/01-parents-guide/#module-1-physics-foundations","title":"Module 1: Physics Foundations","text":"<p>1. Why does a heavier robot push other robots more easily, but also move slower? (Newton's 2nd Law: Force = Mass \u00d7 Acceleration. More mass means more pushing force, but the same motor power results in less acceleration.)</p> <p>2. What happens if your robot's wheels spin but it doesn't move? (The wheels have overcome friction\u2014they're slipping. This means traction is lost, possibly because the robot is too light or the floor is slippery.)</p> <p>3. Why would you choose a red motor cartridge over a blue one? (Red gives high torque (pushing power) but low speed. Blue gives high speed but low torque. It's a trade-off based on what the robot needs to do.)</p> <p>4. If two robots are pushing each other and neither moves, what's happening? (The forces are balanced\u2014Newton's 3rd Law. Each robot pushes equally on the other.)</p> <p>5. Why do some wheels have rollers on them? (Omni wheels have rollers that allow sideways sliding, making turning easier. Traction wheels grip in all directions but make turns harder.)</p>"},{"location":"00-welcome/01-parents-guide/#module-2-robot-anatomy","title":"Module 2: Robot Anatomy","text":"<p>1. Why does the robot need to know which port each motor is connected to? (The code sends commands to specific port numbers. If a motor is on port 1, the code must reference port 1 to control it.)</p> <p>2. Why are the right-side motors \"reversed\" in the code? (Motors on opposite sides face opposite directions. Without reversing, telling both sides to spin \"forward\" would make the robot turn instead of drive straight.)</p> <p>3. What's the difference between the Brain and the Controller? (The Brain is the robot's computer\u2014it runs the code. The Controller is what the driver holds\u2014it sends joystick and button inputs to the Brain wirelessly.)</p> <p>4. What can sensors tell the robot that the driver can't see? (Exact heading angle, precise distance to objects, whether it's the right color block. Humans estimate; sensors measure precisely.)</p> <p>5. Why does the robot need to \"calibrate\" before using certain sensors? (The inertial sensor needs to establish a reference point for \"straight.\" If it calibrates while moving, all readings will be off.)</p>"},{"location":"00-welcome/01-parents-guide/#module-3-python-basics","title":"Module 3: Python Basics","text":"<p>1. Why do programmers create functions instead of writing the same code multiple times? (Functions are reusable. Write once, use anywhere. If you need to fix something, you fix it in one place.)</p> <p>2. What's the difference between a variable that stores a number vs. one that stores True/False? (Numbers (int/float) are for calculations like speed. Booleans (True/False) are for decisions like \"is the intake running?\")</p> <p>3. Why would the robot do something forever using a loop? (Driver control needs to continuously read joystick inputs. Without a loop, it would read once and stop listening.)</p> <p>4. What happens if the code says \"turn 90 degrees\" but doesn't wait for it to finish? (The next command might run immediately, overlapping with the turn. The robot could try to drive forward while still turning.)</p> <p>5. Why would you draw a flowchart before writing code? (Flowcharts show the logic without worrying about syntax. It's easier to spot problems in a diagram than in code.)</p>"},{"location":"00-welcome/01-parents-guide/#module-4-drive-control","title":"Module 4: Drive Control","text":"<p>1. When would tank drive be better than arcade drive? (Tank drive gives independent control of each side, making pivot turns and defensive pushing easier. Arcade is smoother for curves but less precise.)</p> <p>2. Why does the code ignore small joystick movements (deadband)? (Real joysticks aren't perfectly centered\u2014they drift slightly. Without deadband, the robot would creep even when nobody touches the controller.)</p> <p>3. What's the advantage of using a control \"curve\" that makes small movements even smaller? (Precision. When pushing blocks into a goal, you need tiny adjustments. A curve lets you have fine control at low speeds and full power at high speeds.)</p> <p>4. Why practice driving in squares and figure-8s? (These patterns develop muscle memory for common movements\u2014straight lines, turns, and smooth curves. Competition drivers need these instinctively.)</p> <p>5. What should the driver prioritize in the last 10 seconds of a match? (Parking. Two robots parked = 30 points, which often outweighs any blocks they could score in that time.)</p>"},{"location":"00-welcome/01-parents-guide/#module-5-autonomous-programming","title":"Module 5: Autonomous Programming","text":"<p>1. Why is the 15-second autonomous period so important? (It can earn a 10-point bonus and score blocks before the opponent. A good autonomous can determine the match outcome.)</p> <p>2. What's the risk of making the robot move too fast during autonomous? (Overshooting. The robot might drive past its target or turn too far, throwing off all subsequent movements.)</p> <p>3. Why do autonomous routines include \"wait\" commands between movements? (To let the robot stabilize. Momentum continues after a command ends\u2014a brief pause prevents drift.)</p> <p>4. How do you fit multiple scoring actions into just 15 seconds? (Optimize: faster speeds where safe, shorter waits, and overlapping actions like running the intake while driving.)</p> <p>5. What does \"blocking vs. non-blocking\" mean in robot commands? (Blocking commands wait until finished (drive 500mm, then continue). Non-blocking commands start and return immediately (start intake, keep going). This enables multitasking.)</p>"},{"location":"00-welcome/01-parents-guide/#module-6-competition-strategy","title":"Module 6: Competition Strategy","text":"<p>1. Why is parking two robots worth so much more than parking one? (8 points for one vs. 30 for both. It's a teamwork incentive\u2014coordinating with your alliance partner is heavily rewarded.)</p> <p>2. How can removing opponent blocks from a goal be worth more than just scoring your own? (Point swing. If they had zone control (10 points to them), removing blocks gives you control (+10 to you). That's a 20-point shift from one action.)</p> <p>3. What should alliance partners decide before a match starts? (Who covers which field area, what autonomous routines to run (avoiding collisions), and who parks first at the end.)</p> <p>4. When would you stop trying to score and focus on defense? (When you're ahead and time is short. Defending a lead by blocking opponents can be more valuable than risking a turnover.)</p> <p>5. What's the difference between a match and a skills challenge? (Match: 2 vs. 2, 2 minutes. Skills: solo robot, 60 seconds, trying to maximize points alone. Skills determines tournament rankings.)</p>"},{"location":"00-welcome/01-parents-guide/#module-7-advanced-topics","title":"Module 7: Advanced Topics","text":"<p>1. Why does smooth \"proportional\" control work better than just \"on/off\" control? (On/off overshoots the target and oscillates. Proportional slows down as you approach, stopping precisely.)</p> <p>2. What does the \"I\" in PID help solve? (Steady-state error. If friction prevents reaching the exact target, accumulated error builds up and adds extra push to overcome it.)</p> <p>3. Why would a robot use a sensor instead of just timing its movements? (Conditions change. Battery level affects speed, wheels slip, obstacles appear. Sensors let the robot react to what's actually happening.)</p> <p>4. In a 60-second skills run, why is time budgeting critical? (You must reserve time for parking. Spending too long in one area leaves no time for others\u2014or worse, forgetting to park costs 8+ points.)</p> <p>5. What does \"closed-loop control\" mean? (The robot measures its actual state (via sensors) and adjusts continuously. Open-loop just guesses based on time.)</p>"},{"location":"00-welcome/01-parents-guide/#part-3-deep-dive-appendix","title":"Part 3: Deep Dive Appendix","text":"<p>This section is optional reading for parents who want more detail.</p>"},{"location":"00-welcome/01-parents-guide/#complete-scoring-reference","title":"Complete Scoring Reference","text":"Action Points Notes Block scored 3 Each block pushed into any goal Long goal zone control 10 Having more blocks than opponent in left or right goal Center goal upper zone 8 Majority in upper section of center goal Center goal lower zone 6 Majority in lower section of center goal 1 robot parked 8 Your robot in alliance park zone at end 2 robots parked 30 Both alliance robots parked (same zone or separate) Autonomous bonus 10 Win the 15-second autonomous period <p>Autonomous Win Point requirements (all must be met): 1. Score 7+ blocks of your alliance color 2. Blocks in at least 3 different goals 3. Remove 3+ blocks from loaders 4. Neither robot touching park zone barrier</p>"},{"location":"00-welcome/01-parents-guide/#career-connections","title":"Career Connections","text":"<p>This curriculum connects directly to professional fields:</p> <p>Mechanical Engineering - Physics of motion, forces, torque - Gear ratios and trade-offs - Robot design decisions</p> <p>Software Engineering - Python programming fundamentals - Control systems (PID) - Debugging and testing</p> <p>Electrical Engineering - Sensor integration - Motor control and power - Wiring and connections</p> <p>Product Management - Trade-off analysis (speed vs. torque, scoring vs. parking) - Prioritization under constraints - User experience (driver ergonomics)</p> <p>Program Management - Time budgeting (15-second autonomous, 60-second skills) - Coordination with partners - Risk management and fallback plans</p> <p>Data Science - Sensor data interpretation - Feedback loops - Optimization algorithms</p>"},{"location":"00-welcome/01-parents-guide/#glossary","title":"Glossary","text":"Term Simple Definition Autonomous The 15-second period where the robot runs pre-written code without human control Alliance Your team of 2 robots working together against the opposing 2 Deadband Ignoring small joystick movements to prevent drift Drivetrain The motors and wheels that move the robot Encoder Sensor inside motors that tracks rotation precisely Gear ratio Relationship between motor speed and wheel speed IMU (Inertial sensor) Sensor that knows which direction the robot faces Motor cartridge Color-coded gear set (blue/green/red) that sets speed/torque PID Control algorithm for precise movements (Proportional-Integral-Derivative) Port Numbered connection point on the Brain (1-21) Skills challenge Solo 60-second run to score maximum points Tank drive Control scheme: left stick = left wheels, right stick = right wheels Arcade drive Control scheme: one stick controls forward/backward and turning Torque Rotational force (twisting power)"},{"location":"00-welcome/01-parents-guide/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<p>What if my child gets stuck? Encourage them to re-read the tutorial section and try the review questions. Debugging is part of learning\u2014resist solving it for them. If truly stuck, the troubleshooting appendix covers common issues.</p> <p>How much should I help? Ask questions rather than giving answers. \"What did you expect to happen?\" and \"What actually happened?\" are more valuable than fixing the code yourself.</p> <p>What equipment is needed? - Computer with VS Code installed - VEX V5 robot kit (provided by school/team) - The code repository (already set up)</p> <p>Can I watch competitions? Absolutely! VEX competitions are open to spectators. Watching matches helps you understand what your child is working toward.</p> <p>What if my child wants to go deeper? Module 7 (Advanced Topics) is optional and covers sophisticated concepts like PID control. Many students also explore custom mechanisms, vision sensors, or more complex autonomous routines.</p>"},{"location":"00-welcome/01-parents-guide/#navigation","title":"Navigation","text":"<p>\u2190 Previous: Welcome to VEX V5 Robotics</p> <p>\u2192 Next: Physics Foundations: Forces and Motion</p>"},{"location":"01-physics-foundations/01-forces-and-motion/","title":"Tutorial 1.1: Forces and Motion","text":"<p>Time: ~15 minutes Prerequisites: Tutorial 0: Welcome</p>"},{"location":"01-physics-foundations/01-forces-and-motion/#the-shopping-cart-analogy","title":"The Shopping Cart Analogy","text":"<p>Imagine you're at a grocery store with a shopping cart.</p> <pre><code>    Empty Cart                    Full Cart\n\n    +-------+                     +-------+\n    |       |  LIGHT              |\u2588\u2588\u2588\u2588\u2588\u2588\u2588|  HEAVY\n    |       |  Easy to push       |\u2588\u2588\u2588\u2588\u2588\u2588\u2588|  Hard to push\n    +---+---+                     +---+---+\n        |                             |\n       [O]                           [O]\n</code></pre> <p>Question: Which cart is easier to push? Why?</p> <p>The empty cart is easier because it has less mass (weight). You need less force to move it.</p> <p>This simple observation is the foundation of physics that makes robots work!</p>"},{"location":"01-physics-foundations/01-forces-and-motion/#newtons-three-laws-the-simple-version","title":"Newton's Three Laws (The Simple Version)","text":"<p>Sir Isaac Newton figured out the rules of motion about 400 years ago. Here's what they mean for your robot:</p>"},{"location":"01-physics-foundations/01-forces-and-motion/#law-1-objects-stay-put-or-keep-moving","title":"Law 1: Objects Stay Put (or Keep Moving)","text":"<p>\"An object at rest stays at rest, and an object in motion stays in motion, unless a force acts on it.\"</p> <p>For your robot: - Your robot won't move unless motors push it - Your robot won't stop unless you tell it to (or friction slows it)</p> <pre><code>flowchart LR\n    A[\"Robot at rest&lt;br/&gt;Stays still\"] --&gt;|\"Force applied&lt;br/&gt;Motors push\"| B[\"Robot moving&lt;br/&gt;Keeps moving!\"]</code></pre>"},{"location":"01-physics-foundations/01-forces-and-motion/#law-2-force-mass-acceleration-f-m-a","title":"Law 2: Force = Mass \u00d7 Acceleration (F = m \u00d7 a)","text":"<p>\"The force needed to move something depends on how heavy it is and how fast you want it to go.\"</p> <p>For your robot: - Heavier robot = need more motor power - Want faster acceleration = need more motor power - This is why we choose motor gear ratios carefully!</p> <pre><code>    SAME FORCE, DIFFERENT MASS:\n\n    Light Robot                Heavy Robot\n    +--------+                 +===========+\n    |   5kg  |  \u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192      |    15kg   |  \u2192\u2192\n    +--[O][O]+                 +===[O][O]==+\n\n    Accelerates FAST          Accelerates SLOW\n</code></pre>"},{"location":"01-physics-foundations/01-forces-and-motion/#law-3-every-action-has-a-reaction","title":"Law 3: Every Action Has a Reaction","text":"<p>\"When you push something, it pushes back.\"</p> <p>For your robot: - When wheels push against the floor, the floor pushes your robot forward - When you push an opponent, they push back on you - This is why heavier robots are harder to push around!</p> <pre><code>    Your Robot     Opponent\n\n    +--------+    +--------+\n    |  PUSH \u2192|    |\u2190 PUSHES|\n    |        |    |  BACK! |\n    +--[O][O]+    +--[O][O]+\n\n    Action        Reaction\n</code></pre>"},{"location":"01-physics-foundations/01-forces-and-motion/#how-this-applies-to-robot-motors","title":"How This Applies to Robot Motors","text":"<p>Your VEX V5 motors create force by spinning. That spinning force is called torque.</p> <pre><code>flowchart LR\n    A[\"Motor creates torque\"] --&gt; B[\"Spinning shaft\"]\n    B --&gt; C[\"Wheel pushes floor\"]\n    C --&gt; D[\"Floor pushes robot forward!\"]</code></pre>"},{"location":"01-physics-foundations/01-forces-and-motion/#the-force-equation-in-practice","title":"The Force Equation in Practice","text":"<p>Let's say your robot weighs 5 kg and you want it to accelerate at 2 m/s\u00b2:</p> <pre><code>Force = Mass \u00d7 Acceleration\nForce = 5 kg \u00d7 2 m/s\u00b2\nForce = 10 Newtons\n</code></pre> <p>Your motors need to provide at least 10 Newtons of force!</p> <p>Note: VEX motors are rated in torque (Newton-meters), not Newtons directly. We'll cover torque in the next tutorial!</p>"},{"location":"01-physics-foundations/01-forces-and-motion/#why-robot-weight-matters","title":"Why Robot Weight Matters","text":"<p>In the Push Back competition, you might need to push opponents or resist being pushed:</p> <pre><code>    Pushing Match:\n\n    Light Robot (5kg)        Heavy Robot (15kg)\n    +--------+               +============+\n    |        |  \u2192\u2192\u2192          |            |\n    +--[O][O]+               +===[O][O]===+\n\n    Light robot pushes...    Heavy robot barely moves!\n\n    But gets pushed back!    And can push light robot around!\n\n    \u2190\u2190\u2190\u2190\u2190\u2190\u2190\u2190                 \u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192\n</code></pre> <p>Trade-off: - Heavy robot = hard to push, but slower and needs more battery - Light robot = fast and agile, but easier to push around</p> <p>For Push Back, you'll need to decide what's more important for your strategy!</p>"},{"location":"01-physics-foundations/01-forces-and-motion/#code-connection-limiting-force","title":"Code Connection: Limiting Force","text":"<p>Look at <code>src/utils.py</code>:</p> <pre><code>def clamp(value, min_val, max_val):\n    \"\"\"\n    Clamp a value between minimum and maximum bounds.\n    \"\"\"\n    return max(min_val, min(value, max_val))\n</code></pre> <p>This function limits values - like limiting how much force a motor can apply!</p> <p>Example: <pre><code>motor_power = 150  # Someone requested 150% power\nclamped_power = clamp(motor_power, -100, 100)  # But max is 100%\n# Result: clamped_power = 100\n</code></pre></p> <p>Why do we clamp? Because: 1. Motors have maximum power limits 2. Too much power can damage mechanisms 3. You might want to limit speed for safety</p>"},{"location":"01-physics-foundations/01-forces-and-motion/#friction-the-hidden-force","title":"Friction: The Hidden Force","text":"<p>Friction is the force that resists motion. It happens whenever two surfaces touch.</p> <pre><code>    Robot on smooth floor    Robot on carpet\n\n    +--------+               +--------+\n    |        |               |        |\n    +--[O][O]+               +--[O][O]+\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550           ~~~~~~~~~~~~\n    Low friction            High friction\n\n    Easy to slide           Hard to move\n</code></pre> <p>For your robot: - Too little friction = wheels spin but robot doesn't move (like on ice) - Too much friction = motors work hard, battery drains fast - Just right = wheels grip and robot moves efficiently</p> <p>This is why we choose different wheel types: - Traction wheels = high friction for pushing - Omni wheels = can slide sideways (we'll explain why that's useful!)</p>"},{"location":"01-physics-foundations/01-forces-and-motion/#momentum-why-heavy-things-are-hard-to-stop","title":"Momentum: Why Heavy Things Are Hard to Stop","text":"<p>Momentum = Mass \u00d7 Velocity</p> <pre><code>    Slow, heavy robot           Fast, light robot\n\n    +============+              +--------+\n    |   15kg    |  \u2192 (2 m/s)   |  5kg   |  \u2192\u2192\u2192\u2192 (6 m/s)\n    +===[O][O]==+              +--[O][O]+\n\n    Momentum = 30 kg\u00b7m/s       Momentum = 30 kg\u00b7m/s\n\n    SAME momentum, but the heavy robot is harder to dodge!\n</code></pre> <p>In Push Back, a heavy robot moving slowly has lots of momentum - hard to stop or redirect!</p>"},{"location":"01-physics-foundations/01-forces-and-motion/#summary","title":"Summary","text":"Concept What It Means For Your Robot Mass How heavy something is Affects speed and pushing ability Force Push or pull Motors create force to move robot Acceleration How fast speed changes More force = faster acceleration Friction Resistance between surfaces Wheels need friction to grip Momentum Mass \u00d7 velocity Hard to stop heavy/fast objects"},{"location":"01-physics-foundations/01-forces-and-motion/#exercise-force-calculations","title":"Exercise: Force Calculations","text":"<p>Problem 1: Your robot weighs 8 kg. How much force do you need to accelerate at 3 m/s\u00b2?</p> <pre><code>F = m \u00d7 a\nF = ___ \u00d7 ___\nF = ___ Newtons\n</code></pre> <p>Problem 2: You have two robots: - Robot A: 6 kg, moving at 4 m/s - Robot B: 12 kg, moving at 2 m/s</p> <p>Which has more momentum? Which would be harder to stop?</p> <p>Problem 3: Look at the <code>clamp()</code> function in <code>src/utils.py</code>. What would <code>clamp(-150, -100, 100)</code> return?</p>"},{"location":"01-physics-foundations/01-forces-and-motion/#answers","title":"Answers","text":"<p>Problem 1: F = 8 \u00d7 3 = 24 Newtons</p> <p>Problem 2: - Robot A momentum: 6 \u00d7 4 = 24 kg\u00b7m/s - Robot B momentum: 12 \u00d7 2 = 24 kg\u00b7m/s - Same momentum! But Robot B has more mass, so it's harder to redirect.</p> <p>Problem 3: <code>clamp(-150, -100, 100)</code> returns <code>-100</code> (the minimum allowed value)</p> <p>\u2190 Previous: Welcome | Next: Gears and Torque \u2192</p>"},{"location":"01-physics-foundations/02-gears-and-torque/","title":"Tutorial 1.2: Gears and Torque","text":"<p>Time: ~15 minutes Prerequisites: Tutorial 1.1: Forces and Motion</p>"},{"location":"01-physics-foundations/02-gears-and-torque/#the-bicycle-analogy","title":"The Bicycle Analogy","text":"<p>Have you ever ridden a bicycle with gears? Think about what happens when you switch gears:</p> <pre><code>flowchart LR\n    subgraph LOW[\"LOW GEAR (for hills)\"]\n        direction TB\n        L1[\"Pedal: Many rotations\"]\n        L2[\"Wheel: Few rotations\"]\n        L3[\"Easy to pedal&lt;br/&gt;Slow movement&lt;br/&gt;Lots of pushing power\"]\n    end\n    subgraph HIGH[\"HIGH GEAR (for speed)\"]\n        direction TB\n        H1[\"Pedal: Few rotations\"]\n        H2[\"Wheel: Many rotations\"]\n        H3[\"Hard to pedal&lt;br/&gt;Fast movement&lt;br/&gt;Less pushing power\"]\n    end</code></pre> <p>This is exactly how robot motor gears work!</p>"},{"location":"01-physics-foundations/02-gears-and-torque/#what-is-torque","title":"What is Torque?","text":"<p>Torque is rotational (spinning) force. Instead of pushing in a straight line, torque pushes in a circle.</p> <pre><code>    Force (Linear)              Torque (Rotational)\n\n         \u2192\u2192\u2192                         \u27f3\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    Pushes straight               | Motor|\n                                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                  Spins around\n</code></pre> <p>Torque is measured in Newton-meters (N\u00b7m) or inch-pounds (in\u00b7lb).</p> <p>Think of torque as \"twisting strength\" - how hard the motor can twist.</p>"},{"location":"01-physics-foundations/02-gears-and-torque/#vex-v5-motor-gear-cartridges","title":"VEX V5 Motor Gear Cartridges","text":"<p>VEX V5 Smart Motors can use different gear cartridges that change the torque vs. speed trade-off:</p> Cartridge RPM Torque Best For BLUE (6:1) 600 Low Flywheel, intake GREEN (18:1) 200 Medium Drivetrain RED (36:1) 100 High Lifting, pushing"},{"location":"01-physics-foundations/02-gears-and-torque/#understanding-the-ratios","title":"Understanding the Ratios","text":"<p>6:1 ratio means: For every 6 rotations of the motor, the output spins 1 time. - Motor spins fast \u2192 output spins fast - Less mechanical advantage \u2192 less torque</p> <p>36:1 ratio means: For every 36 rotations of the motor, the output spins 1 time. - Motor spins fast \u2192 output spins slow - More mechanical advantage \u2192 more torque</p> <pre><code>    6:1 (Blue)                   36:1 (Red)\n\n    Motor: \u27f3\u27f3\u27f3\u27f3\u27f3\u27f3              Motor: \u27f3\u27f3\u27f3\u27f3\u27f3\u27f3\u27f3\u27f3\u27f3\u27f3....(36 times)\n    Output: \u27f3                    Output: \u27f3\n\n    FAST, weak                   SLOW, strong\n</code></pre>"},{"location":"01-physics-foundations/02-gears-and-torque/#torque-vs-speed-the-trade-off","title":"Torque vs. Speed: The Trade-Off","text":"<p>You can't have both maximum speed AND maximum torque. It's a trade-off:</p> <pre><code>    TORQUE \u2191\n           \u2502\n    RED\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\n    (36:1) \u2502            \u2502\n           \u2502            \u2502\n           \u2502       \u25cf\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 You can be somewhere\n           \u2502       \u2502    \u2502     in between!\n           \u2502       \u2502    \u2502\n    GREEN\u2500\u2500\u253c\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2518    \u2502\n    (18:1) \u2502   \u2502        \u2502\n           \u2502   \u2502        \u2502\n           \u2502   \u2502        \u2502\n    BLUE\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf \u2500\u2500\u2192 SPEED\n    (6:1)  \u2502   \u2502        \u2502\n           \u2502   \u2502        \u2502\n           \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\n</code></pre>"},{"location":"01-physics-foundations/02-gears-and-torque/#which-should-you-choose","title":"Which Should You Choose?","text":"Mechanism Recommended Why Drivetrain GREEN (18:1) Balance of speed and pushing power Intake rollers BLUE (6:1) Need to spin fast to grab blocks Lift arm RED (36:1) Need strength to lift heavy loads Flywheel BLUE (6:1) Need maximum speed for launching"},{"location":"01-physics-foundations/02-gears-and-torque/#the-math-behind-gear-ratios","title":"The Math Behind Gear Ratios","text":"<p>Here's the formula:</p> <pre><code>Output Torque = Input Torque \u00d7 Gear Ratio\nOutput Speed = Input Speed \u00f7 Gear Ratio\n</code></pre> <p>Example with GREEN (18:1): - Motor provides 1 N\u00b7m of torque - Output torque = 1 \u00d7 18 = 18 N\u00b7m (18\u00d7 stronger!) - Motor spins at 3600 RPM internally - Output speed = 3600 \u00f7 18 = 200 RPM</p> <p>Example with BLUE (6:1): - Motor provides 1 N\u00b7m of torque - Output torque = 1 \u00d7 6 = 6 N\u00b7m - Motor spins at 3600 RPM internally - Output speed = 3600 \u00f7 6 = 600 RPM (3\u00d7 faster than green!)</p>"},{"location":"01-physics-foundations/02-gears-and-torque/#code-connection-gear-settings-in-robot_configpy","title":"Code Connection: Gear Settings in robot_config.py","text":"<p>Look at <code>src/robot_config.py</code>, lines 19-30:</p> <pre><code># Gear Settings:\n#   RATIO_6_1  = 600 RPM (blue cartridge)  - high speed, low torque\n#   RATIO_18_1 = 200 RPM (green cartridge) - balanced (default)\n#   RATIO_36_1 = 100 RPM (red cartridge)   - high torque, low speed\n\n# Left side motors (not reversed - standard mounting)\nleft_motor_front = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nleft_motor_back = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\n\n# Right side motors (reversed - mirror mounting spins opposite)\nright_motor_front = Motor(Ports.PORT3, GearSetting.RATIO_18_1, True)\nright_motor_back = Motor(Ports.PORT4, GearSetting.RATIO_18_1, True)\n</code></pre> <p>See how all four drive motors use <code>RATIO_18_1</code> (green)? That's the balanced choice for a drivetrain!</p>"},{"location":"01-physics-foundations/02-gears-and-torque/#changing-gear-cartridges","title":"Changing Gear Cartridges","text":"<p>If you want to change to RED for more pushing power:</p> <pre><code># Change GearSetting.RATIO_18_1 to GearSetting.RATIO_36_1\nleft_motor_front = Motor(Ports.PORT1, GearSetting.RATIO_36_1, False)\n</code></pre> <p>:warning: Important: You must also physically swap the cartridge inside the motor! The code just tells the Brain what to expect.</p>"},{"location":"01-physics-foundations/02-gears-and-torque/#external-gear-ratios","title":"External Gear Ratios","text":"<p>Besides the internal cartridge, you can add external gears between the motor and wheel:</p> <pre><code>    Motor Gear (12 teeth)      Wheel Gear (60 teeth)\n          \u250c\u2500\u2500\u2510                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502\u27f3 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500 chain \u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502   \u27f3    \u2502\n          \u2514\u2500\u2500\u2518                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          Small                     Big\n\n    Ratio = 60 \u00f7 12 = 5:1\n\n    Motor spins 5 times \u2192 Wheel spins 1 time\n    = More torque, less speed\n</code></pre> <p>This is configured in <code>robot_config.py</code>:</p> <pre><code>EXTERNAL_GEAR_RATIO = 1   # Change if using external gearing\n</code></pre> <p>If you have a 60:12 external ratio, you'd set: <pre><code>EXTERNAL_GEAR_RATIO = 5   # 60 \u00f7 12 = 5\n</code></pre></p>"},{"location":"01-physics-foundations/02-gears-and-torque/#torque-and-wheel-size","title":"Torque and Wheel Size","text":"<p>Bigger wheels cover more distance per rotation, but need more torque to accelerate:</p> <pre><code>    Small Wheel (2\")              Large Wheel (4\")\n\n         \u27f3                             \u27f3\n        [O]                          [  O  ]\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    Circumference:              Circumference:\n    2\" \u00d7 \u03c0 = 6.28\"              4\" \u00d7 \u03c0 = 12.57\"\n\n    Less distance per spin      More distance per spin\n    Needs less torque           Needs more torque\n</code></pre> <p>Your robot uses 4-inch wheels:</p> <pre><code># From robot_config.py\n# 4\" omni wheel circumference = 4 * pi * 25.4 = 319.19 mm\nWHEEL_TRAVEL_MM = 319.19\n</code></pre> <p>Each wheel rotation moves the robot 319.19 mm forward!</p>"},{"location":"01-physics-foundations/02-gears-and-torque/#calculating-robot-speed","title":"Calculating Robot Speed","text":"<p>With all the pieces, we can calculate maximum robot speed:</p> <pre><code>Given:\n- GREEN cartridge = 200 RPM\n- 4\" wheel circumference = 319.19 mm\n- External gear ratio = 1 (direct drive)\n\nWheel RPM = Motor RPM \u00f7 External Ratio\n          = 200 \u00f7 1 = 200 RPM\n\nDistance per minute = 200 \u00d7 319.19 mm = 63,838 mm = 63.8 m\n\nSpeed = 63.8 m \u00f7 60 s = 1.06 m/s (about 3.5 ft/s)\n</code></pre> <p>That's walking speed - fast enough for a robot!</p>"},{"location":"01-physics-foundations/02-gears-and-torque/#summary","title":"Summary","text":"Term Definition Trade-off Torque Rotational force More torque = less speed Gear Ratio How much the motor is geared down Higher ratio = more torque Blue (6:1) High speed, low torque For fast mechanisms Green (18:1) Balanced For drivetrains Red (36:1) High torque, low speed For lifting/pushing"},{"location":"01-physics-foundations/02-gears-and-torque/#exercise-gear-selection-challenge","title":"Exercise: Gear Selection Challenge","text":"<p>Scenario 1: You're building an intake mechanism that needs to spin rubber rollers really fast to grab blocks quickly. Which cartridge?</p> <p>Scenario 2: Your robot has a lift arm that needs to raise 2 kg of blocks. Which cartridge?</p> <p>Scenario 3: You're in a pushing match and your opponent keeps pushing you backward. What could you change?</p> <p>Bonus: Calculate your robot's speed if you switched to RED (100 RPM) cartridges.</p>"},{"location":"01-physics-foundations/02-gears-and-torque/#answers","title":"Answers","text":"<p>Scenario 1: BLUE (6:1) - you need speed, not torque</p> <p>Scenario 2: RED (36:1) - you need torque to lift heavy loads</p> <p>Scenario 3: Options: - Switch to RED cartridges for more torque - Add weight to your robot (more mass = harder to push) - Use traction wheels instead of omni (more friction)</p> <p>Bonus: <pre><code>Speed = (100 RPM \u00d7 319.19 mm) \u00f7 60 s\n      = 31,919 mm \u00f7 60 s\n      = 532 mm/s = 0.53 m/s (about 1.7 ft/s)\n</code></pre> Half the speed of green, but much more pushing power!</p> <p>\u2190 Previous: Forces and Motion | Next: Friction and Traction \u2192</p>"},{"location":"01-physics-foundations/03-friction-and-traction/","title":"Tutorial 1.3: Friction and Traction","text":"<p>Time: ~15 minutes Prerequisites: Tutorial 1.2: Gears and Torque</p>"},{"location":"01-physics-foundations/03-friction-and-traction/#the-ice-vs-grass-analogy","title":"The Ice vs. Grass Analogy","text":"<p>Imagine running on two different surfaces:</p> <pre><code>    Running on Ice               Running on Grass\n\n        \ud83c\udfc3 ~~~~slip~~~~             \ud83c\udfc3  \u2192\u2192\u2192\u2192\n    \u2248\u2248\u2248\u2248\u2248\u2248\u2248\u2248\u2248\u2248\u2248\u2248\u2248\u2248\u2248\u2248\u2248          ~~~~~~~~~~~~\n\n    Hard to push off!            Easy to push off!\n    You slip and slide           You grip and go\n    LOW FRICTION                 HIGH FRICTION\n</code></pre> <p>Your robot wheels work the same way! Without friction between the wheels and floor, the wheels just spin without moving the robot.</p>"},{"location":"01-physics-foundations/03-friction-and-traction/#types-of-friction","title":"Types of Friction","text":""},{"location":"01-physics-foundations/03-friction-and-traction/#static-friction","title":"Static Friction","text":"<p>The force that prevents sliding when objects aren't moving yet.</p> <pre><code>    Robot at rest on floor\n\n    +--------+\n    |        |   \u2190 Trying to push\n    +--[O][O]+\n    \u2550\u2550\u2550\u25cf\u25cf\u25cf\u2550\u2550\u2550    \u2190 Static friction holds!\n\n    The robot doesn't slide because\n    static friction resists the push.\n</code></pre>"},{"location":"01-physics-foundations/03-friction-and-traction/#kinetic-moving-friction","title":"Kinetic (Moving) Friction","text":"<p>The force that resists sliding when objects ARE moving.</p> <pre><code>    Robot sliding sideways\n\n    +--------+  \u2190\u2190\u2190 Sliding direction\n    |        |\n    +--[O][O]+\n    \u2550\u2550\u2550\u2192\u2192\u2192\u2550\u2550\u2550    \u2190 Kinetic friction pushes back\n\n    Less friction than static!\n    Once you start sliding, it's easier to keep sliding.\n</code></pre> <p>Key Insight: Static friction is STRONGER than kinetic friction. This is why: - Your wheels grip better when not spinning (accelerating gradually) - If wheels spin too fast, they break loose and \"burn out\"</p>"},{"location":"01-physics-foundations/03-friction-and-traction/#why-wheels-need-friction","title":"Why Wheels Need Friction","text":"<p>Without friction, wheels can't push the robot forward:</p> <pre><code>    Good Friction                Bad Friction (Ice)\n\n    +--------+  \u2192\u2192\u2192             +--------+\n    |        |                  |        |\n    +--[O][O]+                  +--[O][O]+\n       \u27f3  \u27f3  Wheels grip       \u2248\u2248\u2248\u27f3\u2248\u2248\u27f3\u2248\u2248  Wheels spin freely\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                  \u2248\u2248\u2248\u2248\u2248\u2248\u2248\u2248\u2248\u2248\n\n    Robot moves forward!        Robot stays still!\n    Wheels push, floor          Wheels just spin,\n    pushes back                 no grip = no movement\n</code></pre>"},{"location":"01-physics-foundations/03-friction-and-traction/#vex-wheel-types","title":"VEX Wheel Types","text":"<p>VEX offers several wheel types, each with different friction properties:</p>"},{"location":"01-physics-foundations/03-friction-and-traction/#traction-wheels-high-friction","title":"Traction Wheels (High Friction)","text":"<pre><code>    +===========+\n    |  \u2593\u2593\u2593\u2593\u2593\u2593   |   \u2190 Rubber tread pattern\n    |  \u2593\u2593\u2593\u2593\u2593\u2593   |\n    +===========+\n\n    Best for: Pushing matches, climbing\n    Trade-off: Can't slide sideways\n</code></pre>"},{"location":"01-physics-foundations/03-friction-and-traction/#omni-wheels-medium-friction-forward-low-sideways","title":"Omni Wheels (Medium Friction Forward, Low Sideways)","text":"<pre><code>        +------+\n       /   \u27cb   \\      \u2190 Small rollers around edge\n      |  \u27cb O \u27cb  |\n       \\  \u27cb   /\n        +------+\n\n    Best for: Maneuverability, turning\n    Trade-off: Can be pushed sideways\n    SECRET: Rollers let wheel slide sideways!\n</code></pre>"},{"location":"01-physics-foundations/03-friction-and-traction/#mecanum-wheels-omni-directional","title":"Mecanum Wheels (Omni-Directional)","text":"<pre><code>        +------+\n       / \u2572   \u2572 \\     \u2190 Angled rollers\n      |  \u2572 O \u2572 |\n       \\ \u2572   \u2572/\n        +------+\n\n    Best for: Moving in any direction\n    Trade-off: Complex programming, less pushing power\n</code></pre>"},{"location":"01-physics-foundations/03-friction-and-traction/#why-your-robot-uses-omni-wheels","title":"Why Your Robot Uses Omni Wheels","text":"<p>Your robot is configured with 4\" omni wheels. Here's why:</p> <pre><code>    Tank Drive Turn with Traction Wheels\n\n    +--------+              +--------+\n    |        |              |        |\n    +--[\u2588][\u2588]+              +--[\u2588][\u2588]+\n       \u2191  \u2193   Opposite\n              direction     SCRUB! Tires fight each other\n                           Wear, power loss, hard to turn\n\n    Tank Drive Turn with Omni Wheels\n\n    +--------+              +--------+\n    |        |              |        |\n    +--[O][O]+              +--[O][O]+\n       \u2191  \u2193   Opposite      Rollers let wheels\n              direction     slide sideways!\n                           Smooth, easy turning!\n</code></pre> <p>Omni wheels let the robot turn smoothly because the side rollers slide instead of scrubbing.</p>"},{"location":"01-physics-foundations/03-friction-and-traction/#center-of-gravity","title":"Center of Gravity","text":"<p>Your robot's center of gravity (CG) is the balance point:</p> <pre><code>    Balanced Robot              Tipping Robot!\n\n    +--------+                  +--------+\u2572\n    |   CG   |                  |   CG    \u2572\n    +--[O][O]+                  +--[O][O]+ \u2572\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                   \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550   \u2572\n                                          FALLING!\n</code></pre>"},{"location":"01-physics-foundations/03-friction-and-traction/#tips-for-stable-robots","title":"Tips for Stable Robots:","text":"<ol> <li>Keep CG low - Heavy components (battery) near the bottom</li> <li>Keep CG centered - Don't put all weight on one side</li> <li>Wide base - Wheels spread apart resist tipping</li> </ol> <pre><code>    Side View:\n\n    LOW CG (Stable)             HIGH CG (Tippy)\n\n        +--+                      +==+  \u2190 Heavy top\n        |  |                      |  |\n    +---+--+---+                  |  |\n    |          |              +---+--+---+\n    |   \u2588\u2588\u2588\u2588   | \u2190 Battery    |          |\n    +--[O]--[O]+              +--[O]--[O]+\n</code></pre>"},{"location":"01-physics-foundations/03-friction-and-traction/#traction-in-push-back","title":"Traction in Push Back","text":"<p>In the Push Back competition, traction matters a lot:</p> <pre><code>    Pushing Match Scenario:\n\n    Your Robot         Opponent Robot\n    (Omni Wheels)      (Traction Wheels)\n\n    +--------+         +========+\n    |   5kg  |  \u2192\u2192\u2192\u2192   |  8kg   |\n    +--[O][O]+         +--[\u2588][\u2588]+\n\n    You push...        But opponent has:\n                       - More mass (harder to move)\n                       - Traction wheels (more friction)\n\n    Result: You get pushed back!\n</code></pre>"},{"location":"01-physics-foundations/03-friction-and-traction/#strategies-for-better-traction","title":"Strategies for Better Traction","text":"<ol> <li> <p>Mixed Wheels: Traction in front, omni in back    <pre><code>+--------+\n|        |\n+-[\u2588]--[O]+   \u2190 Traction front, omni back\n</code></pre></p> </li> <li> <p>Weight Distribution: More weight over drive wheels</p> </li> <li>Lower Gear Ratio: RED cartridges for more torque</li> <li>Driver Skill: Don't spin wheels - gradual acceleration</li> </ol>"},{"location":"01-physics-foundations/03-friction-and-traction/#code-connection-wheel-measurements","title":"Code Connection: Wheel Measurements","text":"<p>Look at <code>src/robot_config.py</code>:</p> <pre><code># 4\" omni wheel circumference = 4 * pi * 25.4 = 319.19 mm\nWHEEL_TRAVEL_MM = 319.19\nTRACK_WIDTH_MM = 295      # Distance between left and right wheels\nWHEEL_BASE_MM = 200       # Distance between front and back axles\n</code></pre> <p>Why do these measurements matter?</p>"},{"location":"01-physics-foundations/03-friction-and-traction/#track-width","title":"Track Width","text":"<pre><code>    Top View:\n\n    +--------+\n    |        |\n    [O]--295--[O]    \u2190 TRACK_WIDTH_MM\n    |        |\n    [O]      [O]\n    +--------+\n\n    Wider = More stable, but slower to turn\n    Narrower = Less stable, but faster turns\n</code></pre>"},{"location":"01-physics-foundations/03-friction-and-traction/#wheel-base","title":"Wheel Base","text":"<pre><code>    Side View:\n\n    [O]--200--[O]    \u2190 WHEEL_BASE_MM\n\n    Longer = More stable forward/back\n    Shorter = Can tip forward easier\n</code></pre> <p>The drivetrain uses these values for accurate autonomous movements!</p>"},{"location":"01-physics-foundations/03-friction-and-traction/#summary","title":"Summary","text":"Concept What It Means For Push Back Static Friction Resistance before sliding Wheels grip when accelerating Kinetic Friction Resistance while sliding Less grip when wheels spin out Traction Wheels High friction, rubber Best for pushing matches Omni Wheels Side rollers for sliding Easy turning, but can be pushed sideways Center of Gravity Balance point Keep low for stability"},{"location":"01-physics-foundations/03-friction-and-traction/#exercise-wheel-selection-challenge","title":"Exercise: Wheel Selection Challenge","text":"<p>Design Challenge: You're building a Push Back robot. Consider these options:</p> <p>Option A: 4 omni wheels - Pros: Easy turning, smooth driving - Cons: Can be pushed sideways</p> <p>Option B: 4 traction wheels - Pros: Maximum grip, hard to push - Cons: Hard to turn, scrubs tires</p> <p>Option C: 2 traction (front) + 2 omni (back) - Pros: Good grip + smooth turning - Cons: Front can be lifted</p> <p>Questions: 1. Which would you choose for a scoring-focused robot? 2. Which would you choose for a defensive robot? 3. Can you think of other combinations?</p>"},{"location":"01-physics-foundations/03-friction-and-traction/#answers","title":"Answers","text":"<ol> <li> <p>Scoring-focused: Option A (omni) or Option C (mixed) - you need maneuverability to quickly collect and score blocks</p> </li> <li> <p>Defensive robot: Option B (traction) - maximum grip to resist being pushed and to push opponents</p> </li> <li> <p>Other combinations:</p> </li> <li>2 omni (front) + 2 traction (back) - good for pushing while maintaining turning</li> <li>6-wheel drive with dropped center wheel - always 4 wheels touching for stability</li> <li>Mecanum for sideways movement (complex programming required)</li> </ol> <p>Ready to test your knowledge? Check out the Physics Q&amp;A Review!</p> <p>\u2190 Previous: Gears and Torque | Next: Physics Q&amp;A Review \u2192</p>"},{"location":"01-physics-foundations/04-review-qa/","title":"Physics Foundations: Q&amp;A Review","text":"<p>Use this document to test your understanding of Tutorials 1.1-1.3</p> <p>Complete all sections, then check your answers at the end. Aim for 80% or better before moving on!</p>"},{"location":"01-physics-foundations/04-review-qa/#section-1-true-or-false-15-questions","title":"Section 1: True or False (15 Questions)","text":"<p>Write T (True) or F (False) for each statement.</p>"},{"location":"01-physics-foundations/04-review-qa/#forces-and-motion","title":"Forces and Motion","text":"<ol> <li>___ An object at rest will stay at rest forever unless a force acts on it.</li> <li>___ A heavier robot needs more force to accelerate at the same rate as a lighter robot.</li> <li>___ Momentum only depends on how fast an object is moving.</li> <li>___ If you double the force on a robot, its acceleration doubles (assuming mass stays the same).</li> <li>___ A light robot is always better than a heavy robot in competition.</li> </ol>"},{"location":"01-physics-foundations/04-review-qa/#gears-and-torque","title":"Gears and Torque","text":"<ol> <li>___ The BLUE (6:1) gear cartridge provides the most torque.</li> <li>___ A higher gear ratio means more speed but less torque.</li> <li>___ The GREEN (18:1) cartridge is a good choice for drivetrains because it balances speed and torque.</li> <li>___ If you change the gear cartridge in code, you don't need to change it physically in the motor.</li> <li>___ Bigger wheels cover more distance per rotation but need more torque to accelerate.</li> </ol>"},{"location":"01-physics-foundations/04-review-qa/#friction-and-traction","title":"Friction and Traction","text":"<ol> <li>___ Static friction is weaker than kinetic (moving) friction.</li> <li>___ Omni wheels have rollers that allow them to slide sideways.</li> <li>___ Traction wheels are the best choice for easy turning.</li> <li>___ Keeping the center of gravity low makes a robot more stable.</li> <li>___ A wider track width makes a robot turn faster.</li> </ol>"},{"location":"01-physics-foundations/04-review-qa/#section-2-multiple-choice-20-questions","title":"Section 2: Multiple Choice (20 Questions)","text":"<p>Circle the best answer for each question.</p>"},{"location":"01-physics-foundations/04-review-qa/#forces-and-motion_1","title":"Forces and Motion","text":"<p>1. Newton's First Law says that objects: - A) Always accelerate when force is applied - B) Stay at rest or keep moving unless acted on by a force - C) Move faster when they're heavier - D) Stop immediately when force is removed</p> <p>2. A robot weighs 10 kg and accelerates at 2 m/s\u00b2. What force do the motors provide? - A) 5 Newtons - B) 12 Newtons - C) 20 Newtons - D) 8 Newtons</p> <p>3. Which has MORE momentum: a 5 kg robot at 4 m/s OR a 10 kg robot at 2 m/s? - A) The 5 kg robot - B) The 10 kg robot - C) They have equal momentum - D) Cannot determine without more information</p> <p>4. In Push Back, why might you want a heavier robot? - A) It's faster - B) It's harder to push around - C) It uses less battery - D) It turns more easily</p> <p>5. The <code>clamp()</code> function in code is used to: - A) Connect motors together - B) Limit values between a minimum and maximum - C) Calculate momentum - D) Measure friction</p> <p>6. When you push an opponent robot, they push back on you. This is: - A) Newton's First Law - B) Newton's Second Law - C) Newton's Third Law - D) The Law of Friction</p> <p>7. If you want a robot to accelerate faster, you should: - A) Add more weight - B) Reduce motor power - C) Increase motor force - D) Use smaller wheels</p>"},{"location":"01-physics-foundations/04-review-qa/#gears-and-torque_1","title":"Gears and Torque","text":"<p>8. Torque is best described as: - A) Speed of rotation - B) Twisting or rotational force - C) Distance traveled per minute - D) The weight of a gear</p> <p>9. Which VEX V5 cartridge should you use for a flywheel that needs to spin very fast? - A) RED (36:1) - B) GREEN (18:1) - C) BLUE (6:1) - D) Any cartridge works the same</p> <p>10. What does a 36:1 gear ratio mean? - A) The motor spins 36 times for every 1 output rotation - B) The output is 36 times faster than the motor - C) The motor provides 36 Newtons of force - D) The wheel is 36 inches in diameter</p> <p>11. If the GREEN cartridge gives 200 RPM, what does the RED cartridge give? - A) 600 RPM - B) 400 RPM - C) 100 RPM - D) 50 RPM</p> <p>12. You need to lift a heavy arm. Which cartridge provides the most torque? - A) BLUE (6:1) - B) GREEN (18:1) - C) RED (36:1) - D) They all provide the same torque</p> <p>13. Your robot uses 4-inch wheels with GREEN cartridges (200 RPM). What is the wheel circumference? - A) About 100 mm - B) About 200 mm - C) About 319 mm - D) About 400 mm</p> <p>14. If you switch from GREEN (18:1) to BLUE (6:1) cartridges, your robot will: - A) Be slower with more pushing power - B) Be faster with less pushing power - C) Have the same speed and power - D) Use less battery</p>"},{"location":"01-physics-foundations/04-review-qa/#friction-and-traction_1","title":"Friction and Traction","text":"<p>15. Why do omni wheels make turning easier? - A) They're lighter - B) They have rollers that slide sideways - C) They spin faster - D) They have more friction</p> <p>16. Which wheel type provides the MOST friction/grip? - A) Omni wheels - B) Traction wheels - C) Mecanum wheels - D) All wheels have equal friction</p> <p>17. Static friction helps your robot because: - A) It makes the robot slide easier - B) Wheels grip the floor before the robot moves - C) It reduces battery usage - D) It makes turns faster</p> <p>18. A robot with a HIGH center of gravity is: - A) More stable - B) Less likely to tip - C) More likely to tip - D) Faster</p> <p>19. In Push Back, a defensive robot should probably use: - A) All omni wheels for speed - B) Traction wheels for grip - C) Mecanum wheels for strafing - D) No wheels</p> <p>20. What happens when wheels spin faster than they can grip the floor? - A) The robot accelerates faster - B) The wheels \"burn out\" and the robot doesn't move efficiently - C) The robot stops immediately - D) Friction increases</p>"},{"location":"01-physics-foundations/04-review-qa/#section-3-fill-in-the-blank-10-questions","title":"Section 3: Fill in the Blank (10 Questions)","text":"<p>Complete each statement with the correct word or value.</p> <ol> <li> <p>Force = _ \u00d7 Acceleration</p> </li> <li> <p>Momentum = Mass \u00d7 _</p> </li> <li> <p>The BLUE gear cartridge spins at _ RPM.</p> </li> <li> <p>The GREEN gear cartridge has a ratio of _:1.</p> </li> <li> <p>Higher gear ratios provide more _ but less speed.</p> </li> <li> <p>_ friction is the force that prevents objects from sliding when they're not moving yet.</p> </li> <li> <p>_ wheels have small rollers around their edges.</p> </li> <li> <p>The center of _ is the balance point of a robot.</p> </li> <li> <p>Your robot's track width is the distance between the _ and _ wheels.</p> </li> <li> <p>When wheels spin but the robot doesn't move, there's not enough _.</p> </li> </ol>"},{"location":"01-physics-foundations/04-review-qa/#section-4-calculation-problems-10-questions","title":"Section 4: Calculation Problems (10 Questions)","text":"<p>Show your work for each problem.</p>"},{"location":"01-physics-foundations/04-review-qa/#force-calculations","title":"Force Calculations","text":"<p>1. Robot A weighs 6 kg. What force is needed to accelerate it at 3 m/s\u00b2? <pre><code>F = m \u00d7 a\nF = ___ \u00d7 ___\nF = ___ Newtons\n</code></pre></p> <p>2. Robot B weighs 12 kg and its motors provide 24 Newtons of force. What is its acceleration? <pre><code>a = F \u00f7 m\na = ___ \u00f7 ___\na = ___ m/s\u00b2\n</code></pre></p> <p>3. You want Robot C (8 kg) to accelerate at 4 m/s\u00b2. What force is needed? <pre><code>F = ___ \u00d7 ___\nF = ___ Newtons\n</code></pre></p>"},{"location":"01-physics-foundations/04-review-qa/#momentum-calculations","title":"Momentum Calculations","text":"<p>4. Calculate the momentum of a 7 kg robot moving at 3 m/s. <pre><code>p = m \u00d7 v\np = ___ \u00d7 ___\np = ___ kg\u00b7m/s\n</code></pre></p> <p>5. Robot X (4 kg, 5 m/s) vs Robot Y (10 kg, 2 m/s). Which has more momentum? <pre><code>Robot X: p = ___ \u00d7 ___ = ___ kg\u00b7m/s\nRobot Y: p = ___ \u00d7 ___ = ___ kg\u00b7m/s\nWinner: Robot ___\n</code></pre></p>"},{"location":"01-physics-foundations/04-review-qa/#gear-calculations","title":"Gear Calculations","text":"<p>6. A motor provides 2 N\u00b7m of torque through a RED (36:1) cartridge. What is the output torque? <pre><code>Output Torque = Input Torque \u00d7 Gear Ratio\nOutput Torque = ___ \u00d7 ___\nOutput Torque = ___ N\u00b7m\n</code></pre></p> <p>7. With BLUE cartridges (600 RPM) and 4\" wheels (319 mm circumference), how far does the robot travel in 1 minute? <pre><code>Distance = RPM \u00d7 Circumference\nDistance = ___ \u00d7 ___ mm\nDistance = ___ mm = ___ meters\n</code></pre></p> <p>8. If you have a 60-tooth wheel gear and a 12-tooth motor gear, what is the external gear ratio? <pre><code>Ratio = ___ \u00f7 ___\nRatio = ___:1\n</code></pre></p>"},{"location":"01-physics-foundations/04-review-qa/#speed-calculations","title":"Speed Calculations","text":"<p>9. Robot with GREEN cartridge (200 RPM), 4\" wheels (319 mm). What is the speed in m/s? <pre><code>Distance per minute = 200 \u00d7 319 mm = ___ mm\nSpeed = ___ mm \u00f7 60 seconds = ___ mm/s\nSpeed = ___ m/s\n</code></pre></p> <p>10. If you switch to RED cartridges (100 RPM) with the same wheels, what's the new speed? <pre><code>Speed = (100 \u00d7 319) \u00f7 60 = ___ mm/s = ___ m/s\n</code></pre></p>"},{"location":"01-physics-foundations/04-review-qa/#section-5-scenario-based-questions-8-questions","title":"Section 5: Scenario-Based Questions (8 Questions)","text":"<p>Choose the best solution for each competition scenario.</p> <p>1. Your robot keeps getting pushed backward by opponents. What could you change? (Select all that apply) - [ ] A) Switch from omni to traction wheels - [ ] B) Add weight to the robot - [ ] C) Use RED cartridges instead of GREEN - [ ] D) Use BLUE cartridges instead of GREEN</p> <p>2. Your drivetrain is too slow but you have plenty of pushing power. What should you change? - A) Switch to RED (36:1) cartridges - B) Switch to BLUE (6:1) cartridges - C) Add more weight - D) Use smaller wheels</p> <p>3. Your robot tips over when turning quickly. What's the best fix? - A) Move the battery higher - B) Move heavy components lower - C) Use a narrower wheel base - D) Increase motor speed</p> <p>4. You need an intake mechanism that spins rollers very fast to grab blocks. Which cartridge? - A) RED (36:1) for maximum grip - B) GREEN (18:1) for balance - C) BLUE (6:1) for speed - D) It doesn't matter</p> <p>5. Your autonomous routine needs to turn exactly 90 degrees, but the robot overshoots. What's likely the problem? - A) Not enough friction - B) Too much momentum carrying the robot past the target - C) The battery is low - D) The gear ratio is wrong</p> <p>6. During a match, your wheels are spinning but the robot isn't moving well on a dusty floor. Why? - A) Too much static friction - B) Not enough friction between wheels and floor - C) The motors are too powerful - D) The gear ratio is too high</p> <p>7. You're building a defensive robot that needs to block opponents. Prioritize these features (1=most important): - ___ Maximum speed - ___ Maximum pushing power (torque) - ___ Easy turning - ___ Stability (low center of gravity)</p> <p>8. Your alliance partner has a fast scoring robot. What should YOUR robot focus on? - A) Also being fast at scoring - B) Defense and blocking opponents - C) Having the exact same design - D) Using all omni wheels</p>"},{"location":"01-physics-foundations/04-review-qa/#section-6-match-the-terms-15-pairs","title":"Section 6: Match the Terms (15 Pairs)","text":"<p>Draw lines or write the matching letter.</p>"},{"location":"01-physics-foundations/04-review-qa/#set-a-concepts-and-definitions","title":"Set A: Concepts and Definitions","text":"Term Definition 1. Torque A. Resistance between surfaces 2. Friction B. Balance point of an object 3. Momentum C. Rotational force 4. Acceleration D. How much the motor is geared down 5. Gear Ratio E. Mass \u00d7 Velocity 6. Center of Gravity F. Change in velocity over time"},{"location":"01-physics-foundations/04-review-qa/#set-b-analogies-and-physics-concepts","title":"Set B: Analogies and Physics Concepts","text":"Analogy Concept 7. Bicycle gears G. Newton's Third Law 8. Running on ice vs grass H. Gear ratios (torque vs speed) 9. Shopping cart (empty vs full) I. Friction 10. Push opponent, they push back J. Mass affects acceleration"},{"location":"01-physics-foundations/04-review-qa/#set-c-wheel-types-and-use-cases","title":"Set C: Wheel Types and Use Cases","text":"Wheel Type Best Use 11. Traction wheels K. Smooth turning on tank drive 12. Omni wheels L. Maximum grip for pushing 13. Mecanum wheels M. Moving in any direction"},{"location":"01-physics-foundations/04-review-qa/#set-d-cartridges-and-applications","title":"Set D: Cartridges and Applications","text":"Cartridge Best Application 14. BLUE (6:1) N. Drivetrain (balanced) 15. RED (36:1) O. Flywheel/intake (speed) 16. GREEN (18:1) P. Lift arm (strength)"},{"location":"01-physics-foundations/04-review-qa/#section-7-diagram-labeling-3-diagrams","title":"Section 7: Diagram Labeling (3 Diagrams)","text":""},{"location":"01-physics-foundations/04-review-qa/#diagram-1-forces-on-a-moving-robot","title":"Diagram 1: Forces on a Moving Robot","text":"<p>Label the forces A, B, C, D on this diagram:</p> <pre><code>                    [C]\n                     \u2193\n              +--------+\n         [A]\u2190 |  ROBOT | \u2192[B]\n              +--[O][O]+\n                  \u2191\n                 [D]\n              \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n</code></pre> <p>Options: Friction, Motor Force (forward), Gravity, Normal Force (floor pushing up)</p> <p>A = ___ B = __ C = _ D = ____</p>"},{"location":"01-physics-foundations/04-review-qa/#diagram-2-gear-ratio-identification","title":"Diagram 2: Gear Ratio Identification","text":"<p>Which setup gives MORE TORQUE at the output?</p> <pre><code>Setup 1:                    Setup 2:\n\n  [Small]\u2500\u2500[Large]            [Large]\u2500\u2500[Small]\n  Motor    Output             Motor    Output\n     12     36 teeth             36      12 teeth\n</code></pre> <p>Answer: Setup ___ gives more torque because ___</p>"},{"location":"01-physics-foundations/04-review-qa/#diagram-3-wheel-type-identification","title":"Diagram 3: Wheel Type Identification","text":"<p>Identify each wheel type:</p> <pre><code>   Type A              Type B              Type C\n\n   +====+              +----+              +----+\n   |\u2588\u2588\u2588\u2588|              | \u27cb\u27cb |              | \u2572\u2572 |\n   |\u2588\u2588\u2588\u2588|              | \u27cb\u27cb |              | \u2572\u2572 |\n   +====+              +----+              +----+\n\n   Rubber tread        Side rollers        Angled rollers\n</code></pre> <p>A = ___ B = __ C = ____</p>"},{"location":"01-physics-foundations/04-review-qa/#answer-key","title":"Answer Key","text":""},{"location":"01-physics-foundations/04-review-qa/#section-1-true-or-false","title":"Section 1: True or False","text":"<ol> <li>T - Newton's First Law (objects at rest stay at rest)</li> <li>T - F = ma, so more mass needs more force for same acceleration</li> <li>F - Momentum = mass \u00d7 velocity (depends on both)</li> <li>T - F = ma, double F means double a (if m is constant)</li> <li>F - Trade-off: heavy = harder to push, light = faster but easier to push</li> <li>F - BLUE has the LEAST torque (more speed)</li> <li>F - OPPOSITE! Higher ratio = more torque, less speed</li> <li>T - GREEN (18:1) is balanced, commonly used for drivetrains</li> <li>F - You MUST change both code AND physical cartridge</li> <li>T - Bigger wheels = more distance, but need more force to accelerate</li> <li>F - Static friction is STRONGER than kinetic</li> <li>T - That's exactly what the rollers do</li> <li>F - Traction wheels make turning HARDER (scrubbing)</li> <li>T - Low center of gravity = more stable</li> <li>F - Wider track width = slower turns, but more stable</li> </ol>"},{"location":"01-physics-foundations/04-review-qa/#section-2-multiple-choice","title":"Section 2: Multiple Choice","text":"<ol> <li>B - Objects stay at rest or keep moving unless acted on</li> <li>C - F = 10 \u00d7 2 = 20 Newtons</li> <li>C - Both = 20 kg\u00b7m/s (5\u00d74 = 20, 10\u00d72 = 20)</li> <li>B - Harder to push around (Newton's Laws)</li> <li>B - Limits values between min and max</li> <li>C - Newton's Third Law (action/reaction)</li> <li>C - More force = more acceleration (F = ma)</li> <li>B - Torque is twisting/rotational force</li> <li>C - BLUE (6:1) = highest speed</li> <li>A - Motor spins 36 times per 1 output rotation</li> <li>C - RED = 100 RPM (half of GREEN's 200 RPM)</li> <li>C - RED (36:1) provides the most torque</li> <li>C - 4 \u00d7 \u03c0 \u00d7 25.4 \u2248 319 mm</li> <li>B - BLUE = faster but less pushing power</li> <li>B - Rollers allow sideways sliding</li> <li>B - Traction wheels have rubber tread</li> <li>B - Wheels grip before moving</li> <li>C - High CG = more likely to tip</li> <li>B - Traction for maximum grip</li> <li>B - \"Burn out\" - wheels spin without moving robot</li> </ol>"},{"location":"01-physics-foundations/04-review-qa/#section-3-fill-in-the-blank","title":"Section 3: Fill in the Blank","text":"<ol> <li>Mass</li> <li>Velocity</li> <li>600</li> <li>18</li> <li>Torque</li> <li>Static</li> <li>Omni</li> <li>Gravity (Center of Gravity)</li> <li>Left and Right</li> <li>Friction</li> </ol>"},{"location":"01-physics-foundations/04-review-qa/#section-4-calculation-problems","title":"Section 4: Calculation Problems","text":"<ol> <li>F = 6 \u00d7 3 = 18 Newtons</li> <li>a = 24 \u00f7 12 = 2 m/s\u00b2</li> <li>F = 8 \u00d7 4 = 32 Newtons</li> <li>p = 7 \u00d7 3 = 21 kg\u00b7m/s</li> <li>Robot X: 4 \u00d7 5 = 20, Robot Y: 10 \u00d7 2 = 20, Tie!</li> <li>Output = 2 \u00d7 36 = 72 N\u00b7m</li> <li>Distance = 600 \u00d7 319 = 191,400 mm = 191.4 meters</li> <li>Ratio = 60 \u00f7 12 = 5:1</li> <li>200 \u00d7 319 = 63,800 mm/min \u00f7 60 = 1,063 mm/s = 1.06 m/s</li> <li>100 \u00d7 319 \u00f7 60 = 532 mm/s = 0.53 m/s</li> </ol>"},{"location":"01-physics-foundations/04-review-qa/#section-5-scenario-based-questions","title":"Section 5: Scenario-Based Questions","text":"<ol> <li>A, B, C - All help resist pushing (D would make it worse!)</li> <li>B - BLUE gives more speed</li> <li>B - Lower center of gravity = more stable</li> <li>C - BLUE for speed</li> <li>B - Momentum carries the robot past the target</li> <li>B - Dust reduces friction</li> <li>Suggested priority: 2, 1, 4, 3 (Torque first for blocking, then stability, then speed, then turning)</li> <li>B - Complement your partner with defense</li> </ol>"},{"location":"01-physics-foundations/04-review-qa/#section-6-match-the-terms","title":"Section 6: Match the Terms","text":"<p>Set A: 1-C, 2-A, 3-E, 4-F, 5-D, 6-B Set B: 7-H, 8-I, 9-J, 10-G Set C: 11-L, 12-K, 13-M Set D: 14-O, 15-P, 16-N</p>"},{"location":"01-physics-foundations/04-review-qa/#section-7-diagram-labeling","title":"Section 7: Diagram Labeling","text":""},{"location":"01-physics-foundations/04-review-qa/#diagram-1","title":"Diagram 1:","text":"<ul> <li>A = Motor Force (forward)</li> <li>B = Friction (from floor pushing back)</li> <li>C = Gravity (weight pulling down)</li> <li>D = Normal Force (floor pushing up)</li> </ul>"},{"location":"01-physics-foundations/04-review-qa/#diagram-2","title":"Diagram 2:","text":"<p>Setup 1 gives more torque because the output gear is larger than the input (3:1 ratio), which multiplies torque.</p>"},{"location":"01-physics-foundations/04-review-qa/#diagram-3","title":"Diagram 3:","text":"<ul> <li>A = Traction wheel</li> <li>B = Omni wheel</li> <li>C = Mecanum wheel</li> </ul>"},{"location":"01-physics-foundations/04-review-qa/#score-yourself","title":"Score Yourself","text":"Section Your Score Possible True/False ___ 15 Multiple Choice ___ 20 Fill in Blank ___ 10 Calculations ___ 10 Scenarios ___ 8 Matching ___ 16 Diagrams ___ 10 TOTAL ___ 89 <p>Percentage: ___ \u00f7 89 \u00d7 100 = ___%</p> <ul> <li>90-100%: Excellent! Ready for Tutorial 2.</li> <li>80-89%: Good job! Review missed concepts.</li> <li>70-79%: Review Tutorials 1.1-1.3 before continuing.</li> <li>Below 70%: Re-read the tutorials and try again!</li> </ul> <p>\u2190 Previous: Friction and Traction | Next: Robot Anatomy \u2192</p>"},{"location":"02-robot-anatomy/01-brain-and-controller/","title":"Tutorial 2.1: Brain and Controller","text":"<p>Time: ~10 minutes Prerequisites: Tutorial 1: Physics Foundations</p>"},{"location":"02-robot-anatomy/01-brain-and-controller/#the-v5-brain-your-robots-computer","title":"The V5 Brain: Your Robot's Computer","text":"<p>The VEX V5 Brain is like a small computer that runs your Python code and controls all the robot's motors and sensors.</p> <pre><code>flowchart TB\n    subgraph BRAIN[\"V5 BRAIN\"]\n        direction TB\n        subgraph TOP[\"Top Row\"]\n            direction LR\n            SCREEN[\"TOUCHSCREEN&lt;br/&gt;480 x 272 pixels\"]\n            POWER[\"Power Button\"]\n            BATTERY[\"BATTERY SLOT\"]\n        end\n        subgraph PORTS[\"SMART PORTS (21 total)\"]\n            direction LR\n            P1[\"1\"] --- P2[\"2\"] --- P3[\"3\"] --- P4[\"4\"] --- P5[\"5\"] --- P6[\"...\"] --- P21[\"21\"]\n        end\n        subgraph BOTTOM[\"Bottom Row\"]\n            direction LR\n            USB[\"USB-C Port&lt;br/&gt;(download code)\"]\n            RADIO[\"Radio&lt;br/&gt;(wireless controller)\"]\n        end\n    end</code></pre>"},{"location":"02-robot-anatomy/01-brain-and-controller/#key-features","title":"Key Features","text":"Feature What It Does Touchscreen Shows robot status, select programs 21 Smart Ports Connect motors and sensors USB-C Port Download your code from computer Radio Module Communicates with controller wirelessly Battery Slot Powers everything CPU Runs your Python code"},{"location":"02-robot-anatomy/01-brain-and-controller/#port-numbers","title":"Port Numbers","text":"<p>Your robot's motors are plugged into specific ports. Here's your current setup:</p> <pre><code>flowchart LR\n    subgraph PORTS[\"Port Layout (Front View)\"]\n        direction LR\n        P1[\"Port 1&lt;br/&gt;LF\"] --&gt; LF[\"Left Front Motor\"]\n        P2[\"Port 2&lt;br/&gt;LB\"] --&gt; LB[\"Left Back Motor\"]\n        P3[\"Port 3&lt;br/&gt;RF\"] --&gt; RF[\"Right Front Motor&lt;br/&gt;(reversed)\"]\n        P4[\"Port 4&lt;br/&gt;RB\"] --&gt; RB[\"Right Back Motor&lt;br/&gt;(reversed)\"]\n    end</code></pre>"},{"location":"02-robot-anatomy/01-brain-and-controller/#code-connection-brain-setup","title":"Code Connection: Brain Setup","text":"<p>From <code>src/robot_config.py</code>:</p> <pre><code>from vex import *\n\n# Create Brain object - represents the physical V5 Brain\nbrain = Brain()\n</code></pre> <p>That's it! One line creates the brain object. The <code>Brain()</code> class gives you access to: - <code>brain.screen</code> - draw on the touchscreen - <code>brain.timer</code> - track time - <code>brain.battery</code> - check battery level</p>"},{"location":"02-robot-anatomy/01-brain-and-controller/#using-the-brain-screen","title":"Using the Brain Screen","text":"<p>From <code>src/main.py</code>:</p> <pre><code>def main():\n    brain.screen.clear_screen()        # Erase everything\n    brain.screen.set_cursor(1, 1)      # Move to row 1, column 1\n    brain.screen.print(\"Robot Ready!\") # Display text\n</code></pre> <p>The screen is useful for: - Showing what mode the robot is in - Debugging (print variable values) - Showing battery level - Displaying autonomous status</p>"},{"location":"02-robot-anatomy/01-brain-and-controller/#the-v5-controller-your-game-controller","title":"The V5 Controller: Your Game Controller","text":"<p>The V5 Controller looks and feels like an Xbox or PlayStation controller:</p> <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                      V5 CONTROLLER                           \u2502\n    \u2502                                                              \u2502\n    \u2502       [L1]                                    [R1]           \u2502\n    \u2502       [L2]                                    [R2]           \u2502\n    \u2502                                                              \u2502\n    \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              [LOGO]           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502\n    \u2502    \u2502 LEFT  \u2502                               \u2502 RIGHT \u2502        \u2502\n    \u2502    \u2502 STICK \u2502   [ \u25b2 ]   [A]   [B]          \u2502 STICK \u2502        \u2502\n    \u2502    \u2502       \u2502  [\u25c4] [\u25ba]                      \u2502       \u2502        \u2502\n    \u2502    \u2502  Axis \u2502   [ \u25bc ]   [X]   [Y]          \u2502 Axis  \u2502        \u2502\n    \u2502    \u2502  3,4  \u2502                              \u2502  1,2  \u2502        \u2502\n    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502\n    \u2502                                                              \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"02-robot-anatomy/01-brain-and-controller/#joystick-axes","title":"Joystick Axes","text":"<p>Each joystick has two axes (directions it can move):</p> <pre><code>    LEFT JOYSTICK              RIGHT JOYSTICK\n\n         Axis4 (X)                  Axis1 (X)\n           \u2190 \u2192                        \u2190 \u2192\n            \u2191                          \u2191\n    Axis3 (Y)                  Axis2 (Y)\n            \u2193                          \u2193\n\n    Axis3 = Up/Down            Axis2 = Up/Down\n    Axis4 = Left/Right         Axis1 = Left/Right\n</code></pre> <p>Values range from -100 to +100: - 0 = Centered - +100 = Full forward (or full right) - -100 = Full backward (or full left)</p>"},{"location":"02-robot-anatomy/01-brain-and-controller/#code-connection-controller-setup","title":"Code Connection: Controller Setup","text":"<p>From <code>src/robot_config.py</code>:</p> <pre><code># Create controller object - PRIMARY is the main controller\ncontroller = Controller(PRIMARY)\n</code></pre>"},{"location":"02-robot-anatomy/01-brain-and-controller/#reading-joystick-values","title":"Reading Joystick Values","text":"<p>From <code>src/driver_control.py</code>:</p> <pre><code>while True:\n    # Get joystick positions (-100 to 100)\n    left_speed = controller.axis3.position()   # Left joystick Y\n    right_speed = controller.axis2.position()  # Right joystick Y\n</code></pre>"},{"location":"02-robot-anatomy/01-brain-and-controller/#button-reference","title":"Button Reference","text":"Button Common Uses A, B, X, Y Activate mechanisms (intake, lift, etc.) L1, L2 Left bumpers - secondary controls R1, R2 Right bumpers - secondary controls D-Pad Mode switching, menu navigation"},{"location":"02-robot-anatomy/01-brain-and-controller/#reading-buttons","title":"Reading Buttons","text":"<pre><code># Check if button A is pressed\nif controller.buttonA.pressing():\n    # Do something!\n    intake_motor.spin(FORWARD)\n</code></pre>"},{"location":"02-robot-anatomy/01-brain-and-controller/#communication-between-brain-and-controller","title":"Communication Between Brain and Controller","text":"<p>The Brain and Controller talk wirelessly:</p> <pre><code>    Controller                         Brain\n\n    [CTRL]  \u2500\u2500\u2500\u2500\u2500radio waves\u2500\u2500\u2500\u2500\u2500&gt;  [BRAIN]\n\n    Sends:                         Receives:\n    - Joystick positions           - Controller inputs\n    - Button presses               - Updates screen\n    - D-pad direction              - Controls motors\n</code></pre> <p>Important: The controller must be paired with the brain before use!</p>"},{"location":"02-robot-anatomy/01-brain-and-controller/#wired-vs-wireless","title":"Wired vs. Wireless","text":"<p>You can also connect the controller with a cable:</p> <pre><code>    WIRELESS                    WIRED\n\n    [CTRL] ~~~wireless~~~&gt; [BRAIN]    [CTRL]===cable===[BRAIN]\n\n    Good for:                   Good for:\n    - Matches                   - Downloading code\n    - Practice                  - Troubleshooting\n    - Normal use                - Competition setup\n</code></pre>"},{"location":"02-robot-anatomy/01-brain-and-controller/#summary","title":"Summary","text":"Component Purpose Key Class V5 Brain Robot's computer, runs code <code>Brain()</code> 21 Ports Connect motors/sensors <code>Ports.PORT1</code> - <code>Ports.PORT21</code> Touchscreen Display info <code>brain.screen</code> V5 Controller Driver input <code>Controller(PRIMARY)</code> Joysticks Analog direction input <code>controller.axis1</code> - <code>axis4</code> Buttons Digital on/off input <code>controller.buttonA</code>, etc."},{"location":"02-robot-anatomy/01-brain-and-controller/#exercise-explore-the-controller","title":"Exercise: Explore the Controller","text":"<p>Goal: Write code that displays joystick values on the Brain screen.</p> <p>Look at this code snippet:</p> <pre><code>while True:\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n\n    left_y = controller.axis3.position()\n    brain.screen.print(\"Left Y: \" + str(left_y))\n\n    wait(100, MSEC)\n</code></pre> <p>Questions: 1. What does <code>controller.axis3.position()</code> return? 2. Why do we need <code>str(left_y)</code> when printing? 3. Why is there a <code>wait(100, MSEC)</code> at the end?</p>"},{"location":"02-robot-anatomy/01-brain-and-controller/#answers","title":"Answers","text":"<ol> <li>Returns a number from -100 to +100 representing the left joystick's vertical position</li> <li><code>print()</code> expects text, so we convert the number to a string with <code>str()</code></li> <li>Without the wait, the screen would update thousands of times per second, causing flickering. 100ms = 10 updates per second, which is smooth.</li> </ol> <p>\u2190 Previous: Friction and Traction | Next: Motors and Gears \u2192 | Review Q&amp;A</p>"},{"location":"02-robot-anatomy/02-motors-and-gears/","title":"Tutorial 2.2: Motors and Gears","text":"<p>Time: ~10 minutes Prerequisites: Tutorial 2.1: Brain and Controller</p>"},{"location":"02-robot-anatomy/02-motors-and-gears/#the-v5-smart-motor","title":"The V5 Smart Motor","text":"<p>The V5 Smart Motor is the most important component of your robot. It converts electrical power into rotational motion.</p> <pre><code>flowchart TB\n    subgraph MOTOR[\"V5 SMART MOTOR\"]\n        direction TB\n        subgraph CONNECTIONS[\"Connections\"]\n            direction LR\n            PORT[\"PORT&lt;br/&gt;Smart cable connects here\"]\n            SHAFT[\"OUTPUT SHAFT&lt;br/&gt;Rotates\"]\n        end\n        CARTRIDGE[\"GEAR CARTRIDGE SLOT&lt;br/&gt;(swap for different speeds/torque)\"]\n        subgraph INTERNAL[\"Internal Sensors\"]\n            direction LR\n            ENC[\"Encoder&lt;br/&gt;(rotation sensor)\"]\n            TEMP[\"Temperature&lt;br/&gt;sensor\"]\n            CURR[\"Current&lt;br/&gt;sensor\"]\n        end\n    end</code></pre>"},{"location":"02-robot-anatomy/02-motors-and-gears/#smart-features","title":"Smart Features","text":"<p>Unlike simple motors, V5 Smart Motors have built-in sensors:</p> Sensor What It Measures Why It's Useful Encoder Rotation count Know how far you've traveled Temperature Motor heat Prevent overheating Current Power usage Detect stalls/resistance Velocity Speed Accurate speed control"},{"location":"02-robot-anatomy/02-motors-and-gears/#motor-configuration-in-code","title":"Motor Configuration in Code","text":"<p>Let's look at <code>src/robot_config.py</code>:</p> <pre><code># Left side motors (not reversed - standard mounting)\nleft_motor_front = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nleft_motor_back = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\n\n# Right side motors (reversed - mirror mounting spins opposite)\nright_motor_front = Motor(Ports.PORT3, GearSetting.RATIO_18_1, True)\nright_motor_back = Motor(Ports.PORT4, GearSetting.RATIO_18_1, True)\n</code></pre>"},{"location":"02-robot-anatomy/02-motors-and-gears/#the-motor-constructor","title":"The Motor() Constructor","text":"<pre><code>Motor(port, gear_setting, reversed)\n</code></pre> Parameter What It Means Your Values <code>port</code> Which port on Brain PORT1, PORT2, PORT3, PORT4 <code>gear_setting</code> Cartridge type RATIO_18_1 (green) <code>reversed</code> Spin direction False (left), True (right)"},{"location":"02-robot-anatomy/02-motors-and-gears/#why-are-right-motors-reversed","title":"Why Are Right Motors Reversed?","text":"<p>This is one of the most common questions! Look at how motors are mounted:</p> <pre><code>    TOP VIEW OF ROBOT:\n\n         FRONT\n           \u2191\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502             \u2502\n    \u2502  LF     RF  \u2502\n    \u2502  [\u2192]   [\u2190]  \u2502  \u2190 Motors face OUTWARD\n    \u2502             \u2502\n    \u2502  LB     RB  \u2502\n    \u2502  [\u2192]   [\u2190]  \u2502\n    \u2502             \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Left motors:  Clockwise = Forward\n    Right motors: Clockwise = BACKWARD (opposite!)\n</code></pre> <p>Solution: Tell the code to reverse right motors:</p> <pre><code># Left: clockwise = forward (normal)\nleft_motor_front = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\n\n# Right: clockwise = backward, so REVERSE it!\nright_motor_front = Motor(Ports.PORT3, GearSetting.RATIO_18_1, True)\n</code></pre> <p>Now when you tell both motors to spin \"forward,\" they actually move the robot forward!</p>"},{"location":"02-robot-anatomy/02-motors-and-gears/#motor-groups","title":"Motor Groups","text":"<p>Individual motors are useful, but for a drivetrain, we want to control multiple motors together:</p> <pre><code># Group left motors together\nleft_motors = MotorGroup(left_motor_front, left_motor_back)\n\n# Group right motors together\nright_motors = MotorGroup(right_motor_front, right_motor_back)\n</code></pre>"},{"location":"02-robot-anatomy/02-motors-and-gears/#why-use-motor-groups","title":"Why Use Motor Groups?","text":"<pre><code># WITHOUT MotorGroup (tedious):\nleft_motor_front.spin(FORWARD, 50, PERCENT)\nleft_motor_back.spin(FORWARD, 50, PERCENT)\n\n# WITH MotorGroup (simple):\nleft_motors.spin(FORWARD, 50, PERCENT)\n</code></pre> <p>One command controls both motors at once!</p>"},{"location":"02-robot-anatomy/02-motors-and-gears/#common-motor-methods","title":"Common Motor Methods","text":""},{"location":"02-robot-anatomy/02-motors-and-gears/#setting-velocity","title":"Setting Velocity","text":"<pre><code># Set speed (doesn't start spinning yet)\nmotor.set_velocity(50, PERCENT)   # 50% of max speed\n\n# Different units:\nmotor.set_velocity(200, RPM)      # 200 rotations per minute\nmotor.set_velocity(100, DPS)      # 100 degrees per second\n</code></pre>"},{"location":"02-robot-anatomy/02-motors-and-gears/#spinning-the-motor","title":"Spinning the Motor","text":"<pre><code># Start spinning\nmotor.spin(FORWARD)               # Spin forward at set velocity\nmotor.spin(REVERSE)               # Spin backward\n\n# Spin with specific velocity\nmotor.spin(FORWARD, 75, PERCENT)  # 75% speed forward\n</code></pre>"},{"location":"02-robot-anatomy/02-motors-and-gears/#stopping-the-motor","title":"Stopping the Motor","text":"<pre><code>motor.stop()                      # Stop with default mode\n\n# Stop modes:\nmotor.set_stopping(COAST)         # Free-spin to stop\nmotor.set_stopping(BRAKE)         # Active braking\nmotor.set_stopping(HOLD)          # Hold position firmly\n</code></pre> <pre><code>    COAST                BRAKE                HOLD\n\n    \u27f3 \u2192 \u27f3 \u2192 \u27f3 \u2192 stop     \u27f3 \u2192 \u27f3 \u2192 X           \u27f3 \u2192 X (locked!)\n    Slowly coasts        Quick stop           Resists movement\n</code></pre>"},{"location":"02-robot-anatomy/02-motors-and-gears/#reading-motor-values","title":"Reading Motor Values","text":"<pre><code>motor.velocity(PERCENT)           # Current speed\nmotor.position(DEGREES)           # Total rotation in degrees\nmotor.temperature(FAHRENHEIT)     # Motor temperature\nmotor.current()                   # Current power draw\n</code></pre>"},{"location":"02-robot-anatomy/02-motors-and-gears/#the-drivetrain-class","title":"The DriveTrain Class","text":"<p>For easier autonomous movement, we wrap everything in a DriveTrain:</p> <pre><code>drivetrain = DriveTrain(\n    left_motors,           # Left MotorGroup\n    right_motors,          # Right MotorGroup\n    WHEEL_TRAVEL_MM,       # Wheel circumference (319.19mm)\n    TRACK_WIDTH_MM,        # Distance between wheels (295mm)\n    WHEEL_BASE_MM,         # Front-to-back distance (200mm)\n    MM,                    # Units\n    EXTERNAL_GEAR_RATIO    # External gearing (1 = direct)\n)\n</code></pre>"},{"location":"02-robot-anatomy/02-motors-and-gears/#drivetrain-methods","title":"DriveTrain Methods","text":"<pre><code># Autonomous movements\ndrivetrain.drive_for(FORWARD, 500, MM)     # Drive 500mm forward\ndrivetrain.turn_for(RIGHT, 90, DEGREES)    # Turn 90\u00b0 right\n\n# Speed settings\ndrivetrain.set_drive_velocity(50, PERCENT)  # Set drive speed\ndrivetrain.set_turn_velocity(30, PERCENT)   # Set turn speed\n\n# Stopping mode\ndrivetrain.set_stopping(BRAKE)\n</code></pre>"},{"location":"02-robot-anatomy/02-motors-and-gears/#motor-wiring-diagram","title":"Motor Wiring Diagram","text":"<p>Here's how your robot is wired:</p> <pre><code>    V5 BRAIN PORTS:\n\n    [1]\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500[3]\n    Left     \u2502     \u2502     Right\n    Front    \u2502     \u2502     Front\n             \u2502     \u2502     (reversed)\n    [2]\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u251c\u2500\u2500\u2500\u2500\u2500\u2500[4]\n    Left     \u2502     \u2502     Right\n    Back     \u2502     \u2502     Back\n             \u2502     \u2502     (reversed)\n             \u2193     \u2193\n\n         LEFT SIDE    RIGHT SIDE\n\n         [LF] [LB]    [RF] [RB]\n           \u2193   \u2193        \u2193   \u2193\n         +--------+  +--------+\n         |        |  |        |\n         +--[O][O]+  +[O][O]--+\n\n              ROBOT (top view)\n</code></pre>"},{"location":"02-robot-anatomy/02-motors-and-gears/#summary","title":"Summary","text":"Concept Purpose Code Motor Single motor object <code>Motor(port, gear, reversed)</code> Reversed Flip direction <code>True</code> for right side motors MotorGroup Control multiple <code>MotorGroup(motor1, motor2)</code> DriveTrain High-level driving <code>drivetrain.drive_for()</code> spin() Start motor <code>motor.spin(FORWARD)</code> stop() Stop motor <code>motor.stop()</code>"},{"location":"02-robot-anatomy/02-motors-and-gears/#exercise-add-a-fifth-motor","title":"Exercise: Add a Fifth Motor","text":"<p>Goal: Add an intake motor to <code>robot_config.py</code></p> <p>Imagine you're adding a motor on Port 5 for an intake mechanism: - It should spin at high speed (use BLUE cartridge) - It doesn't need to be reversed</p> <p>Write the code:</p> <pre><code># Add this line to robot_config.py:\nintake_motor = Motor(_____, GearSetting._____, _____)\n</code></pre> <p>Bonus: How would you make it spin forward when button R1 is pressed?</p>"},{"location":"02-robot-anatomy/02-motors-and-gears/#answers","title":"Answers","text":"<pre><code>intake_motor = Motor(Ports.PORT5, GearSetting.RATIO_6_1, False)\n</code></pre> <p>Bonus - Button control: <pre><code># In driver_control.py, inside the while loop:\nif controller.buttonR1.pressing():\n    intake_motor.spin(FORWARD, 100, PERCENT)\nelse:\n    intake_motor.stop()\n</code></pre></p> <p>\u2190 Previous: Brain and Controller | Next: Sensors Overview \u2192 | Review Q&amp;A</p>"},{"location":"02-robot-anatomy/03-sensors-overview/","title":"Tutorial 2.3: Sensors Overview","text":"<p>Time: ~10 minutes Prerequisites: Tutorial 2.2: Motors and Gears</p>"},{"location":"02-robot-anatomy/03-sensors-overview/#what-are-sensors","title":"What Are Sensors?","text":"<p>Sensors let your robot \"see\" and \"feel\" the world around it. Without sensors, your robot is blind - it just follows instructions without knowing what's actually happening.</p> <pre><code>    Without Sensors:              With Sensors:\n\n    \"Drive forward 1000mm\"        \"Drive until you see a wall\"\n\n    +--------+                    +--------+\n    |  BLIND |  \u2192\u2192\u2192\u2192\u2192 CRASH!      | SENSOR |  \u2192\u2192\u2192\u2192 STOP!\n    +--[O][O]+                    +--[O][O]+\n                                       \u2191\n                                  \"I see something!\"\n</code></pre>"},{"location":"02-robot-anatomy/03-sensors-overview/#available-vex-v5-sensors","title":"Available VEX V5 Sensors","text":""},{"location":"02-robot-anatomy/03-sensors-overview/#inertial-sensor-imu","title":"Inertial Sensor (IMU)","text":"<p>Like a compass + tilt sensor combined</p> <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   INERTIAL  \u2502\n    \u2502   SENSOR    \u2502\n    \u2502             \u2502\n    \u2502  Measures:  \u2502\n    \u2502  - Heading  \u2502  \u2190 Which way you're pointing\n    \u2502  - Rotation \u2502  \u2190 How much you've turned\n    \u2502  - Tilt     \u2502  \u2190 Are you level?\n    \u2502  - Accel    \u2502  \u2190 Are you moving?\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Best for: Accurate turning in autonomous, detecting collisions</p>"},{"location":"02-robot-anatomy/03-sensors-overview/#distance-sensor","title":"Distance Sensor","text":"<p>Like robot sonar - measures how far away things are</p> <pre><code>    +--------+\n    |        |  \u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192 WALL\n    | DIST   |       \u2191\n    | SENSOR |   \"Distance: 500mm\"\n    +--------+\n</code></pre> <p>Best for: Wall following, stopping before obstacles</p>"},{"location":"02-robot-anatomy/03-sensors-overview/#optical-sensor","title":"Optical Sensor","text":"<p>Detects colors and light levels</p> <pre><code>    +--------+\n    |OPTICAL | \u2193 (points down at field)\n    +--------+\n        \u2193\n    \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2190 Object color detected!\n</code></pre> <p>Best for: Detecting block colors, line following</p>"},{"location":"02-robot-anatomy/03-sensors-overview/#gps-sensor","title":"GPS Sensor","text":"<p>Knows exactly where you are on the field</p> <pre><code>    FIELD MAP:\n\n    +-----------------+\n    |        N        |\n    |                 |\n    | W      \ud83d\udccd     E |  \u2190 \"Position: (300mm, 450mm)\"\n    |                 |\n    |        S        |\n    +-----------------+\n</code></pre> <p>Best for: Precise autonomous navigation, returning to positions</p>"},{"location":"02-robot-anatomy/03-sensors-overview/#code-connection-sensor-setup","title":"Code Connection: Sensor Setup","text":"<p>Look at <code>src/robot_config.py</code> (lines 67-74):</p> <pre><code># =============================================================================\n# SENSORS (add as needed)\n# =============================================================================\n# Uncomment and configure sensors when you add them:\n#\n# inertial_sensor = Inertial(Ports.PORT5)\n# distance_sensor = Distance(Ports.PORT6)\n# optical_sensor = Optical(Ports.PORT7)\n# gps_sensor = Gps(Ports.PORT8)\n</code></pre> <p>These are commented out because the basic robot doesn't have sensors installed yet. When you add a sensor, uncomment the line and update the port number.</p>"},{"location":"02-robot-anatomy/03-sensors-overview/#using-the-inertial-sensor","title":"Using the Inertial Sensor","text":"<p>The inertial sensor is the most useful for competition robots:</p> <pre><code># Setup\ninertial_sensor = Inertial(Ports.PORT5)\n\n# IMPORTANT: Calibrate before use!\ninertial_sensor.calibrate()\nwait(3, SECONDS)  # Wait for calibration\n\n# Read heading (0-360 degrees)\nheading = inertial_sensor.heading()  # Returns 0-359.99\n\n# Read rotation (continuous, can be negative)\nrotation = inertial_sensor.rotation()  # Can be -999999 to +999999\n</code></pre> <pre><code>flowchart LR\n    subgraph HEADING[\"Heading (0-360)\"]\n        direction TB\n        H1[\"Start: 0\"]\n        H2[\"Turn right 45: 45\"]\n        H3[\"Turn right 45: 90\"]\n        H4[\"Turn right 290: 20\"]\n        H5[\"Turn left 30: 350\"]\n        H1 --&gt; H2 --&gt; H3 --&gt; H4 --&gt; H5\n    end\n    subgraph ROTATION[\"Rotation (continuous)\"]\n        direction TB\n        R1[\"Start: 0\"]\n        R2[\"Turn right 45: 45\"]\n        R3[\"Turn right 45: 90\"]\n        R4[\"Turn right 290: 380&lt;br/&gt;Keeps counting!\"]\n        R5[\"Turn left 30: 350\"]\n        R1 --&gt; R2 --&gt; R3 --&gt; R4 --&gt; R5\n    end</code></pre>"},{"location":"02-robot-anatomy/03-sensors-overview/#smartdrive-drivetrain-inertial","title":"SmartDrive: DriveTrain + Inertial","text":"<p>When you add an inertial sensor, you can upgrade to SmartDrive:</p> <pre><code># From robot_config.py (commented):\n# smart_drivetrain = SmartDrive(\n#     left_motors,\n#     right_motors,\n#     inertial_sensor,       # \u2190 The magic ingredient!\n#     WHEEL_TRAVEL_MM,\n#     TRACK_WIDTH_MM,\n#     WHEEL_BASE_MM,\n#     MM,\n#     EXTERNAL_GEAR_RATIO\n# )\n</code></pre> <p>SmartDrive automatically uses the inertial sensor for more accurate turns!</p>"},{"location":"02-robot-anatomy/03-sensors-overview/#using-the-distance-sensor","title":"Using the Distance Sensor","text":"<pre><code># Setup\ndistance_sensor = Distance(Ports.PORT6)\n\n# Read distance\ndist = distance_sensor.object_distance(MM)  # Distance in mm\n\n# Example: Stop before hitting a wall\nwhile True:\n    if distance_sensor.object_distance(MM) &lt; 100:\n        drivetrain.stop()\n    else:\n        drivetrain.drive(FORWARD)\n</code></pre> <pre><code>    Distance Sensor Range:\n\n    CLOSE            MEDIUM           FAR\n    &lt; 100mm          100-500mm        500-2000mm\n\n    +--------+        +--------+      +--------+\n    | DIST   |\u2192       | DIST   |\u2192\u2192\u2192   | DIST   |\u2192\u2192\u2192\u2192\u2192\u2192\u2192\n    +--------+        +--------+      +--------+\n</code></pre>"},{"location":"02-robot-anatomy/03-sensors-overview/#using-the-optical-sensor","title":"Using the Optical Sensor","text":"<pre><code># Setup\noptical_sensor = Optical(Ports.PORT7)\n\n# Turn on the light for color detection\noptical_sensor.set_light_power(100)\noptical_sensor.set_light(LedStateType.ON)\n\n# Detect if object is present\nif optical_sensor.is_near_object():\n    # Read the color\n    color = optical_sensor.color()\n\n    if color == Color.RED:\n        print(\"Red block detected!\")\n    elif color == Color.BLUE:\n        print(\"Blue block detected!\")\n</code></pre>"},{"location":"02-robot-anatomy/03-sensors-overview/#sensor-comparison-table","title":"Sensor Comparison Table","text":"Sensor Measures Best For Ports Used Inertial Rotation, tilt, acceleration Accurate turns 1 Distance Distance to objects (mm) Wall detection 1 Optical Color, light level Block detection 1 GPS X, Y position on field Field navigation 1 Limit Switch Contact (pressed/not) Arm limits 1 3-wire Bumper Contact (pressed/not) Wall touch 1 3-wire"},{"location":"02-robot-anatomy/03-sensors-overview/#why-sensors-matter-for-push-back","title":"Why Sensors Matter for Push Back","text":"<p>In Push Back, sensors can give you an edge:</p> <pre><code>    Without Inertial:               With Inertial:\n\n    \"Turn right 90\u00b0\"                \"Turn until heading = 90\u00b0\"\n\n    Might turn 85\u00b0 or 95\u00b0           Always turns exactly 90\u00b0\n    (motor slip, friction)          (sensor confirms angle)\n</code></pre>"},{"location":"02-robot-anatomy/03-sensors-overview/#sensor-ideas-for-push-back","title":"Sensor Ideas for Push Back","text":"Sensor Competition Use Inertial Accurate autonomous turns, detect being pushed Distance Detect goals, detect blocks nearby Optical Know if block is your color or opponent's GPS Return to specific field positions"},{"location":"02-robot-anatomy/03-sensors-overview/#summary","title":"Summary","text":"Sensor Setup Code Main Method Inertial <code>Inertial(Ports.PORT#)</code> <code>.heading()</code>, <code>.rotation()</code> Distance <code>Distance(Ports.PORT#)</code> <code>.object_distance(MM)</code> Optical <code>Optical(Ports.PORT#)</code> <code>.color()</code>, <code>.is_near_object()</code> GPS <code>Gps(Ports.PORT#)</code> <code>.x_position()</code>, <code>.y_position()</code>"},{"location":"02-robot-anatomy/03-sensors-overview/#exercise-add-an-inertial-sensor","title":"Exercise: Add an Inertial Sensor","text":"<p>Goal: Modify <code>robot_config.py</code> to add an inertial sensor on Port 5.</p> <p>Step 1: Find this line in <code>robot_config.py</code>: <pre><code># inertial_sensor = Inertial(Ports.PORT5)\n</code></pre></p> <p>Step 2: Uncomment it by removing the <code>#</code>: <pre><code>inertial_sensor = Inertial(Ports.PORT5)\n</code></pre></p> <p>Step 3: Write code to display the heading on the brain screen: <pre><code># In main.py or a test file:\ninertial_sensor.calibrate()\nwait(3, SECONDS)\n\nwhile True:\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n    heading = inertial_sensor.heading()\n    brain.screen.print(\"Heading: \" + str(heading))\n    wait(100, MSEC)\n</code></pre></p> <p>Question: What happens to the heading value when you rotate the robot?</p>"},{"location":"02-robot-anatomy/03-sensors-overview/#answer","title":"Answer","text":"<p>When you rotate the robot: - Clockwise (right): Heading increases (0 \u2192 90 \u2192 180 \u2192 270 \u2192 0) - Counter-clockwise (left): Heading decreases (0 \u2192 270 \u2192 180 \u2192 90 \u2192 0) - Heading always stays between 0 and 360 degrees</p> <p>\u2190 Previous: Motors and Gears | Next: Thinking with Flowcharts \u2192 | Review Q&amp;A</p>"},{"location":"02-robot-anatomy/04-review-qa/","title":"Module 2: Robot Anatomy - Revision Q&amp;A","text":"<p>Target Audience: 8th Grade Students Estimated Time: 45-60 minutes Total Questions: 79 Competition: VEX V5 Push Back 2025-2026</p>"},{"location":"02-robot-anatomy/04-review-qa/#how-to-use-this-document","title":"How to Use This Document","text":"<p>This revision document helps you test your understanding of VEX V5 robot anatomy. Work through the questions at your own pace, then check your answers in the Answer Key at the end.</p>"},{"location":"02-robot-anatomy/04-review-qa/#difficulty-levels","title":"Difficulty Levels","text":"Icon Level What It Means [STARTER] 1 Basic facts - if you read the tutorial, you know this! [LEARNER] 2 Understanding concepts - explain what things do [BUILDER] 3 Apply knowledge - use what you learned [THINKER] 4 Analyze and connect - see the bigger picture [CHAMPION] 5 Competition-ready - solve real match scenarios"},{"location":"02-robot-anatomy/04-review-qa/#question-types","title":"Question Types","text":"<ul> <li>Multiple Choice (MC) - Pick the best answer (A, B, C, or D)</li> <li>Fill-in-Blank (FB) - Complete the sentence or code</li> <li>True/False (TF) - Decide if the statement is correct</li> <li>Short Answer (SA) - Write 1-3 sentences explaining your answer</li> <li>Code Analysis (CA) - Read and understand Python code</li> <li>Diagram (DG) - Work with visual diagrams</li> </ul>"},{"location":"02-robot-anatomy/04-review-qa/#tips-for-success","title":"Tips for Success","text":"<ol> <li>Try answering without looking at your notes first</li> <li>If stuck, review the tutorial section mentioned in the question</li> <li>For code questions, trace through line by line</li> <li>Write down your answers before checking the Answer Key</li> </ol>"},{"location":"02-robot-anatomy/04-review-qa/#part-1-brain-and-controller","title":"Part 1: Brain and Controller","text":"<p>Questions 1-21 | Review: Tutorial 2.1</p>"},{"location":"02-robot-anatomy/04-review-qa/#foundational-questions-starterlearner","title":"Foundational Questions [STARTER/LEARNER]","text":""},{"location":"02-robot-anatomy/04-review-qa/#q1-starter-mc","title":"Q1. [STARTER - MC]","text":"<p>How many Smart Ports does the V5 Brain have for connecting motors and sensors?</p> <p>A) 10 B) 15 C) 21 D) 25</p>"},{"location":"02-robot-anatomy/04-review-qa/#q2-starter-tf","title":"Q2. [STARTER - TF]","text":"<p>True or False: The V5 Brain has a touchscreen that is 480 x 272 pixels.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q3-starter-fb","title":"Q3. [STARTER - FB]","text":"<p>Complete the sentence: To download code from your computer to the V5 Brain, you connect a _ cable.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q4-starter-mc","title":"Q4. [STARTER - MC]","text":"<p>Which component allows the V5 Controller to communicate wirelessly with the V5 Brain?</p> <p>A) USB-C port B) Radio module C) Touchscreen D) Battery slot</p>"},{"location":"02-robot-anatomy/04-review-qa/#q5-learner-fb","title":"Q5. [LEARNER - FB]","text":"<p>In your robot's configuration, the motors are connected to ports 1 through 4. Fill in the motor names:</p> <ul> <li>Port 1: _ (LF)</li> <li>Port 2: _ (LB)</li> <li>Port 3: _ (RF)</li> <li>Port 4: _ (RB)</li> </ul>"},{"location":"02-robot-anatomy/04-review-qa/#q6-learner-mc","title":"Q6. [LEARNER - MC]","text":"<p>What range of values does a joystick axis return?</p> <p>A) 0 to 100 B) -100 to +100 C) -255 to +255 D) 0 to 255</p>"},{"location":"02-robot-anatomy/04-review-qa/#q7-learner-tf","title":"Q7. [LEARNER - TF]","text":"<p>True or False: When the joystick is centered (not being touched), it returns a value of 0.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q8-learner-fb","title":"Q8. [LEARNER - FB]","text":"<p>The V5 Controller has two joysticks. The left joystick uses Axis _ for up/down and Axis ___ for left/right.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q9-learner-mc","title":"Q9. [LEARNER - MC]","text":"<p>What does <code>brain.screen.print()</code> do?</p> <p>A) Sends text to the computer B) Displays text on the Brain's touchscreen C) Prints a physical paper receipt D) Sends text to the controller</p>"},{"location":"02-robot-anatomy/04-review-qa/#q10-learner-dg","title":"Q10. [LEARNER - DG]","text":"<p>Look at this controller diagram. Label the button positions:</p> <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502       [?1]                        [?2]      \u2502\n    \u2502       [?3]                        [?4]      \u2502\n    \u2502                                             \u2502\n    \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n    \u2502    \u2502 LEFT  \u2502                  \u2502 RIGHT \u2502    \u2502\n    \u2502    \u2502 STICK \u2502   [A] [B]        \u2502 STICK \u2502    \u2502\n    \u2502    \u2502       \u2502   [X] [Y]        \u2502       \u2502    \u2502\n    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>?1 = _ ?2 =  ?3 = __ ?4 = _____</p>"},{"location":"02-robot-anatomy/04-review-qa/#intermediate-questions-builderthinker","title":"Intermediate Questions [BUILDER/THINKER]","text":""},{"location":"02-robot-anatomy/04-review-qa/#q11-builder-ca","title":"Q11. [BUILDER - CA]","text":"<p>Look at this code from <code>robot_config.py</code>:</p> <pre><code>from vex import *\n\nbrain = Brain()\ncontroller = Controller(PRIMARY)\n</code></pre> <p>What would you need to change to use a partner (second) controller instead?</p>"},{"location":"02-robot-anatomy/04-review-qa/#q12-builder-fb","title":"Q12. [BUILDER - FB]","text":"<p>Complete this code to read the vertical position of the LEFT joystick:</p> <pre><code>left_y = controller._______.position()\n</code></pre>"},{"location":"02-robot-anatomy/04-review-qa/#q13-builder-ca","title":"Q13. [BUILDER - CA]","text":"<p>What does this code do?</p> <pre><code>while True:\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n    left_y = controller.axis3.position()\n    brain.screen.print(\"Left Y: \" + str(left_y))\n    wait(100, MSEC)\n</code></pre> <p>Write a short description of what you would see on the Brain screen.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q14-builder-mc","title":"Q14. [BUILDER - MC]","text":"<p>Why do we need <code>str(left_y)</code> when printing the joystick value?</p> <p>A) To make the number smaller B) To convert the number to text for printing C) To round the number D) To make the number positive</p>"},{"location":"02-robot-anatomy/04-review-qa/#q15-thinker-sa","title":"Q15. [THINKER - SA]","text":"<p>The code has <code>wait(100, MSEC)</code> at the end of the loop. What would happen if we removed this line? Why?</p>"},{"location":"02-robot-anatomy/04-review-qa/#q16-thinker-dg","title":"Q16. [THINKER - DG]","text":"<p>Label the joystick axes in this diagram:</p> <pre><code>    LEFT JOYSTICK              RIGHT JOYSTICK\n\n         (A)                        (C)\n          \u2191                          \u2191\n    (B) \u2190   \u2192                  (D) \u2190   \u2192\n          \u2193                          \u2193\n</code></pre> <p>A = Axis _ B = Axis  C = Axis __ D = Axis _____</p>"},{"location":"02-robot-anatomy/04-review-qa/#q17-thinker-sa","title":"Q17. [THINKER - SA]","text":"<p>Explain the difference between connecting the controller wirelessly versus with a cable. When would you use each?</p>"},{"location":"02-robot-anatomy/04-review-qa/#q18-thinker-ca","title":"Q18. [THINKER - CA]","text":"<p>Look at this code:</p> <pre><code>if controller.buttonA.pressing():\n    intake_motor.spin(FORWARD)\n</code></pre> <p>What's the problem with this code if we want the motor to stop when the button is released?</p>"},{"location":"02-robot-anatomy/04-review-qa/#advanced-questions-champion","title":"Advanced Questions [CHAMPION]","text":""},{"location":"02-robot-anatomy/04-review-qa/#q19-champion-sa","title":"Q19. [CHAMPION - SA]","text":"<p>Your robot's controller is experiencing \"drift\" - the robot moves slightly even when you're not touching the joysticks. Based on what you learned about joystick values, explain:</p> <p>a) Why this happens b) How could you fix it in code?</p>"},{"location":"02-robot-anatomy/04-review-qa/#q20-champion-ca","title":"Q20. [CHAMPION - CA]","text":"<p>Design a button control scheme for a robot with: - Drive motors (controlled by joysticks) - An intake motor - A lift motor</p> <p>Which buttons would you assign to each mechanism and why? Write pseudocode or describe your plan.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q21-champion-sa","title":"Q21. [CHAMPION - SA]","text":"<p>In a Push Back match, you need to quickly see your robot's status during driver control. Design what information you would display on the Brain screen and explain why each piece is useful.</p>"},{"location":"02-robot-anatomy/04-review-qa/#part-2-motors-and-gears","title":"Part 2: Motors and Gears","text":"<p>Questions 22-45 | Review: Tutorial 2.2</p>"},{"location":"02-robot-anatomy/04-review-qa/#foundational-questions-starterlearner_1","title":"Foundational Questions [STARTER/LEARNER]","text":""},{"location":"02-robot-anatomy/04-review-qa/#q22-starter-tf","title":"Q22. [STARTER - TF]","text":"<p>True or False: V5 Smart Motors have built-in sensors that can measure rotation, temperature, and current.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q23-starter-mc","title":"Q23. [STARTER - MC]","text":"<p>Which gear cartridge color provides the FASTEST speed (600 RPM)?</p> <p>A) Red (36:1) B) Green (18:1) C) Blue (6:1) D) Yellow (12:1)</p>"},{"location":"02-robot-anatomy/04-review-qa/#q24-starter-fb","title":"Q24. [STARTER - FB]","text":"<p>In your robot's code, the left front motor is connected to Port _ and the right front motor is connected to Port ___.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q25-starter-mc","title":"Q25. [STARTER - MC]","text":"<p>What does the Motor's encoder measure?</p> <p>A) Temperature B) Rotation count C) Battery voltage D) Distance to objects</p>"},{"location":"02-robot-anatomy/04-review-qa/#q26-learner-fb","title":"Q26. [LEARNER - FB]","text":"<p>Complete the motor constructor:</p> <pre><code>Motor(Ports.PORT1, GearSetting.RATIO_18_1, _____)\n</code></pre> <p>The third parameter is <code>True</code> or <code>False</code> for whether the motor is _.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q27-learner-tf","title":"Q27. [LEARNER - TF]","text":"<p>True or False: All four drive motors on your robot should have the same <code>reversed</code> setting (all True or all False).</p>"},{"location":"02-robot-anatomy/04-review-qa/#q28-learner-mc","title":"Q28. [LEARNER - MC]","text":"<p>Which gear cartridge provides the MOST torque (pushing power)?</p> <p>A) Red (36:1) - 100 RPM B) Green (18:1) - 200 RPM C) Blue (6:1) - 600 RPM D) They all have the same torque</p>"},{"location":"02-robot-anatomy/04-review-qa/#q29-learner-dg","title":"Q29. [LEARNER - DG]","text":"<p>Look at this motor mounting diagram:</p> <pre><code>    TOP VIEW OF ROBOT:\n         FRONT\n           \u2191\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502             \u2502\n    \u2502  LF     RF  \u2502\n    \u2502  [\u2192]   [\u2190]  \u2502  \u2190 Motors face OUTWARD\n    \u2502             \u2502\n    \u2502  LB     RB  \u2502\n    \u2502  [\u2192]   [\u2190]  \u2502\n    \u2502             \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Which motors need to be reversed in code (set to <code>True</code>)?</p>"},{"location":"02-robot-anatomy/04-review-qa/#q30-learner-fb","title":"Q30. [LEARNER - FB]","text":"<p>To control both left motors together with one command, you create a _____.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q31-learner-mc","title":"Q31. [LEARNER - MC]","text":"<p>What does <code>motor.spin(FORWARD, 75, PERCENT)</code> do?</p> <p>A) Spin at 75 RPM B) Spin forward for 75 seconds C) Spin forward at 75% of maximum speed D) Spin for 75 rotations</p>"},{"location":"02-robot-anatomy/04-review-qa/#intermediate-questions-builderthinker_1","title":"Intermediate Questions [BUILDER/THINKER]","text":""},{"location":"02-robot-anatomy/04-review-qa/#q32-builder-ca","title":"Q32. [BUILDER - CA]","text":"<p>Look at this code from <code>robot_config.py</code>:</p> <pre><code>left_motor_front = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nright_motor_front = Motor(Ports.PORT3, GearSetting.RATIO_18_1, True)\n</code></pre> <p>Why is the left motor <code>False</code> but the right motor <code>True</code>?</p>"},{"location":"02-robot-anatomy/04-review-qa/#q33-builder-fb","title":"Q33. [BUILDER - FB]","text":"<p>Complete the code to create a MotorGroup:</p> <pre><code>left_motors = _________(left_motor_front, left_motor_back)\n</code></pre>"},{"location":"02-robot-anatomy/04-review-qa/#q34-builder-ca","title":"Q34. [BUILDER - CA]","text":"<p>What's the difference between these two code blocks?</p> <p>Block A: <pre><code>left_motor_front.spin(FORWARD, 50, PERCENT)\nleft_motor_back.spin(FORWARD, 50, PERCENT)\n</code></pre></p> <p>Block B: <pre><code>left_motors.spin(FORWARD, 50, PERCENT)\n</code></pre></p>"},{"location":"02-robot-anatomy/04-review-qa/#q35-builder-mc","title":"Q35. [BUILDER - MC]","text":"<p>What stopping mode would you use to make the robot hold its position firmly (resist being pushed)?</p> <p>A) COAST B) BRAKE C) HOLD D) STOP</p>"},{"location":"02-robot-anatomy/04-review-qa/#q36-thinker-sa","title":"Q36. [THINKER - SA]","text":"<p>Explain the difference between these three stopping modes:</p> <ul> <li>COAST</li> <li>BRAKE</li> <li>HOLD</li> </ul> <p>Give an example of when you would use each in a competition.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q37-thinker-dg","title":"Q37. [THINKER - DG]","text":"<p>Look at this wiring diagram:</p> <pre><code>    V5 BRAIN PORTS:\n\n    [1]\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500[3]\n    [2]\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u251c\u2500\u2500\u2500\u2500\u2500\u2500[4]\n             \u2502     \u2502\n             \u2193     \u2193\n         LEFT SIDE    RIGHT SIDE\n</code></pre> <p>If you added an intake motor on Port 5, write the line of code to create it (use blue cartridge, not reversed):</p>"},{"location":"02-robot-anatomy/04-review-qa/#q38-thinker-ca","title":"Q38. [THINKER - CA]","text":"<p>Look at this DriveTrain setup:</p> <pre><code>drivetrain = DriveTrain(\n    left_motors,\n    right_motors,\n    319.19,          # wheel travel in mm\n    295,             # track width in mm\n    200,             # wheel base in mm\n    MM,\n    1                # external gear ratio\n)\n</code></pre> <p>What does the <code>319.19</code> value represent and why is it important?</p>"},{"location":"02-robot-anatomy/04-review-qa/#q39-thinker-fb","title":"Q39. [THINKER - FB]","text":"<p>To make the robot drive forward 500mm, you would use:</p> <pre><code>drivetrain.drive_for(_______, 500, MM)\n</code></pre>"},{"location":"02-robot-anatomy/04-review-qa/#q40-thinker-ca","title":"Q40. [THINKER - CA]","text":"<p>What's wrong with this code?</p> <pre><code>motor.set_velocity(50, PERCENT)\n# Robot doesn't move - why?\n</code></pre>"},{"location":"02-robot-anatomy/04-review-qa/#q41-thinker-mc","title":"Q41. [THINKER - MC]","text":"<p>The <code>motor.position(DEGREES)</code> method returns:</p> <p>A) The motor's current speed B) The total rotation of the motor since it was reset C) The motor's temperature D) The port number the motor is on</p>"},{"location":"02-robot-anatomy/04-review-qa/#advanced-questions-champion_1","title":"Advanced Questions [CHAMPION]","text":""},{"location":"02-robot-anatomy/04-review-qa/#q42-champion-sa","title":"Q42. [CHAMPION - SA]","text":"<p>You're designing a robot for Push Back. You need to: 1. Push blocks quickly across the field 2. Climb the elevated park zone at the end</p> <p>You only have green cartridges (18:1). Explain: a) What trade-offs you face b) How you might use code to compensate when climbing</p>"},{"location":"02-robot-anatomy/04-review-qa/#q43-champion-ca","title":"Q43. [CHAMPION - CA]","text":"<p>Write the code to add an intake motor on Port 5 that: - Uses blue cartridge (fast) - Spins forward when R1 is pressed - Spins backward when R2 is pressed - Stops when neither is pressed</p>"},{"location":"02-robot-anatomy/04-review-qa/#q44-champion-sa","title":"Q44. [CHAMPION - SA]","text":"<p>Your robot's motors are getting hot during a long match. Using what you know about V5 Smart Motor sensors, how could you:</p> <p>a) Detect when motors are overheating? b) Prevent damage to the motors?</p>"},{"location":"02-robot-anatomy/04-review-qa/#q45-champion-ca","title":"Q45. [CHAMPION - CA]","text":"<p>Trace through this autonomous code and describe the robot's path:</p> <pre><code>drivetrain.set_drive_velocity(50, PERCENT)\ndrivetrain.set_turn_velocity(30, PERCENT)\ndrivetrain.set_stopping(BRAKE)\n\ndrivetrain.drive_for(FORWARD, 600, MM)\ndrivetrain.turn_for(RIGHT, 90, DEGREES)\ndrivetrain.drive_for(FORWARD, 400, MM)\ndrivetrain.turn_for(LEFT, 90, DEGREES)\ndrivetrain.drive_for(REVERSE, 200, MM)\n</code></pre> <p>Draw or describe the path the robot takes.</p>"},{"location":"02-robot-anatomy/04-review-qa/#part-3-sensors-overview","title":"Part 3: Sensors Overview","text":"<p>Questions 46-63 | Review: Tutorial 2.3</p>"},{"location":"02-robot-anatomy/04-review-qa/#foundational-questions-starterlearner_2","title":"Foundational Questions [STARTER/LEARNER]","text":""},{"location":"02-robot-anatomy/04-review-qa/#q46-starter-mc","title":"Q46. [STARTER - MC]","text":"<p>What does a sensor do for your robot?</p> <p>A) Provides extra power B) Lets the robot \"see\" and \"feel\" the world C) Makes the robot faster D) Stores programs</p>"},{"location":"02-robot-anatomy/04-review-qa/#q47-starter-tf","title":"Q47. [STARTER - TF]","text":"<p>True or False: The Inertial Sensor can measure which direction the robot is pointing (heading).</p>"},{"location":"02-robot-anatomy/04-review-qa/#q48-starter-fb","title":"Q48. [STARTER - FB]","text":"<p>The _ sensor measures how far away objects are, like robot sonar.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q49-starter-mc","title":"Q49. [STARTER - MC]","text":"<p>Which sensor would you use to detect the color of a block?</p> <p>A) Inertial Sensor B) Distance Sensor C) Optical Sensor D) GPS Sensor</p>"},{"location":"02-robot-anatomy/04-review-qa/#q50-learner-mc","title":"Q50. [LEARNER - MC]","text":"<p>What is the range of values returned by <code>inertial_sensor.heading()</code>?</p> <p>A) -180 to +180 B) 0 to 360 C) -100 to +100 D) 0 to 100</p>"},{"location":"02-robot-anatomy/04-review-qa/#q51-learner-fb","title":"Q51. [LEARNER - FB]","text":"<p>Before using the inertial sensor, you must _ it and wait about 3 seconds.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q52-learner-tf","title":"Q52. [LEARNER - TF]","text":"<p>True or False: The GPS sensor tells you your robot's exact X and Y position on the field.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q53-learner-mc","title":"Q53. [LEARNER - MC]","text":"<p>SmartDrive is created by combining a DriveTrain with which sensor?</p> <p>A) Distance Sensor B) Optical Sensor C) Inertial Sensor D) GPS Sensor</p>"},{"location":"02-robot-anatomy/04-review-qa/#intermediate-questions-builderthinker_2","title":"Intermediate Questions [BUILDER/THINKER]","text":""},{"location":"02-robot-anatomy/04-review-qa/#q54-builder-ca","title":"Q54. [BUILDER - CA]","text":"<p>What's missing from this code?</p> <pre><code>inertial_sensor = Inertial(Ports.PORT5)\nheading = inertial_sensor.heading()  # This might be wrong!\n</code></pre>"},{"location":"02-robot-anatomy/04-review-qa/#q55-builder-fb","title":"Q55. [BUILDER - FB]","text":"<p>Complete the code to read the distance to an object in millimeters:</p> <pre><code>dist = distance_sensor.___________(MM)\n</code></pre>"},{"location":"02-robot-anatomy/04-review-qa/#q56-builder-ca","title":"Q56. [BUILDER - CA]","text":"<p>What does this code do?</p> <pre><code>while True:\n    if distance_sensor.object_distance(MM) &lt; 100:\n        drivetrain.stop()\n    else:\n        drivetrain.drive(FORWARD)\n</code></pre>"},{"location":"02-robot-anatomy/04-review-qa/#q57-thinker-sa","title":"Q57. [THINKER - SA]","text":"<p>Explain the difference between <code>heading()</code> and <code>rotation()</code> on the Inertial Sensor. Give an example of when you would use each.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q58-thinker-dg","title":"Q58. [THINKER - DG]","text":"<p>Match each sensor to its real-world analogy:</p> Sensor Analogy Inertial Sensor A) Car parking sensors Distance Sensor B) GPS navigation in a car Optical Sensor C) Your inner ear (balance) GPS Sensor D) Your eyes seeing colors <p>Inertial = _ Distance =  Optical = __ GPS = _____</p>"},{"location":"02-robot-anatomy/04-review-qa/#q59-thinker-ca","title":"Q59. [THINKER - CA]","text":"<p>Look at this optical sensor code:</p> <pre><code>optical_sensor.set_light_power(100)\noptical_sensor.set_light(LedStateType.ON)\n\nif optical_sensor.is_near_object():\n    color = optical_sensor.color()\n    if color == Color.RED:\n        print(\"Red block!\")\n</code></pre> <p>Why do we turn on the light before detecting colors?</p>"},{"location":"02-robot-anatomy/04-review-qa/#q60-thinker-fb","title":"Q60. [THINKER - FB]","text":"<p>After two full clockwise rotations (720 degrees), what would these values be?</p> <ul> <li><code>heading()</code> = _ degrees</li> <li><code>rotation()</code> = _ degrees</li> </ul>"},{"location":"02-robot-anatomy/04-review-qa/#advanced-questions-champion_2","title":"Advanced Questions [CHAMPION]","text":""},{"location":"02-robot-anatomy/04-review-qa/#q61-champion-sa","title":"Q61. [CHAMPION - SA]","text":"<p>In Push Back, explain how you could use each of these sensors:</p> <p>a) Inertial Sensor b) Distance Sensor c) Optical Sensor</p> <p>Give specific examples for autonomous or driver control.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q62-champion-ca","title":"Q62. [CHAMPION - CA]","text":"<p>Write code for an autonomous routine that: 1. Drives forward until the distance sensor reads less than 150mm 2. Stops 3. Turns right exactly 90 degrees using the inertial sensor</p>"},{"location":"02-robot-anatomy/04-review-qa/#q63-champion-sa","title":"Q63. [CHAMPION - SA]","text":"<p>Compare these two approaches for turning in autonomous:</p> <p>Approach A: <code>drivetrain.turn_for(RIGHT, 90, DEGREES)</code></p> <p>Approach B: <pre><code>while inertial_sensor.rotation() &lt; 90:\n    left_motors.spin(FORWARD, 30, PERCENT)\n    right_motors.spin(REVERSE, 30, PERCENT)\ndrivetrain.stop()\n</code></pre></p> <p>What are the advantages of each approach? When would you use each?</p>"},{"location":"02-robot-anatomy/04-review-qa/#part-4-integration-and-competition","title":"Part 4: Integration and Competition","text":"<p>Questions 64-79 | Cross-Topic and Push Back Scenarios</p>"},{"location":"02-robot-anatomy/04-review-qa/#cross-topic-questions","title":"Cross-Topic Questions","text":""},{"location":"02-robot-anatomy/04-review-qa/#q64-builder-sa","title":"Q64. [BUILDER - SA]","text":"<p>Trace the flow of information when you push the joystick forward:</p> <ol> <li>Joystick physical movement</li> <li>??? (fill in the steps)</li> <li>Robot moves forward</li> </ol>"},{"location":"02-robot-anatomy/04-review-qa/#q65-builder-ca","title":"Q65. [BUILDER - CA]","text":"<p>Look at this complete driver control code:</p> <pre><code>while True:\n    left_speed = controller.axis3.position()\n    right_speed = controller.axis2.position()\n\n    left_motors.set_velocity(left_speed, PERCENT)\n    right_motors.set_velocity(right_speed, PERCENT)\n\n    left_motors.spin(FORWARD)\n    right_motors.spin(FORWARD)\n\n    wait(20, MSEC)\n</code></pre> <p>This is called \"tank drive.\" Explain how you would control the robot to: a) Drive straight forward b) Turn right in place c) Turn left while moving forward</p>"},{"location":"02-robot-anatomy/04-review-qa/#q66-thinker-dg","title":"Q66. [THINKER - DG]","text":"<p>Complete this system diagram showing how components connect:</p> <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  CONTROLLER  \u2502 \u2500\u2500?\u2500\u2500&gt;  \u2502    BRAIN     \u2502\n    \u2502              \u2502         \u2502              \u2502\n    \u2502  axis3 = 80  \u2502         \u2502  Runs code   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    ?\n                                    \u2193\n                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                             \u2502   MOTORS     \u2502\n                             \u2502              \u2502\n                             \u2502  spin at ?%  \u2502\n                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Fill in the <code>?</code> symbols.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q67-thinker-ca","title":"Q67. [THINKER - CA]","text":"<p>What would happen if you ran this code with the wrong port numbers?</p> <pre><code>left_motor_front = Motor(Ports.PORT3, GearSetting.RATIO_18_1, False)  # Wrong!\nright_motor_front = Motor(Ports.PORT1, GearSetting.RATIO_18_1, True)  # Wrong!\n</code></pre> <p>Describe the robot's behavior when trying to drive forward.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q68-thinker-sa","title":"Q68. [THINKER - SA]","text":"<p>Explain why the constants in <code>robot_config.py</code> are important:</p> <pre><code>WHEEL_TRAVEL_MM = 319.19\nTRACK_WIDTH_MM = 295\nWHEEL_BASE_MM = 200\n</code></pre> <p>What would happen if these values were wrong?</p>"},{"location":"02-robot-anatomy/04-review-qa/#q69-champion-ca","title":"Q69. [CHAMPION - CA]","text":"<p>Design a complete <code>robot_config.py</code> for a robot with: - 4 drive motors (ports 1-4, green cartridge) - 1 intake motor (port 5, blue cartridge) - 1 lift motor (port 6, red cartridge) - Inertial sensor (port 7)</p> <p>Write the code to configure all components.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q70-champion-sa","title":"Q70. [CHAMPION - SA]","text":"<p>You're debugging a robot that won't drive straight. List 5 possible causes and how you would check each one.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q71-champion-ca","title":"Q71. [CHAMPION - CA]","text":"<p>Combine multiple concepts to write a driver control loop that: - Uses tank drive for movement - R1 spins intake forward - R2 spins intake backward - L1 raises lift - L2 lowers lift - Displays motor temperatures on the brain screen</p>"},{"location":"02-robot-anatomy/04-review-qa/#push-back-competition-scenarios","title":"Push Back Competition Scenarios","text":""},{"location":"02-robot-anatomy/04-review-qa/#q72-champion-sa","title":"Q72. [CHAMPION - SA]","text":"<p>Scenario: You're starting autonomous from the LEFT side of the field. Your goal is to push the nearest block into the goal zone.</p> <p>Describe your autonomous strategy and the approximate movements (distances and turns) needed. What sensors would help?</p>"},{"location":"02-robot-anatomy/04-review-qa/#q73-champion-mc","title":"Q73. [CHAMPION - MC]","text":"<p>In Push Back, which stopping mode should you use when parking on the elevated platform at the end of the match?</p> <p>A) COAST - Let the robot roll freely B) BRAKE - Quick stop C) HOLD - Resist movement D) It doesn't matter</p>"},{"location":"02-robot-anatomy/04-review-qa/#q74-champion-sa","title":"Q74. [CHAMPION - SA]","text":"<p>Scenario: Your battery is at 40% during your last qualification match. How might this affect:</p> <p>a) Your autonomous routine distances? b) Your motor performance? c) What adjustments could you make?</p>"},{"location":"02-robot-anatomy/04-review-qa/#q75-champion-ca","title":"Q75. [CHAMPION - CA]","text":"<p>Scenario: You want to detect if an opponent is pushing your robot during driver control.</p> <p>Using the inertial sensor, write pseudocode to detect a sudden change in rotation (someone pushing you) and alert the driver on the brain screen.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q76-champion-sa","title":"Q76. [CHAMPION - SA]","text":"<p>Scenario: During autonomous, your robot consistently turns 85 degrees instead of 90 degrees.</p> <p>a) What's causing this? b) How could you fix it without an inertial sensor? c) How would an inertial sensor solve this permanently?</p>"},{"location":"02-robot-anatomy/04-review-qa/#q77-champion-ca","title":"Q77. [CHAMPION - CA]","text":"<p>Write an autonomous routine for the SKILLS challenge (60 seconds) that: 1. Starts in the center 2. Pushes blocks from multiple areas 3. Parks on the platform at the end</p> <p>Outline the sequence of movements with estimated values.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q78-champion-sa","title":"Q78. [CHAMPION - SA]","text":"<p>Compare your robot's two drive control options:</p> Feature Tank Drive Arcade Drive Forward/backward ? ? Turning ? ? Best for... ? ? <p>Fill in the comparison and explain which you would choose for Push Back and why.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q79-champion-sa","title":"Q79. [CHAMPION - SA]","text":"<p>Final Challenge: You're the driver for your alliance in the finals. List everything you should check before the match starts:</p> <ul> <li>Hardware checks (3 things)</li> <li>Software checks (3 things)</li> <li>Strategy preparation (2 things)</li> </ul>"},{"location":"02-robot-anatomy/04-review-qa/#answer-key","title":"Answer Key","text":"<p>All answers with explanations</p>"},{"location":"02-robot-anatomy/04-review-qa/#part-1-brain-and-controller-answers","title":"Part 1: Brain and Controller Answers","text":""},{"location":"02-robot-anatomy/04-review-qa/#q1-answer-c-21","title":"Q1. Answer: C) 21","text":"<p>Explanation: The V5 Brain has 21 Smart Ports numbered 1-21 for connecting motors and sensors. Common Mistake: Students sometimes count USB-C or radio as Smart Ports\u2014these are separate. Tutorial Reference: Section \"Key Features\" - port diagram</p>"},{"location":"02-robot-anatomy/04-review-qa/#q2-answer-true","title":"Q2. Answer: True","text":"<p>Explanation: The V5 Brain touchscreen is 480 x 272 pixels, used for displaying robot status and selecting programs. Tutorial Reference: Brain diagram showing \"480 x 272 pixels\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q3-answer-usb-c","title":"Q3. Answer: USB-C","text":"<p>Explanation: The USB-C port on the Brain connects to your computer for downloading code. Tutorial Reference: Section \"Key Features\" table</p>"},{"location":"02-robot-anatomy/04-review-qa/#q4-answer-b-radio-module","title":"Q4. Answer: B) Radio module","text":"<p>Explanation: The radio module enables wireless communication between controller and brain. Common Mistake: USB-C is for wired connection to computer, not controller. Tutorial Reference: Section \"Communication Between Brain and Controller\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q5-answer","title":"Q5. Answer:","text":"<ul> <li>Port 1: Left Front Motor</li> <li>Port 2: Left Back Motor</li> <li>Port 3: Right Front Motor</li> <li>Port 4: Right Back Motor</li> </ul> <p>Explanation: This is the standard 4-motor drivetrain configuration used in the project. Tutorial Reference: Port Layout diagram</p>"},{"location":"02-robot-anatomy/04-review-qa/#q6-answer-b-100-to-100","title":"Q6. Answer: B) -100 to +100","text":"<p>Explanation: Centered = 0, full forward/right = +100, full backward/left = -100. Common Mistake: 0-100 is wrong because joysticks report negative values when pushed back/left. Tutorial Reference: Section \"Joystick Axes\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q7-answer-true","title":"Q7. Answer: True","text":"<p>Explanation: When the joystick is centered (not touched), it returns approximately 0. Note: In practice, it might return small values like -2 or +3 due to wear\u2014that's why we use deadband filtering. Tutorial Reference: Joystick values explanation</p>"},{"location":"02-robot-anatomy/04-review-qa/#q8-answer-axis-3-axis-4","title":"Q8. Answer: Axis 3, Axis 4","text":"<p>Explanation: Left joystick: Axis 3 = up/down (Y), Axis 4 = left/right (X). Tutorial Reference: Joystick axes diagram</p>"},{"location":"02-robot-anatomy/04-review-qa/#q9-answer-b-displays-text-on-the-brains-touchscreen","title":"Q9. Answer: B) Displays text on the Brain's touchscreen","text":"<p>Explanation: <code>brain.screen.print()</code> shows text on the 480x272 pixel touchscreen. Tutorial Reference: Section \"Using the Brain Screen\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q10-answer","title":"Q10. Answer:","text":"<ul> <li>?1 = L1</li> <li>?2 = R1</li> <li>?3 = L2</li> <li>?4 = R2</li> </ul> <p>Explanation: L1/R1 are the upper bumpers, L2/R2 are the lower bumpers (triggers). Tutorial Reference: Controller diagram</p>"},{"location":"02-robot-anatomy/04-review-qa/#q11-answer-change-primary-to-partner","title":"Q11. Answer: Change <code>PRIMARY</code> to <code>PARTNER</code>","text":"<p><pre><code>controller = Controller(PARTNER)\n</code></pre> Explanation: PRIMARY is the main controller, PARTNER is the second controller for two-driver setups. Tutorial Reference: Section \"Code Connection: Controller Setup\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q12-answer-axis3","title":"Q12. Answer: axis3","text":"<p><pre><code>left_y = controller.axis3.position()\n</code></pre> Explanation: axis3 is the left joystick's Y (vertical) axis. Tutorial Reference: Section \"Reading Joystick Values\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q13-answer","title":"Q13. Answer:","text":"<p>The Brain screen continuously displays the current position of the left joystick's vertical axis (up/down). The number updates 10 times per second and changes from -100 (pushed down) to +100 (pushed up).</p> <p>Explanation: The loop clears the screen, moves cursor to top-left, reads axis3, prints the value, then waits 100ms before repeating. Tutorial Reference: Section \"Using the Brain Screen\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q14-answer-b-to-convert-the-number-to-text-for-printing","title":"Q14. Answer: B) To convert the number to text for printing","text":"<p>Explanation: <code>print()</code> expects a string (text), but <code>axis3.position()</code> returns a number. <code>str()</code> converts the number to text. Common Mistake: Python requires explicit type conversion for concatenation with +. Tutorial Reference: Exercise answers section</p>"},{"location":"02-robot-anatomy/04-review-qa/#q15-answer","title":"Q15. Answer:","text":"<p>Without the wait, the screen would update thousands of times per second, causing: - Screen flickering - High CPU usage - Unreadable display</p> <p>The 100ms wait creates 10 updates per second, which is smooth and readable.</p> <p>Tutorial Reference: Exercise answers section</p>"},{"location":"02-robot-anatomy/04-review-qa/#q16-answer","title":"Q16. Answer:","text":"<ul> <li>A = Axis 3 (left Y)</li> <li>B = Axis 4 (left X)</li> <li>C = Axis 2 (right Y)</li> <li>D = Axis 1 (right X)</li> </ul> <p>Explanation: Each joystick has X (horizontal) and Y (vertical) axes. The numbers are: axis1/2 for right, axis3/4 for left. Tutorial Reference: Joystick axes diagram</p>"},{"location":"02-robot-anatomy/04-review-qa/#q17-answer","title":"Q17. Answer:","text":"<p>Wireless: Used for matches, practice, and normal operation. More convenient, no cable in the way.</p> <p>Wired: Used for downloading code, troubleshooting connection issues, and initial competition setup. More reliable for programming.</p> <p>Tutorial Reference: Section \"Wired vs. Wireless\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q18-answer","title":"Q18. Answer:","text":"<p>The motor only spins while the button is pressed but never stops. Need to add an else clause:</p> <pre><code>if controller.buttonA.pressing():\n    intake_motor.spin(FORWARD)\nelse:\n    intake_motor.stop()\n</code></pre> <p>Explanation: Without the else, the motor keeps spinning even after the button is released. Tutorial Reference: Section \"Reading Buttons\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q19-answer","title":"Q19. Answer:","text":"<p>a) Why it happens: Joysticks may not return exactly 0 when centered due to physical wear, manufacturing tolerances, or calibration issues. They might return small values like -3 or +2.</p> <p>b) How to fix: Use a deadband filter that ignores small values: <pre><code>if abs(joystick_value) &lt; 5:\n    joystick_value = 0\n</code></pre> Or use the <code>deadband()</code> function from <code>utils.py</code>.</p> <p>Tutorial Reference: This connects to the deadband concept in driver_control.py</p>"},{"location":"02-robot-anatomy/04-review-qa/#q20-answer","title":"Q20. Answer:","text":"<p>Example button scheme: - Joysticks: Tank drive (left stick = left motors, right stick = right motors) - R1/R2: Intake forward/backward (right hand controls intake) - L1/L2: Lift up/down (left hand controls lift)</p> <p>Reasoning: - Keeps drive on thumbs for precision - Related functions grouped (intake on R, lift on L) - Easy to remember (R = right side of robot mechanisms)</p>"},{"location":"02-robot-anatomy/04-review-qa/#q21-answer","title":"Q21. Answer:","text":"<p>Useful display information: 1. Drive mode (Tank/Arcade) - Know current control scheme 2. Motor temperatures - Prevent overheating 3. Battery percentage - Monitor power 4. Match time remaining - Track autonomous/driver periods 5. Sensor values (if equipped) - Debug autonomous</p> <p>Example layout: <pre><code>Mode: Tank     Battery: 87%\nLF: 45\u00b0C  RF: 43\u00b0C\nMatch: Driver  Time: 1:23\n</code></pre></p>"},{"location":"02-robot-anatomy/04-review-qa/#part-2-motors-and-gears-answers","title":"Part 2: Motors and Gears Answers","text":""},{"location":"02-robot-anatomy/04-review-qa/#q22-answer-true","title":"Q22. Answer: True","text":"<p>Explanation: V5 Smart Motors have built-in encoder (rotation), temperature sensor, and current sensor. Tutorial Reference: Section \"Smart Features\" table</p>"},{"location":"02-robot-anatomy/04-review-qa/#q23-answer-c-blue-61","title":"Q23. Answer: C) Blue (6:1)","text":"<p>Explanation: Blue = 6:1 ratio = 600 RPM (fastest but lowest torque). Tutorial Reference: Gear cartridge comparison</p>"},{"location":"02-robot-anatomy/04-review-qa/#q24-answer-port-1-port-3","title":"Q24. Answer: Port 1, Port 3","text":"<p>Explanation: Left front = Port 1, Right front = Port 3 (as configured in robot_config.py). Tutorial Reference: Motor configuration code</p>"},{"location":"02-robot-anatomy/04-review-qa/#q25-answer-b-rotation-count","title":"Q25. Answer: B) Rotation count","text":"<p>Explanation: The encoder measures how many degrees or rotations the motor has turned, like a car's odometer. Tutorial Reference: Section \"Smart Features\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q26-answer-false-reversed","title":"Q26. Answer: False, reversed","text":"<p>Explanation: The third parameter determines if the motor direction is reversed. <code>False</code> = normal, <code>True</code> = reversed. Tutorial Reference: Section \"The Motor() Constructor\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q27-answer-false","title":"Q27. Answer: False","text":"<p>Explanation: Left motors use <code>False</code> (not reversed), right motors use <code>True</code> (reversed) because they're mirror-mounted. Tutorial Reference: Section \"Why Are Right Motors Reversed?\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q28-answer-a-red-361-100-rpm","title":"Q28. Answer: A) Red (36:1) - 100 RPM","text":"<p>Explanation: Lower speed = higher torque. Red cartridge trades speed for maximum pushing power. Common Mistake: Blue is fast but has lowest torque. Green is balanced. Tutorial Reference: Gear ratio explanation</p>"},{"location":"02-robot-anatomy/04-review-qa/#q29-answer-rf-and-rb-right-front-and-right-back","title":"Q29. Answer: RF and RB (Right Front and Right Back)","text":"<p>Explanation: Motors facing outward means right side motors spin \"backward\" relative to left when both go clockwise. We reverse right motors in code. Tutorial Reference: Top view mounting diagram</p>"},{"location":"02-robot-anatomy/04-review-qa/#q30-answer-motorgroup","title":"Q30. Answer: MotorGroup","text":"<p>Explanation: <code>MotorGroup(motor1, motor2)</code> lets you control multiple motors with one command. Tutorial Reference: Section \"Motor Groups\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q31-answer-c-spin-forward-at-75-of-maximum-speed","title":"Q31. Answer: C) Spin forward at 75% of maximum speed","text":"<p>Explanation: FORWARD is direction, 75 is velocity value, PERCENT is the unit (out of 100%). Tutorial Reference: Section \"Spinning the Motor\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q32-answer","title":"Q32. Answer:","text":"<p>Because motors are mounted facing outward (mirror image). When both motors spin clockwise: - Left motor moves robot FORWARD - Right motor moves robot BACKWARD</p> <p>Setting right motor to <code>True</code> (reversed) means \"forward\" in code = forward movement for both sides.</p> <p>Tutorial Reference: Section \"Why Are Right Motors Reversed?\" with diagram</p>"},{"location":"02-robot-anatomy/04-review-qa/#q33-answer-motorgroup","title":"Q33. Answer: MotorGroup","text":"<p><pre><code>left_motors = MotorGroup(left_motor_front, left_motor_back)\n</code></pre> Tutorial Reference: Motor Groups section</p>"},{"location":"02-robot-anatomy/04-review-qa/#q34-answer","title":"Q34. Answer:","text":"<p>Both do the same thing\u2014spin left motors at 50%.</p> <p>Block A: Controls each motor individually (2 lines, more typing). Block B: Controls both motors at once through the MotorGroup (1 line, simpler).</p> <p>MotorGroup is preferred because it's cleaner and ensures both motors get the same command simultaneously.</p> <p>Tutorial Reference: Section \"Why Use Motor Groups?\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q35-answer-c-hold","title":"Q35. Answer: C) HOLD","text":"<p>Explanation: - COAST = free spin (robot rolls) - BRAKE = quick stop (but can still be pushed) - HOLD = actively resists movement (holds position)</p> <p>Tutorial Reference: Stopping modes diagram</p>"},{"location":"02-robot-anatomy/04-review-qa/#q36-answer","title":"Q36. Answer:","text":"<p>COAST: Motor spins freely to a stop, like taking your foot off the gas. Use when you want smooth stops or don't care about precise position.</p> <p>BRAKE: Motor actively slows down quickly. Use for quick stops during driving.</p> <p>HOLD: Motor fights to stay in position. Use when parking on the platform or resisting being pushed.</p> <p>Competition examples: - COAST: End of driver control when match ends - BRAKE: Normal driving stops - HOLD: Climbing/parking on elevated platform</p> <p>Tutorial Reference: Stopping modes section</p>"},{"location":"02-robot-anatomy/04-review-qa/#q37-answer","title":"Q37. Answer:","text":"<p><pre><code>intake_motor = Motor(Ports.PORT5, GearSetting.RATIO_6_1, False)\n</code></pre> Explanation: Port 5, Blue cartridge (6:1 for speed), not reversed (assuming standard mounting). Tutorial Reference: Exercise section</p>"},{"location":"02-robot-anatomy/04-review-qa/#q38-answer","title":"Q38. Answer:","text":"<p><code>319.19</code> is the wheel circumference in millimeters (the distance traveled in one complete wheel rotation).</p> <p>Why important: The DriveTrain uses this to calculate actual distances. If wrong: - <code>drive_for(FORWARD, 500, MM)</code> would travel more or less than 500mm - Autonomous routines would be inaccurate - Robot might crash into walls or miss targets</p> <p>Calculation: 4-inch omni wheel \u00d7 \u03c0 \u2248 319.19mm</p> <p>Tutorial Reference: DriveTrain configuration</p>"},{"location":"02-robot-anatomy/04-review-qa/#q39-answer-forward","title":"Q39. Answer: FORWARD","text":"<p><pre><code>drivetrain.drive_for(FORWARD, 500, MM)\n</code></pre> Tutorial Reference: DriveTrain Methods section</p>"},{"location":"02-robot-anatomy/04-review-qa/#q40-answer","title":"Q40. Answer:","text":"<p><code>set_velocity()</code> only sets the speed\u2014it doesn't start the motor spinning!</p> <p>You need to add: <pre><code>motor.set_velocity(50, PERCENT)\nmotor.spin(FORWARD)  # This actually starts the motor\n</code></pre></p> <p>Or use: <code>motor.spin(FORWARD, 50, PERCENT)</code> which does both at once.</p> <p>Tutorial Reference: Section \"Setting Velocity\" vs \"Spinning the Motor\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q41-answer-b-the-total-rotation-of-the-motor-since-it-was-reset","title":"Q41. Answer: B) The total rotation of the motor since it was reset","text":"<p>Explanation: <code>position()</code> returns cumulative rotation in degrees. After 3 full rotations, it would return 1080 degrees. Tutorial Reference: Section \"Reading Motor Values\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q42-answer","title":"Q42. Answer:","text":"<p>a) Trade-offs: Green cartridge (200 RPM) is balanced\u2014not the fastest for pushing blocks, not the strongest for climbing. You might: - Struggle to push blocks against opponents (need more speed for momentum) - Struggle to climb the platform (need more torque for incline)</p> <p>b) Code compensation for climbing: - Reduce velocity to 30-40% when climbing (motors produce more effective torque at lower speeds) - Use <code>set_stopping(HOLD)</code> to prevent rollback - Take a running start to use momentum - Monitor motor temperature to avoid overheating</p>"},{"location":"02-robot-anatomy/04-review-qa/#q43-answer","title":"Q43. Answer:","text":"<pre><code># In robot_config.py:\nintake_motor = Motor(Ports.PORT5, GearSetting.RATIO_6_1, False)\n\n# In driver_control.py (inside the while loop):\nif controller.buttonR1.pressing():\n    intake_motor.spin(FORWARD, 100, PERCENT)\nelif controller.buttonR2.pressing():\n    intake_motor.spin(REVERSE, 100, PERCENT)\nelse:\n    intake_motor.stop()\n</code></pre>"},{"location":"02-robot-anatomy/04-review-qa/#q44-answer","title":"Q44. Answer:","text":"<p>a) Detect overheating: <pre><code>if motor.temperature(CELSIUS) &gt; 50:\n    brain.screen.print(\"WARNING: Motor hot!\")\n</code></pre></p> <p>b) Prevent damage: - Display warning on brain screen - Reduce motor speed temporarily - Switch to COAST mode to let motors rest - Alert driver to ease up on controls</p> <p>Note: V5 motors have built-in thermal protection that will slow/stop motors automatically, but monitoring helps you address the issue proactively.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q45-answer","title":"Q45. Answer:","text":"<p>Path description: 1. Start at origin, facing forward 2. Drive forward 600mm 3. Turn right 90 degrees (now facing right) 4. Drive forward 400mm 5. Turn left 90 degrees (now facing forward again) 6. Drive backward 200mm</p> <p>Visual path (if viewed from above): <pre><code>    START\n      \u2502\n      \u2502 600mm\n      \u2193\n      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2192 400mm\n               \u2502\n               \u2502 200mm (reverse)\n               \u2191\n             END\n</code></pre></p> <p>The robot ends up 400mm to the right and 400mm forward from start, facing forward.</p>"},{"location":"02-robot-anatomy/04-review-qa/#part-3-sensors-answers","title":"Part 3: Sensors Answers","text":""},{"location":"02-robot-anatomy/04-review-qa/#q46-answer-b-lets-the-robot-see-and-feel-the-world","title":"Q46. Answer: B) Lets the robot \"see\" and \"feel\" the world","text":"<p>Explanation: Sensors give robots information about their environment\u2014distance, direction, colors, position. Tutorial Reference: Opening section \"What Are Sensors?\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q47-answer-true","title":"Q47. Answer: True","text":"<p>Explanation: The Inertial Sensor measures heading (compass direction 0-360\u00b0), rotation, tilt, and acceleration. Tutorial Reference: Inertial Sensor section</p>"},{"location":"02-robot-anatomy/04-review-qa/#q48-answer-distance","title":"Q48. Answer: Distance","text":"<p>Explanation: The Distance Sensor uses ultrasonic waves (like sonar) to measure distance to objects. Tutorial Reference: Distance Sensor section</p>"},{"location":"02-robot-anatomy/04-review-qa/#q49-answer-c-optical-sensor","title":"Q49. Answer: C) Optical Sensor","text":"<p>Explanation: The Optical Sensor has a light and color detector to identify block colors. Tutorial Reference: Optical Sensor section</p>"},{"location":"02-robot-anatomy/04-review-qa/#q50-answer-b-0-to-360","title":"Q50. Answer: B) 0 to 360","text":"<p>Explanation: <code>heading()</code> returns compass-style values that wrap around (359\u00b0 \u2192 0\u00b0). Tutorial Reference: Section \"Using the Inertial Sensor\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q51-answer-calibrate","title":"Q51. Answer: calibrate","text":"<p>Explanation: <code>inertial_sensor.calibrate()</code> must be called before use, followed by a ~3 second wait. Tutorial Reference: Inertial sensor code example</p>"},{"location":"02-robot-anatomy/04-review-qa/#q52-answer-true","title":"Q52. Answer: True","text":"<p>Explanation: The GPS Sensor uses the field's positioning strips to determine exact X,Y coordinates. Tutorial Reference: GPS Sensor section</p>"},{"location":"02-robot-anatomy/04-review-qa/#q53-answer-c-inertial-sensor","title":"Q53. Answer: C) Inertial Sensor","text":"<p>Explanation: SmartDrive = DriveTrain + Inertial Sensor, enabling more accurate turns. Tutorial Reference: Section \"SmartDrive: DriveTrain + Inertial\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q54-answer","title":"Q54. Answer:","text":"<p>Missing calibration! The inertial sensor must be calibrated before reading values:</p> <pre><code>inertial_sensor = Inertial(Ports.PORT5)\ninertial_sensor.calibrate()      # Missing!\nwait(3, SECONDS)                  # Missing!\nheading = inertial_sensor.heading()\n</code></pre> <p>Without calibration, readings will be inaccurate or unpredictable.</p> <p>Tutorial Reference: Inertial sensor setup</p>"},{"location":"02-robot-anatomy/04-review-qa/#q55-answer-object_distance","title":"Q55. Answer: object_distance","text":"<p><pre><code>dist = distance_sensor.object_distance(MM)\n</code></pre> Tutorial Reference: Distance Sensor code example</p>"},{"location":"02-robot-anatomy/04-review-qa/#q56-answer","title":"Q56. Answer:","text":"<p>The code creates an automatic obstacle avoidance system: - Continuously checks distance to objects - If something is within 100mm (about 4 inches), the robot stops - Otherwise, the robot keeps driving forward</p> <p>This prevents the robot from crashing into walls or obstacles.</p> <p>Tutorial Reference: Distance Sensor example</p>"},{"location":"02-robot-anatomy/04-review-qa/#q57-answer","title":"Q57. Answer:","text":"<p>heading(): Returns 0-360 degrees, like a compass. Wraps around (after 360\u00b0 comes 0\u00b0 again). Best for knowing which direction you're pointing.</p> <p>rotation(): Returns continuous degrees, can be any number including negative. Keeps counting (720\u00b0 after two rotations). Best for measuring how much you've turned.</p> <p>Example: - Use <code>heading()</code> to \"face north\" (heading = 0\u00b0) - Use <code>rotation()</code> to \"turn exactly 450 degrees\" for a spin move</p> <p>Tutorial Reference: Heading vs Rotation diagram</p>"},{"location":"02-robot-anatomy/04-review-qa/#q58-answer","title":"Q58. Answer:","text":"<ul> <li>Inertial = C (Your inner ear for balance)</li> <li>Distance = A (Car parking sensors)</li> <li>Optical = D (Your eyes seeing colors)</li> <li>GPS = B (GPS navigation in a car)</li> </ul> <p>Tutorial Reference: Sensors are like senses analogy in tutorial</p>"},{"location":"02-robot-anatomy/04-review-qa/#q59-answer","title":"Q59. Answer:","text":"<p>The optical sensor needs light to detect colors accurately. Without light: - Colors appear darker/different - Detection is unreliable - Especially problematic in dim competition venues</p> <p>The built-in LED provides consistent illumination regardless of ambient lighting.</p> <p>Tutorial Reference: Optical sensor code example</p>"},{"location":"02-robot-anatomy/04-review-qa/#q60-answer","title":"Q60. Answer:","text":"<ul> <li><code>heading()</code> = 0 degrees (wraps: 720 mod 360 = 0)</li> <li><code>rotation()</code> = 720 degrees (continuous counting)</li> </ul> <p>Explanation: Heading resets every 360\u00b0, rotation keeps adding. Tutorial Reference: Heading vs Rotation comparison</p>"},{"location":"02-robot-anatomy/04-review-qa/#q61-answer","title":"Q61. Answer:","text":"<p>a) Inertial Sensor: - Autonomous: Accurate 90\u00b0 turns, drive straight correction - Driver: Detect if opponent pushes you (sudden rotation change)</p> <p>b) Distance Sensor: - Autonomous: Stop before hitting goals, detect walls - Driver: Warning when backing up near obstacles</p> <p>c) Optical Sensor: - Autonomous: Identify block colors for scoring strategy - Driver: Display block color on brain screen to help driver see</p> <p>Tutorial Reference: Section \"Why Sensors Matter for Push Back\"</p>"},{"location":"02-robot-anatomy/04-review-qa/#q62-answer","title":"Q62. Answer:","text":"<pre><code># Configure inertial sensor\ninertial_sensor = Inertial(Ports.PORT5)\ninertial_sensor.calibrate()\nwait(3, SECONDS)\n\n# Configure distance sensor\ndistance_sensor = Distance(Ports.PORT6)\n\n# Reset rotation for accurate turn measurement\ninertial_sensor.reset_rotation()\n\n# Drive until close to object\nwhile distance_sensor.object_distance(MM) &gt;= 150:\n    left_motors.spin(FORWARD, 40, PERCENT)\n    right_motors.spin(FORWARD, 40, PERCENT)\n    wait(20, MSEC)\n\n# Stop\nleft_motors.stop()\nright_motors.stop()\nwait(200, MSEC)\n\n# Turn right 90 degrees using inertial\nwhile inertial_sensor.rotation() &lt; 90:\n    left_motors.spin(FORWARD, 30, PERCENT)\n    right_motors.spin(REVERSE, 30, PERCENT)\n    wait(20, MSEC)\n\n# Stop\nleft_motors.stop()\nright_motors.stop()\n</code></pre>"},{"location":"02-robot-anatomy/04-review-qa/#q63-answer","title":"Q63. Answer:","text":"<p>Approach A advantages: - Simple, one line of code - Uses DriveTrain's built-in motor control - Good for basic autonomous</p> <p>Approach B advantages: - Uses sensor feedback for accuracy - Compensates for motor slip, battery variation - More consistent results across matches</p> <p>When to use each: - Use A for quick prototyping or when precision isn't critical - Use B for competition when you need exact angles every time - Best solution: SmartDrive combines both (DriveTrain + Inertial)</p>"},{"location":"02-robot-anatomy/04-review-qa/#part-4-integration-and-competition-answers","title":"Part 4: Integration and Competition Answers","text":""},{"location":"02-robot-anatomy/04-review-qa/#q64-answer","title":"Q64. Answer:","text":"<p>Flow of information: 1. Joystick physical movement - You push stick forward 2. Controller reads position - axis3 returns value (e.g., 80) 3. Wireless transmission - Radio sends data to Brain 4. Brain runs code - <code>controller.axis3.position()</code> returns 80 5. Code sets motor velocity - <code>left_motors.set_velocity(80, PERCENT)</code> 6. Motors spin - Electrical signal to motors 7. Robot moves forward - Wheels turn, robot drives</p>"},{"location":"02-robot-anatomy/04-review-qa/#q65-answer","title":"Q65. Answer:","text":"<p>a) Drive straight forward: Push both joysticks forward equally. Left stick controls left motors, right stick controls right motors. Both at same speed = straight line.</p> <p>b) Turn right in place: Push left joystick forward, right joystick backward. Left motors go forward, right motors go backward = robot spins clockwise (right) without moving forward.</p> <p>c) Turn left while moving forward: Push both joysticks forward, but left joystick less than right (or pull left back slightly). Left side slower than right = robot curves left while moving.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q66-answer","title":"Q66. Answer:","text":"<pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  wireless   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  CONTROLLER  \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;  \u2502    BRAIN     \u2502\n    \u2502              \u2502   radio     \u2502              \u2502\n    \u2502  axis3 = 80  \u2502             \u2502  Runs code   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                        \u2502\n                                   Smart cable\n                                        \u2193\n                                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                 \u2502   MOTORS     \u2502\n                                 \u2502              \u2502\n                                 \u2502  spin at 80% \u2502\n                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"02-robot-anatomy/04-review-qa/#q67-answer","title":"Q67. Answer:","text":"<p>The robot would behave opposite to expected: - Pushing left joystick forward would spin RIGHT motors (which are reversed) - Pushing right joystick forward would spin LEFT motors (not reversed) - Result: Robot would turn instead of going straight - Controls would feel \"crossed\" and confusing</p> <p>Why: The code expects left motors on ports 1-2 and right on 3-4, but the physical wiring is swapped.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q68-answer","title":"Q68. Answer:","text":"<p>These constants tell the DriveTrain about your robot's physical dimensions:</p> <p>WHEEL_TRAVEL_MM (319.19): Wheel circumference. If wrong, distances are wrong\u2014<code>drive_for(FORWARD, 500, MM)</code> might actually go 400mm or 600mm.</p> <p>TRACK_WIDTH_MM (295): Distance between left and right wheels. If wrong, turns are wrong\u2014a 90\u00b0 turn might be 80\u00b0 or 100\u00b0.</p> <p>WHEEL_BASE_MM (200): Front-to-back distance. Affects turning calculations.</p> <p>Impact of wrong values: Autonomous routines miss targets, crash into obstacles, or score in wrong locations.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q69-answer","title":"Q69. Answer:","text":"<pre><code>from vex import *\n\n# Brain and Controller\nbrain = Brain()\ncontroller = Controller(PRIMARY)\n\n# Drive motors (green cartridge)\nleft_motor_front = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nleft_motor_back = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\nright_motor_front = Motor(Ports.PORT3, GearSetting.RATIO_18_1, True)\nright_motor_back = Motor(Ports.PORT4, GearSetting.RATIO_18_1, True)\n\n# Mechanism motors\nintake_motor = Motor(Ports.PORT5, GearSetting.RATIO_6_1, False)   # Blue\nlift_motor = Motor(Ports.PORT6, GearSetting.RATIO_36_1, False)    # Red\n\n# Motor groups\nleft_motors = MotorGroup(left_motor_front, left_motor_back)\nright_motors = MotorGroup(right_motor_front, right_motor_back)\n\n# Sensor\ninertial_sensor = Inertial(Ports.PORT7)\n\n# DriveTrain\nWHEEL_TRAVEL_MM = 319.19\nTRACK_WIDTH_MM = 295\nWHEEL_BASE_MM = 200\n\ndrivetrain = DriveTrain(left_motors, right_motors, WHEEL_TRAVEL_MM,\n                        TRACK_WIDTH_MM, WHEEL_BASE_MM, MM, 1)\n</code></pre>"},{"location":"02-robot-anatomy/04-review-qa/#q70-answer","title":"Q70. Answer:","text":"<p>5 Possible Causes and Checks:</p> <ol> <li> <p>Motor reversal wrong: Check that right motors are set to <code>True</code> (reversed). Test: Run one side at a time and verify direction.</p> </li> <li> <p>Wheel sizes different: Worn wheels spin at different rates. Check: Measure wheel diameters, replace if uneven.</p> </li> <li> <p>Port connections swapped: Wrong motor on wrong port. Check: Disconnect one motor, see which side stops.</p> </li> <li> <p>Friction differences: One side drags more than other. Check: Lift robot, spin wheels by hand, compare resistance.</p> </li> <li> <p>Motor damage/wear: One motor weaker than others. Check: Run all 4 motors at same speed, listen/feel for differences. Check motor temperature.</p> </li> </ol>"},{"location":"02-robot-anatomy/04-review-qa/#q71-answer","title":"Q71. Answer:","text":"<pre><code>def driver_control_loop():\n    while True:\n        # Tank drive\n        left_speed = deadband(controller.axis3.position(), 5)\n        right_speed = deadband(controller.axis2.position(), 5)\n\n        left_motors.set_velocity(left_speed, PERCENT)\n        right_motors.set_velocity(right_speed, PERCENT)\n        left_motors.spin(FORWARD)\n        right_motors.spin(FORWARD)\n\n        # Intake control\n        if controller.buttonR1.pressing():\n            intake_motor.spin(FORWARD, 100, PERCENT)\n        elif controller.buttonR2.pressing():\n            intake_motor.spin(REVERSE, 100, PERCENT)\n        else:\n            intake_motor.stop()\n\n        # Lift control\n        if controller.buttonL1.pressing():\n            lift_motor.spin(FORWARD, 75, PERCENT)  # Up\n        elif controller.buttonL2.pressing():\n            lift_motor.spin(REVERSE, 75, PERCENT)  # Down\n        else:\n            lift_motor.stop()\n\n        # Display temperatures (every ~1 second)\n        brain.screen.clear_screen()\n        brain.screen.set_cursor(1, 1)\n        brain.screen.print(\"LF:\" + str(int(left_motor_front.temperature(CELSIUS))) + \"C \")\n        brain.screen.print(\"RF:\" + str(int(right_motor_front.temperature(CELSIUS))) + \"C\")\n\n        wait(20, MSEC)\n</code></pre>"},{"location":"02-robot-anatomy/04-review-qa/#q72-answer","title":"Q72. Answer:","text":"<p>LEFT side starting position strategy:</p> <ol> <li>Setup: Face toward center of field</li> <li>Drive forward: ~800mm toward nearest block</li> <li>Turn: 45\u00b0 right to align with goal zone</li> <li>Drive forward: ~600mm to push block into zone</li> <li>Backup and reposition if time permits</li> </ol> <p>Helpful sensors: - Inertial: Accurate 45\u00b0 turn - Distance: Stop before hitting the wall - Optical: Verify block color (if relevant)</p> <p>Estimated time: 10-12 seconds, leaves buffer for adjustments</p>"},{"location":"02-robot-anatomy/04-review-qa/#q73-answer-c-hold-resist-movement","title":"Q73. Answer: C) HOLD - Resist movement","text":"<p>Explanation: The elevated platform is inclined. - COAST: Robot would roll backward - BRAKE: Robot might slowly slip - HOLD: Motors actively resist\u2014robot stays parked</p> <p>This is especially important because Push Back awards parking points.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q74-answer","title":"Q74. Answer:","text":"<p>a) Autonomous distances: - Motors may spin slower at low battery - Robot might not travel full distances - Turns might undershoot</p> <p>b) Motor performance: - Reduced top speed - Less pushing power - Possible brownouts under heavy load</p> <p>c) Adjustments: - Reduce autonomous speeds to be more consistent - Use sensor feedback (inertial, distance) instead of time-based movements - Avoid extended full-power pushing - Use HOLD mode sparingly (draws more power) - Conserve power early, push hard at end if needed</p>"},{"location":"02-robot-anatomy/04-review-qa/#q75-answer","title":"Q75. Answer:","text":"<pre><code># Pseudocode for push detection\nPUSH_THRESHOLD = 15  # degrees of sudden rotation\n\n# Store previous rotation\nprevious_rotation = inertial_sensor.rotation()\n\nwhile True:\n    current_rotation = inertial_sensor.rotation()\n    rotation_change = abs(current_rotation - previous_rotation)\n\n    # If sudden large rotation change (someone pushed us)\n    if rotation_change &gt; PUSH_THRESHOLD:\n        brain.screen.clear_screen()\n        brain.screen.set_cursor(1, 1)\n        brain.screen.print(\"PUSHED!\")\n        # Could also: change screen color, trigger sound, etc.\n\n    previous_rotation = current_rotation\n    wait(50, MSEC)  # Check frequently\n</code></pre>"},{"location":"02-robot-anatomy/04-review-qa/#q76-answer","title":"Q76. Answer:","text":"<p>a) Cause: Motor slip, wheel slip, or friction variations. The motors turn the requested amount, but the robot's actual rotation is less due to: - Wheels slipping on the field surface - Battery voltage affecting motor power - Friction differences between wheels</p> <p>b) Fix without inertial sensor: - Increase turn amount: <code>turn_for(RIGHT, 95, DEGREES)</code> (trial and error) - Reduce turn speed for less slip - Add small correction turns - Problem: Not reliable across different field surfaces</p> <p>c) Inertial sensor solution: <pre><code>while inertial_sensor.rotation() &lt; 90:\n    # Keep turning until sensor confirms 90\u00b0\n    ...\n</code></pre> The sensor measures actual robot rotation, not motor rotation. It self-corrects regardless of slip.</p>"},{"location":"02-robot-anatomy/04-review-qa/#q77-answer","title":"Q77. Answer:","text":"<p>60-second Skills Routine Outline:</p> <pre><code>def skills_autonomous():\n    setup_autonomous()\n\n    # Start in center, facing left\n    # Phase 1: Clear left blocks (15 sec)\n    drivetrain.drive_for(FORWARD, 1000, MM)    # Push left blocks\n    drivetrain.drive_for(REVERSE, 400, MM)     # Back up\n    drivetrain.turn_for(RIGHT, 90, DEGREES)    # Face forward\n\n    # Phase 2: Clear center blocks (20 sec)\n    drivetrain.drive_for(FORWARD, 800, MM)\n    drivetrain.turn_for(LEFT, 45, DEGREES)\n    drivetrain.drive_for(FORWARD, 600, MM)\n    drivetrain.drive_for(REVERSE, 600, MM)\n    drivetrain.turn_for(RIGHT, 90, DEGREES)    # Similar pattern\n\n    # Phase 3: Clear right blocks (15 sec)\n    drivetrain.drive_for(FORWARD, 1000, MM)\n    drivetrain.drive_for(REVERSE, 500, MM)\n\n    # Phase 4: Park (10 sec)\n    drivetrain.turn_for(LEFT, 135, DEGREES)    # Face platform\n    drivetrain.drive_for(FORWARD, 800, MM)     # Drive onto platform\n    drivetrain.set_stopping(HOLD)\n    drivetrain.stop()\n</code></pre> <p>Key considerations: - Leave time buffer (aim for 55 seconds of movement) - Practice on actual field for distance tuning - Use inertial sensor for accurate turns - End with HOLD to stay parked</p>"},{"location":"02-robot-anatomy/04-review-qa/#q78-answer","title":"Q78. Answer:","text":"Feature Tank Drive Arcade Drive Forward/backward Both sticks same direction Left stick Y (up/down) Turning Left stick = left wheels, Right stick = right wheels Left stick X (left/right) Best for... Precise turning, experienced drivers New drivers, one-handed control <p>For Push Back, I would choose: Tank Drive</p> <p>Why: - Push Back requires precise positioning and pushing - Tank drive gives more control over each wheel - Easier to make small adjustments while pushing blocks - Spin turns are intuitive (push sticks opposite directions) - Team drivers usually prefer tank once practiced</p>"},{"location":"02-robot-anatomy/04-review-qa/#q79-answer","title":"Q79. Answer:","text":"<p>Hardware Checks (3): 1. Battery charged above 70% 2. All cables securely connected (no loose smart cables) 3. Controller paired and responding (test joysticks and buttons)</p> <p>Software Checks (3): 1. Correct autonomous routine selected (LEFT vs RIGHT position) 2. Driver control mode correct (Tank or Arcade as practiced) 3. Code downloaded and fresh (re-download if made recent changes)</p> <p>Strategy Preparation (2): 1. Confirm alliance strategy with partner team (who does what) 2. Know starting position and autonomous sequence mentally</p> <p>Bonus checks: - Wheels clean and not worn - No game pieces stuck in robot - Robot fits in starting size limits - Know field orientation (driver station side)</p>"},{"location":"02-robot-anatomy/04-review-qa/#quick-reference-cheat-sheet","title":"Quick Reference Cheat Sheet","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           MODULE 2: ROBOT ANATOMY - QUICK REFERENCE             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 BRAIN                                                           \u2502\n\u2502   Brain()            - Create brain object                      \u2502\n\u2502   21 Smart Ports     - Connect motors/sensors                   \u2502\n\u2502   brain.screen       - Display information                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 CONTROLLER                                                      \u2502\n\u2502   Controller(PRIMARY)      - Main controller                    \u2502\n\u2502   axis1/axis2 (right)      - Right joystick X/Y                \u2502\n\u2502   axis3/axis4 (left)       - Left joystick X/Y                 \u2502\n\u2502   Values: -100 to +100     - Centered = 0                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 MOTORS                                                          \u2502\n\u2502   Motor(port, gear, reversed)                                   \u2502\n\u2502   Gears: 6:1 (blue/fast), 18:1 (green/balanced), 36:1 (red)    \u2502\n\u2502   Right motors: reversed=True (mirror mounting)                 \u2502\n\u2502   Methods: spin(), stop(), set_velocity()                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 MOTOR GROUPS &amp; DRIVETRAIN                                       \u2502\n\u2502   MotorGroup(motor1, motor2)  - Control together               \u2502\n\u2502   DriveTrain(left, right, wheel, track, base, units, ratio)    \u2502\n\u2502   drive_for(), turn_for()     - Autonomous movements           \u2502\n\u2502   Stopping: COAST, BRAKE, HOLD                                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 SENSORS                                                         \u2502\n\u2502   Inertial: heading() [0-360], rotation() [continuous]         \u2502\n\u2502   Distance: object_distance(MM)                                \u2502\n\u2502   Optical: color(), is_near_object()                           \u2502\n\u2502   GPS: x_position(), y_position()                              \u2502\n\u2502   SmartDrive = DriveTrain + Inertial Sensor                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 YOUR ROBOT'S PORT MAP                                           \u2502\n\u2502   Port 1: Left Front Motor                                      \u2502\n\u2502   Port 2: Left Back Motor                                       \u2502\n\u2502   Port 3: Right Front Motor (reversed)                         \u2502\n\u2502   Port 4: Right Back Motor (reversed)                          \u2502\n\u2502   Port 5+: Sensors (when added)                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>\u2190 Back to Tutorial 2.3 | Next: Tutorial 3 - Python Basics \u2192</p>"},{"location":"03-python-basics/00-flowchart/","title":"Tutorial 3.0: Thinking with Flowcharts","text":"<p>Time: ~20 minutes Prerequisites: None - this is where your programming journey begins!</p>"},{"location":"03-python-basics/00-flowchart/#why-start-with-flowcharts","title":"Why Start with Flowcharts?","text":"<p>Before you write a single line of code, you need to think like a programmer. Programmers don't just type - they plan, visualize, and break problems into steps.</p> <p>A flowchart is a visual map that shows: - What steps to take - What order to take them - What decisions to make along the way</p> <p>Think of it like GPS directions for solving problems!</p> <pre><code>flowchart LR\n    A[\"Problem\"] --&gt; B[\"Flowchart\"]\n    B --&gt; C[\"Code\"]\n    C --&gt; D[\"Working Robot!\"]\n\n    style A fill:#ffcdd2,stroke:#c62828\n    style D fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"03-python-basics/00-flowchart/#what-is-a-flowchart","title":"What is a Flowchart?","text":"<p>A flowchart is a diagram that shows the steps to solve a problem, connected by arrows that show the order.</p>"},{"location":"03-python-basics/00-flowchart/#real-world-example-making-toast","title":"Real-World Example: Making Toast","text":"<p>You do this without thinking, but there ARE steps:</p> <pre><code>flowchart LR\n    A([Start]) --&gt; B[Get bread]\n    B --&gt; C[Put in toaster]\n    C --&gt; D[Wait for toast]\n    D --&gt; E[Remove toast]\n    E --&gt; F([End])\n\n    style A fill:#e8f5e9,stroke:#2e7d32\n    style F fill:#ffcdd2,stroke:#c62828</code></pre> <p>See? Even making toast is a sequence of steps. Programming is the same - just with different steps!</p>"},{"location":"03-python-basics/00-flowchart/#flowchart-symbols","title":"Flowchart Symbols","text":"<p>Every shape in a flowchart has a meaning:</p> <pre><code>flowchart TD\n    A([Oval: Start or End]) --&gt; B[Rectangle: Do Something]\n    B --&gt; C{Diamond: Ask a Question}\n    C --&gt;|Yes| D[/Parallelogram: Input or Output/]\n    C --&gt;|No| E[Another Action]\n\n    style A fill:#e8f5e9,stroke:#2e7d32\n    style C fill:#fff9c4,stroke:#f57f17</code></pre>"},{"location":"03-python-basics/00-flowchart/#symbol-reference","title":"Symbol Reference","text":"Shape Name What It Means Example Oval <code>([...])</code> Terminal Start or End of program <code>([Start])</code>, <code>([End])</code> Rectangle <code>[...]</code> Process An action or step <code>[Set motor speed]</code> Diamond <code>{...}</code> Decision Yes/No question <code>{Is button pressed?}</code> Parallelogram <code>[/.../]</code> Input/Output Get or show data <code>[/Read joystick/]</code> Arrow <code>--&gt;</code> Flow Order of steps Shows what comes next"},{"location":"03-python-basics/00-flowchart/#part-1-sequential-flow-steps-in-order","title":"Part 1: Sequential Flow (Steps in Order)","text":"<p>The simplest flowcharts are sequential - one step after another, like following a recipe.</p>"},{"location":"03-python-basics/00-flowchart/#example-1-robot-moves-forward","title":"Example 1: Robot Moves Forward","text":"<pre><code>flowchart TD\n    A([Start]) --&gt; B[Set speed to 50%]\n    B --&gt; C[Drive forward 500mm]\n    C --&gt; D[Stop motors]\n    D --&gt; E([End])\n\n    style A fill:#e8f5e9,stroke:#2e7d32\n    style E fill:#ffcdd2,stroke:#c62828</code></pre> <p>This is exactly how autonomous robot code works - do this, then this, then this!</p>"},{"location":"03-python-basics/00-flowchart/#the-code-it-becomes","title":"The Code It Becomes","text":"<pre><code># Sequential steps - just like the flowchart!\ndef simple_autonomous():\n    drivetrain.set_velocity(50, PERCENT)    # Set speed to 50%\n    drivetrain.drive_for(FORWARD, 500, MM)  # Drive forward 500mm\n    drivetrain.stop()                        # Stop motors\n</code></pre>"},{"location":"03-python-basics/00-flowchart/#coding-question-1-easy","title":"Coding Question #1 (Easy)","text":"<p>Convert this flowchart to English steps:</p> <pre><code>flowchart TD\n    A([Start]) --&gt; B[Turn on LED]\n    B --&gt; C[Wait 2 seconds]\n    C --&gt; D[Turn off LED]\n    D --&gt; E([End])</code></pre> Click to see answer  **English Steps:** 1. Start the program 2. Turn on the LED 3. Wait for 2 seconds 4. Turn off the LED 5. End the program"},{"location":"03-python-basics/00-flowchart/#part-2-decision-making-ifelse","title":"Part 2: Decision Making (If/Else)","text":"<p>Real programs make decisions. The diamond shape asks a Yes/No question, and the answer determines which path to take.</p>"},{"location":"03-python-basics/00-flowchart/#example-2-should-i-bring-an-umbrella","title":"Example 2: Should I Bring an Umbrella?","text":"<pre><code>flowchart TD\n    A([Start]) --&gt; B{Is it raining?}\n    B --&gt;|Yes| C[Bring umbrella]\n    B --&gt;|No| D[Leave umbrella home]\n    C --&gt; E([Go outside])\n    D --&gt; E\n\n    style B fill:#fff9c4,stroke:#f57f17\n    style C fill:#bbdefb,stroke:#1565c0\n    style D fill:#c8e6c9,stroke:#2e7d32</code></pre> <p>The diamond asks a question. Yes goes one way, No goes another.</p>"},{"location":"03-python-basics/00-flowchart/#example-3-robot-button-detection","title":"Example 3: Robot Button Detection","text":"<pre><code>flowchart TD\n    A([Start]) --&gt; B{Is button pressed?}\n    B --&gt;|Yes| C[Move forward]\n    B --&gt;|No| D[Stop motors]\n    C --&gt; E([End])\n    D --&gt; E\n\n    style B fill:#fff9c4,stroke:#f57f17\n    style C fill:#c8e6c9,stroke:#2e7d32\n    style D fill:#ffcdd2,stroke:#c62828</code></pre>"},{"location":"03-python-basics/00-flowchart/#the-code-it-becomes_1","title":"The Code It Becomes","text":"<pre><code>if controller.buttonA.pressing():\n    drivetrain.drive(FORWARD)   # Button pressed - move!\nelse:\n    drivetrain.stop()           # No button - stop!\n</code></pre>"},{"location":"03-python-basics/00-flowchart/#example-4-multiple-decisions-ifelifelse","title":"Example 4: Multiple Decisions (If/Elif/Else)","text":"<p>Sometimes you need to check multiple conditions. This is called if/elif/else:</p> <pre><code>flowchart TD\n    A{speed &gt; 75?} --&gt;|Yes| B[\"Print 'Fast!'\"]\n    A --&gt;|No| C{speed &gt; 25?}\n    C --&gt;|Yes| D[\"Print 'Medium'\"]\n    C --&gt;|No| E[\"Print 'Slow'\"]\n\n    style A fill:#fff9c4,stroke:#f57f17\n    style C fill:#fff9c4,stroke:#f57f17\n    style B fill:#ffcdd2,stroke:#c62828\n    style D fill:#fff3e0,stroke:#ef6c00\n    style E fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"03-python-basics/00-flowchart/#the-code-it-becomes_2","title":"The Code It Becomes","text":"<pre><code>if speed &gt; 75:\n    print(\"Fast!\")\nelif speed &gt; 25:\n    print(\"Medium\")\nelse:\n    print(\"Slow\")\n</code></pre>"},{"location":"03-python-basics/00-flowchart/#coding-question-2-easy","title":"Coding Question #2 (Easy)","text":"<p>Draw a flowchart for this problem:</p> <p>\"If score &gt; 80, print 'You win!', else print 'Try again'\"</p> Click to see answer <pre><code>flowchart TD\n    A([Start]) --&gt; B{score &gt; 80?}\n    B --&gt;|Yes| C[\"Print 'You win!'\"]\n    B --&gt;|No| D[\"Print 'Try again'\"]\n    C --&gt; E([End])\n    D --&gt; E\n\n    style B fill:#fff9c4,stroke:#f57f17\n    style C fill:#c8e6c9,stroke:#2e7d32\n    style D fill:#ffcdd2,stroke:#c62828</code></pre>"},{"location":"03-python-basics/00-flowchart/#coding-question-3-medium","title":"Coding Question #3 (Medium)","text":"<p>Convert this flowchart to Python if/elif/else:</p> <pre><code>flowchart TD\n    A{temperature &gt; 30?} --&gt;|Yes| B[\"Print 'Hot!'\"]\n    A --&gt;|No| C{temperature &gt; 15?}\n    C --&gt;|Yes| D[\"Print 'Nice'\"]\n    C --&gt;|No| E[\"Print 'Cold'\"]</code></pre> Click to see answer <pre><code>if temperature &gt; 30:\n    print(\"Hot!\")\nelif temperature &gt; 15:\n    print(\"Nice\")\nelse:\n    print(\"Cold\")\n</code></pre>"},{"location":"03-python-basics/00-flowchart/#part-3-loops-repetition","title":"Part 3: Loops (Repetition)","text":"<p>Sometimes you need to repeat steps. In flowcharts, we show this with arrows that loop back.</p>"},{"location":"03-python-basics/00-flowchart/#example-5-count-to-5","title":"Example 5: Count to 5","text":"<pre><code>flowchart TD\n    A([Start]) --&gt; B[count = 0]\n    B --&gt; C{count &lt; 5?}\n    C --&gt;|No| D([End])\n    C --&gt;|Yes| E[\"print(count)\"]\n    E --&gt; F[count = count + 1]\n    F --&gt; C\n\n    style C fill:#fff9c4,stroke:#f57f17\n    style F fill:#e3f2fd,stroke:#1565c0</code></pre> <p>Notice how the arrow from F goes back up to C? That's the loop!</p>"},{"location":"03-python-basics/00-flowchart/#the-code-it-becomes_3","title":"The Code It Becomes","text":"<pre><code>count = 0\nwhile count &lt; 5:\n    print(count)\n    count = count + 1\n# Output: 0, 1, 2, 3, 4\n</code></pre>"},{"location":"03-python-basics/00-flowchart/#example-6-driver-control-loop-forever-loop","title":"Example 6: Driver Control Loop (Forever Loop)","text":"<p>Robot driver control runs forever during a match:</p> <pre><code>flowchart TD\n    A([Start]) --&gt; B{Match running?}\n    B --&gt;|No| C([End])\n    B --&gt;|Yes| D[Read joystick]\n    D --&gt; E[Set motor speed]\n    E --&gt; F[Wait 20ms]\n    F --&gt; B\n\n    style B fill:#fff9c4,stroke:#f57f17\n    style D fill:#e3f2fd,stroke:#1565c0\n    style E fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"03-python-basics/00-flowchart/#the-code-it-becomes_4","title":"The Code It Becomes","text":"<pre><code>while True:  # Forever loop!\n    left_speed = controller.axis3.position()\n    right_speed = controller.axis2.position()\n    left_motors.spin(FORWARD, left_speed, PERCENT)\n    right_motors.spin(FORWARD, right_speed, PERCENT)\n    wait(20, MSEC)\n</code></pre>"},{"location":"03-python-basics/00-flowchart/#coding-question-4-medium","title":"Coding Question #4 (Medium)","text":"<p>Write the Python code for this \"count to 5\" flowchart:</p> <pre><code>flowchart TD\n    A([Start]) --&gt; B[count = 0]\n    B --&gt; C{count &lt; 5?}\n    C --&gt;|No| D([End])\n    C --&gt;|Yes| E[\"print(count)\"]\n    E --&gt; F[count = count + 1]\n    F --&gt; C</code></pre> Click to see answer <pre><code>count = 0\nwhile count &lt; 5:\n    print(count)\n    count = count + 1\n</code></pre>  **Output:** <pre><code>0\n1\n2\n3\n4\n</code></pre>"},{"location":"03-python-basics/00-flowchart/#coding-question-5-medium","title":"Coding Question #5 (Medium)","text":"<p>Draw a flowchart for:</p> <p>\"Keep asking for a password until it equals 'secret'\"</p> Click to see answer <pre><code>flowchart TD\n    A([Start]) --&gt; B[password = '']\n    B --&gt; C{password == 'secret'?}\n    C --&gt;|Yes| D[\"Print 'Access granted!'\"]\n    D --&gt; E([End])\n    C --&gt;|No| F[\"Ask user for password\"]\n    F --&gt; G[Store user input in password]\n    G --&gt; C\n\n    style C fill:#fff9c4,stroke:#f57f17\n    style D fill:#c8e6c9,stroke:#2e7d32</code></pre>  **The Python code:** <pre><code>password = \"\"\nwhile password != \"secret\":\n    password = input(\"Enter password: \")\nprint(\"Access granted!\")\n</code></pre>"},{"location":"03-python-basics/00-flowchart/#part-4-combining-decisions-and-loops","title":"Part 4: Combining Decisions and Loops","text":"<p>Real robot programs use BOTH decisions and loops together!</p>"},{"location":"03-python-basics/00-flowchart/#example-7-push-back-turbo-mode","title":"Example 7: Push Back Turbo Mode","text":"<p>During driver control, check if the turbo button is pressed:</p> <pre><code>flowchart TD\n    A([Start: Driver Control]) --&gt; B{Match running?}\n    B --&gt;|No| C([End])\n    B --&gt;|Yes| D[Read joystick]\n    D --&gt; E{R1 pressed?}\n    E --&gt;|Yes| F[\"speed = joystick \u00d7 1.5\"]\n    E --&gt;|No| G[\"speed = joystick \u00d7 1.0\"]\n    F --&gt; H[Set motors to speed]\n    G --&gt; H\n    H --&gt; I[Wait 20ms]\n    I --&gt; B\n\n    style B fill:#fff9c4,stroke:#f57f17\n    style E fill:#fff9c4,stroke:#f57f17\n    style F fill:#fff3e0,stroke:#ef6c00\n    style G fill:#e3f2fd,stroke:#1565c0</code></pre> <p>Key insight: The decision (R1 pressed?) happens inside the loop!</p>"},{"location":"03-python-basics/00-flowchart/#coding-question-6-hard","title":"Coding Question #6 (Hard)","text":"<p>Convert the Push Back turbo mode flowchart to Python:</p> Click to see answer <pre><code>def driver_control_with_turbo():\n    while True:  # Match running loop\n        # Read joystick\n        left_joy = controller.axis3.position()\n        right_joy = controller.axis2.position()\n\n        # Check for turbo button\n        if controller.buttonR1.pressing():\n            left_speed = left_joy * 1.5   # Turbo mode\n            right_speed = right_joy * 1.5\n        else:\n            left_speed = left_joy * 1.0   # Normal mode\n            right_speed = right_joy * 1.0\n\n        # Clamp to valid range\n        left_speed = clamp(left_speed, -100, 100)\n        right_speed = clamp(right_speed, -100, 100)\n\n        # Set motors\n        left_motors.spin(FORWARD, left_speed, PERCENT)\n        right_motors.spin(FORWARD, right_speed, PERCENT)\n\n        wait(20, MSEC)\n</code></pre>"},{"location":"03-python-basics/00-flowchart/#part-5-problem-solving-process","title":"Part 5: Problem-Solving Process","text":"<p>When you face a programming problem, follow these steps:</p> <pre><code>flowchart TD\n    A[\"1. Understand the problem\"] --&gt; B[\"2. Identify inputs &amp; outputs\"]\n    B --&gt; C[\"3. Break into small steps\"]\n    C --&gt; D[\"4. Add decisions if needed\"]\n    D --&gt; E[\"5. Add loops if repeating\"]\n    E --&gt; F[\"6. Draw the flowchart\"]\n    F --&gt; G[\"7. Write the code\"]\n\n    style A fill:#e3f2fd,stroke:#1565c0\n    style F fill:#fff9c4,stroke:#f57f17\n    style G fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"03-python-basics/00-flowchart/#example-robot-avoids-wall","title":"Example: \"Robot Avoids Wall\"","text":"<p>Problem: Robot drives forward. If distance sensor sees something closer than 200mm, turn right. Otherwise, keep going.</p> <p>Step 1: Understand - Robot should avoid walls Step 2: Inputs: distance sensor. Outputs: motor commands Step 3: Steps: read sensor, decide, move/turn Step 4: Decision: is distance &lt; 200mm? Step 5: Loop: keep checking forever</p> <pre><code>flowchart TD\n    A([Start]) --&gt; B{Match running?}\n    B --&gt;|No| C([End])\n    B --&gt;|Yes| D[Read distance sensor]\n    D --&gt; E{distance &lt; 200mm?}\n    E --&gt;|Yes| F[Turn right 90 degrees]\n    E --&gt;|No| G[Drive forward]\n    F --&gt; H[Wait 100ms]\n    G --&gt; H\n    H --&gt; B\n\n    style E fill:#fff9c4,stroke:#f57f17\n    style F fill:#ffcdd2,stroke:#c62828\n    style G fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"03-python-basics/00-flowchart/#coding-question-7-medium","title":"Coding Question #7 (Medium)","text":"<p>Create a flowchart for:</p> <p>\"Robot follows a line. If sensor sees black, go straight. If sensor sees white, turn right.\"</p> Click to see answer <pre><code>flowchart TD\n    A([Start]) --&gt; B{Match running?}\n    B --&gt;|No| C([End])\n    B --&gt;|Yes| D[Read line sensor]\n    D --&gt; E{Sees black?}\n    E --&gt;|Yes| F[Drive straight]\n    E --&gt;|No| G[Turn right]\n    F --&gt; H[Wait 20ms]\n    G --&gt; H\n    H --&gt; B\n\n    style E fill:#fff9c4,stroke:#f57f17\n    style F fill:#c8e6c9,stroke:#2e7d32\n    style G fill:#fff3e0,stroke:#ef6c00</code></pre>"},{"location":"03-python-basics/00-flowchart/#coding-question-8-hard","title":"Coding Question #8 (Hard)","text":"<p>Create a flowchart for:</p> <p>\"During autonomous, score 3 blocks. For each block: drive forward, push block into goal, back up. After 3 blocks, park.\"</p> Click to see answer <pre><code>flowchart TD\n    A([Start Autonomous]) --&gt; B[blocks_scored = 0]\n    B --&gt; C{blocks_scored &lt; 3?}\n    C --&gt;|No| D[Drive to park zone]\n    D --&gt; E[Stop motors]\n    E --&gt; F([End])\n    C --&gt;|Yes| G[Drive forward to block]\n    G --&gt; H[Push block into goal]\n    H --&gt; I[Back up]\n    I --&gt; J[blocks_scored = blocks_scored + 1]\n    J --&gt; C\n\n    style C fill:#fff9c4,stroke:#f57f17\n    style D fill:#bbdefb,stroke:#1565c0\n    style J fill:#e3f2fd,stroke:#1565c0</code></pre>  **The Python code:** <pre><code>def autonomous_routine():\n    blocks_scored = 0\n\n    while blocks_scored &lt; 3:\n        drivetrain.drive_for(FORWARD, 500, MM)   # Drive to block\n        drivetrain.drive_for(FORWARD, 300, MM)   # Push into goal\n        drivetrain.drive_for(REVERSE, 400, MM)   # Back up\n        blocks_scored = blocks_scored + 1\n\n    # After 3 blocks, park\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    drivetrain.drive_for(FORWARD, 400, MM)\n    drivetrain.stop()\n</code></pre>"},{"location":"03-python-basics/00-flowchart/#part-6-coding-challenges","title":"Part 6: Coding Challenges","text":"<p>Practice makes perfect! Try these challenges (answers at the end).</p>"},{"location":"03-python-basics/00-flowchart/#challenge-1-easy-morning-routine","title":"Challenge 1 (Easy): Morning Routine","text":"<p>Draw a flowchart for: \"Wake up. Check time. If late, skip breakfast and go straight to getting dressed. Otherwise, eat breakfast first, then get dressed. Finally, go to school.\"</p>"},{"location":"03-python-basics/00-flowchart/#challenge-2-easy-even-or-odd","title":"Challenge 2 (Easy): Even or Odd","text":"<p>Draw a flowchart and write Python code for: \"Input a number. If number % 2 equals 0, print 'Even'. Otherwise, print 'Odd'.\"</p>"},{"location":"03-python-basics/00-flowchart/#challenge-3-medium-grade-calculator","title":"Challenge 3 (Medium): Grade Calculator","text":"<p>Draw a flowchart for: \"Input a score. Print 'A' if 90+, 'B' if 80+, 'C' if 70+, 'D' if 60+, 'F' if below 60.\"</p>"},{"location":"03-python-basics/00-flowchart/#challenge-4-medium-password-with-3-attempts","title":"Challenge 4 (Medium): Password with 3 Attempts","text":"<p>Draw a flowchart for: \"Allow 3 password attempts. If correct, print 'Access granted'. If 3 fails, print 'Locked out'.\"</p>"},{"location":"03-python-basics/00-flowchart/#challenge-5-hard-vex-autonomous-timer","title":"Challenge 5 (Hard): VEX Autonomous Timer","text":"<p>Draw a flowchart for: \"Start a 15-second timer. Score blocks while time &gt; 3 seconds. When time &lt;= 3 seconds, drive to park zone.\"</p>"},{"location":"03-python-basics/00-flowchart/#challenge-6-hard-zone-control-calculator","title":"Challenge 6 (Hard): Zone Control Calculator","text":"<p>Draw a flowchart for: \"Count blocks in a goal (our_blocks and their_blocks). If our_blocks &gt; their_blocks, print 'We control!' and add 10 points. Otherwise, print 'No control'.\"</p>"},{"location":"03-python-basics/00-flowchart/#flowchart-to-code-translation","title":"Flowchart to Code Translation","text":"<p>Use this table when converting flowcharts to Python:</p> Flowchart Element Python Code <code>([Start])</code> First line of your function <code>([End])</code> Last line, or <code>return</code> <code>[Action]</code> Regular code line <code>{Question?}</code> with 2 paths <code>if condition:</code> and <code>else:</code> <code>{Question?}</code> with 3+ paths <code>if/elif/else</code> Arrow looping back <code>while condition:</code> Arrow looping forever <code>while True:</code>"},{"location":"03-python-basics/00-flowchart/#challenge-answers","title":"Challenge Answers","text":""},{"location":"03-python-basics/00-flowchart/#challenge-1-morning-routine","title":"Challenge 1: Morning Routine","text":"<pre><code>flowchart TD\n    A([Wake up]) --&gt; B{Am I late?}\n    B --&gt;|Yes| C[Skip breakfast]\n    B --&gt;|No| D[Eat breakfast]\n    C --&gt; E[Get dressed]\n    D --&gt; E\n    E --&gt; F([Go to school])\n\n    style B fill:#fff9c4,stroke:#f57f17</code></pre>"},{"location":"03-python-basics/00-flowchart/#challenge-2-even-or-odd","title":"Challenge 2: Even or Odd","text":"<pre><code>flowchart TD\n    A([Start]) --&gt; B[/Input number/]\n    B --&gt; C{number % 2 == 0?}\n    C --&gt;|Yes| D[\"Print 'Even'\"]\n    C --&gt;|No| E[\"Print 'Odd'\"]\n    D --&gt; F([End])\n    E --&gt; F\n\n    style C fill:#fff9c4,stroke:#f57f17</code></pre> <pre><code>number = int(input(\"Enter a number: \"))\nif number % 2 == 0:\n    print(\"Even\")\nelse:\n    print(\"Odd\")\n</code></pre>"},{"location":"03-python-basics/00-flowchart/#challenge-3-grade-calculator","title":"Challenge 3: Grade Calculator","text":"<pre><code>flowchart TD\n    A([Start]) --&gt; B[/Input score/]\n    B --&gt; C{score &gt;= 90?}\n    C --&gt;|Yes| D[\"Print 'A'\"]\n    C --&gt;|No| E{score &gt;= 80?}\n    E --&gt;|Yes| F[\"Print 'B'\"]\n    E --&gt;|No| G{score &gt;= 70?}\n    G --&gt;|Yes| H[\"Print 'C'\"]\n    G --&gt;|No| I{score &gt;= 60?}\n    I --&gt;|Yes| J[\"Print 'D'\"]\n    I --&gt;|No| K[\"Print 'F'\"]\n    D --&gt; L([End])\n    F --&gt; L\n    H --&gt; L\n    J --&gt; L\n    K --&gt; L\n\n    style C fill:#fff9c4,stroke:#f57f17\n    style E fill:#fff9c4,stroke:#f57f17\n    style G fill:#fff9c4,stroke:#f57f17\n    style I fill:#fff9c4,stroke:#f57f17</code></pre> <pre><code>score = int(input(\"Enter score: \"))\nif score &gt;= 90:\n    print(\"A\")\nelif score &gt;= 80:\n    print(\"B\")\nelif score &gt;= 70:\n    print(\"C\")\nelif score &gt;= 60:\n    print(\"D\")\nelse:\n    print(\"F\")\n</code></pre>"},{"location":"03-python-basics/00-flowchart/#challenge-4-password-with-3-attempts","title":"Challenge 4: Password with 3 Attempts","text":"<pre><code>flowchart TD\n    A([Start]) --&gt; B[attempts = 0]\n    B --&gt; C{attempts &lt; 3?}\n    C --&gt;|No| D[\"Print 'Locked out'\"]\n    D --&gt; E([End])\n    C --&gt;|Yes| F[/Ask for password/]\n    F --&gt; G{password == 'secret'?}\n    G --&gt;|Yes| H[\"Print 'Access granted'\"]\n    H --&gt; E\n    G --&gt;|No| I[attempts = attempts + 1]\n    I --&gt; C\n\n    style C fill:#fff9c4,stroke:#f57f17\n    style G fill:#fff9c4,stroke:#f57f17\n    style D fill:#ffcdd2,stroke:#c62828\n    style H fill:#c8e6c9,stroke:#2e7d32</code></pre> <pre><code>attempts = 0\nwhile attempts &lt; 3:\n    password = input(\"Enter password: \")\n    if password == \"secret\":\n        print(\"Access granted\")\n        break\n    attempts = attempts + 1\nelse:\n    print(\"Locked out\")\n</code></pre>"},{"location":"03-python-basics/00-flowchart/#challenge-5-vex-autonomous-timer","title":"Challenge 5: VEX Autonomous Timer","text":"<pre><code>flowchart TD\n    A([Start Autonomous]) --&gt; B[time_remaining = 15]\n    B --&gt; C{time_remaining &gt; 3?}\n    C --&gt;|Yes| D[Score a block]\n    D --&gt; E[time_remaining = time_remaining - 2.5]\n    E --&gt; C\n    C --&gt;|No| F[Drive to park zone]\n    F --&gt; G[Stop]\n    G --&gt; H([End])\n\n    style C fill:#fff9c4,stroke:#f57f17\n    style F fill:#bbdefb,stroke:#1565c0</code></pre>"},{"location":"03-python-basics/00-flowchart/#challenge-6-zone-control-calculator","title":"Challenge 6: Zone Control Calculator","text":"<pre><code>flowchart TD\n    A([Start]) --&gt; B[/Input our_blocks/]\n    B --&gt; C[/Input their_blocks/]\n    C --&gt; D{our_blocks &gt; their_blocks?}\n    D --&gt;|Yes| E[\"Print 'We control!'\"]\n    E --&gt; F[points = points + 10]\n    F --&gt; G([End])\n    D --&gt;|No| H[\"Print 'No control'\"]\n    H --&gt; G\n\n    style D fill:#fff9c4,stroke:#f57f17\n    style E fill:#c8e6c9,stroke:#2e7d32</code></pre> <pre><code>our_blocks = int(input(\"Our blocks: \"))\ntheir_blocks = int(input(\"Their blocks: \"))\npoints = 0\n\nif our_blocks &gt; their_blocks:\n    print(\"We control!\")\n    points = points + 10\nelse:\n    print(\"No control\")\n\nprint(\"Points:\", points)\n</code></pre>"},{"location":"03-python-basics/00-flowchart/#summary","title":"Summary","text":"Concept Flowchart Symbol Python Start/End Oval <code>([...])</code> First/last line Action Rectangle <code>[...]</code> Regular code Decision Diamond <code>{...}</code> <code>if/elif/else</code> Input/Output Parallelogram <code>[/.../]</code> <code>input()</code> / <code>print()</code> Loop Arrow back <code>while</code>"},{"location":"03-python-basics/00-flowchart/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Plan before coding - Draw a flowchart first!</li> <li>Break problems into steps - One rectangle per action</li> <li>Identify decisions - These become <code>if</code> statements</li> <li>Find repetition - These become <code>while</code> loops</li> <li>Practice both ways - Flowchart \u2192 Code AND Code \u2192 Flowchart</li> </ol>"},{"location":"03-python-basics/00-flowchart/#whats-next","title":"What's Next?","text":"<p>Now that you can think with flowcharts, you're ready to learn real Python code!</p> <p>In the next tutorial, you'll learn about variables - the building blocks that store information in your programs.</p> <p>\u2190 Previous: Sensors Overview | Next: Variables and Types \u2192</p>"},{"location":"03-python-basics/01-variables-and-types/","title":"Tutorial 3.1: Variables and Types","text":"<p>Time: ~15 minutes Prerequisites: Tutorial 3.0: Thinking with Flowcharts</p>"},{"location":"03-python-basics/01-variables-and-types/#what-is-a-variable","title":"What is a Variable?","text":"<p>A variable is like a labeled box that holds information. You give it a name and put something inside.</p> <pre><code>    Real World:                  In Code:\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             speed = 50\n    \u2502   SPEED     \u2502\n    \u2502     50      \u2502             \"speed\" is the label\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             50 is what's inside\n</code></pre> <p>Think of it like labeling containers in your kitchen:</p> <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 SUGAR \u2502  \u2502 FLOUR \u2502  \u2502 SALT  \u2502\n    \u2502  2kg  \u2502  \u2502  1kg  \u2502  \u2502 0.5kg \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    In Python:\n    sugar = 2\n    flour = 1\n    salt = 0.5\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#creating-variables","title":"Creating Variables","text":"<p>In Python, you create a variable by writing <code>name = value</code>:</p> <pre><code># Create a variable called 'speed' with value 50\nspeed = 50\n\n# Create a variable called 'robot_name' with value \"VEX Bot\"\nrobot_name = \"VEX Bot\"\n\n# Create a variable called 'is_running' with value True\nis_running = True\n</code></pre> <p>The <code>=</code> sign doesn't mean \"equals\" here - it means \"store this value in this box.\"</p>"},{"location":"03-python-basics/01-variables-and-types/#variable-assignment-flowchart","title":"Variable Assignment Flowchart","text":"<pre><code>flowchart LR\n    A[\"Value: 50\"] --&gt; B[\"= \\n(assignment)\"]\n    B --&gt; C[\"Variable Box\\n'speed'\"]\n\n    style A fill:#e8f5e9,stroke:#2e7d32\n    style B fill:#fff9c4,stroke:#f57f17\n    style C fill:#e3f2fd,stroke:#1565c0</code></pre> <p>This shows the flow: the value (50) is assigned (<code>=</code>) to the variable (speed).</p>"},{"location":"03-python-basics/01-variables-and-types/#types-of-data","title":"Types of Data","text":"<p>Python has different types of data that variables can hold:</p>"},{"location":"03-python-basics/01-variables-and-types/#numbers-integers-int","title":"Numbers: Integers (int)","text":"<p>Whole numbers without decimal points:</p> <pre><code>motor_port = 1          # Port number\nteam_number = 12345     # Your team\nscore = 42              # Points scored\nnegative = -100         # Negative numbers work too\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#numbers-decimals-float","title":"Numbers: Decimals (float)","text":"<p>Numbers with decimal points:</p> <pre><code>wheel_circumference = 319.19   # Wheel size in mm\npi = 3.14159                   # Mathematical pi\nhalf = 0.5                     # Half of something\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#text-strings-str","title":"Text: Strings (str)","text":"<p>Words and sentences - always in quotes:</p> <pre><code>robot_name = \"VEX Bot\"         # Double quotes work\nteam_name = 'Lightning'        # Single quotes work too\nmessage = \"Hello, World!\"      # Your first program tradition!\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#truefalse-booleans-bool","title":"True/False: Booleans (bool)","text":"<p>Only two possible values: <code>True</code> or <code>False</code></p> <pre><code>is_running = True      # Motor is running\nbutton_pressed = False # Button not pressed\nsensor_active = True   # Sensor is working\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#type-comparison-table","title":"Type Comparison Table","text":"Type Example What It's For <code>int</code> <code>42</code>, <code>-7</code>, <code>0</code> Counting, port numbers <code>float</code> <code>3.14</code>, <code>0.5</code>, <code>-2.7</code> Measurements, percentages <code>str</code> <code>\"Hello\"</code>, <code>'VEX'</code> Text, messages <code>bool</code> <code>True</code>, <code>False</code> Yes/no decisions"},{"location":"03-python-basics/01-variables-and-types/#data-type-decision-flowchart","title":"Data Type Decision Flowchart","text":"<p>How do you know what type a value is? Follow this decision tree:</p> <pre><code>flowchart TD\n    A[\"What kind of data?\"] --&gt; B{\"Is it in quotes?\"}\n    B --&gt;|Yes| C[\"str\\n'Hello', 'VEX'\"]\n    B --&gt;|No| D{\"Is it True or False?\"}\n    D --&gt;|Yes| E[\"bool\\nTrue, False\"]\n    D --&gt;|No| F{\"Does it have\\na decimal point?\"}\n    F --&gt;|Yes| G[\"float\\n3.14, 0.5\"]\n    F --&gt;|No| H[\"int\\n42, -7\"]\n\n    style C fill:#c8e6c9,stroke:#2e7d32\n    style E fill:#f8bbd9,stroke:#c2185b\n    style G fill:#fff3e0,stroke:#ef6c00\n    style H fill:#bbdefb,stroke:#1565c0</code></pre> <p>Quick Tips: - See quotes? It's a string - See <code>True</code> or <code>False</code>? It's a bool - See a decimal point? It's a float - Just a number? It's an int</p>"},{"location":"03-python-basics/01-variables-and-types/#code-connection-variables-in-robot_configpy","title":"Code Connection: Variables in robot_config.py","text":"<p>Look at <code>src/robot_config.py</code>:</p> <pre><code># These are all variables!\n\n# Integer variables (port numbers)\n# (hidden inside Motor constructor, but conceptually)\n\n# Float variables (measurements)\nWHEEL_TRAVEL_MM = 319.19      # float\nTRACK_WIDTH_MM = 295          # int (but could be float)\nWHEEL_BASE_MM = 200           # int\nEXTERNAL_GEAR_RATIO = 1       # int\n\n# The drivetrain uses these variables:\ndrivetrain = DriveTrain(\n    left_motors,\n    right_motors,\n    WHEEL_TRAVEL_MM,           # Using the variable here!\n    TRACK_WIDTH_MM,\n    WHEEL_BASE_MM,\n    MM,\n    EXTERNAL_GEAR_RATIO\n)\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#all_caps-variable-names","title":"ALL_CAPS Variable Names","text":"<p>Notice <code>WHEEL_TRAVEL_MM</code> is in ALL CAPS? This is a Python convention: - ALL_CAPS = constant (value shouldn't change) - lowercase = regular variable</p>"},{"location":"03-python-basics/01-variables-and-types/#changing-variable-values","title":"Changing Variable Values","text":"<p>Variables can change! That's why they're called \"variables\":</p> <pre><code>speed = 50          # Start at 50\nprint(speed)        # Output: 50\n\nspeed = 75          # Change to 75\nprint(speed)        # Output: 75\n\nspeed = speed + 10  # Add 10 to current value\nprint(speed)        # Output: 85\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#variable-update-flowchart","title":"Variable Update Flowchart","text":"<pre><code>flowchart LR\n    A[\"speed = 50\\n(initial)\"] --&gt; B[\"speed = 75\\n(reassign)\"]\n    B --&gt; C[\"speed = speed + 10\\n(calculate &amp; store)\"]\n    C --&gt; D[\"speed = 85\\n(final value)\"]\n\n    style A fill:#e3f2fd,stroke:#1565c0\n    style B fill:#fff9c4,stroke:#f57f17\n    style C fill:#fff3e0,stroke:#ef6c00\n    style D fill:#c8e6c9,stroke:#2e7d32</code></pre> <p>Each arrow shows the variable being updated - the old value is replaced by the new one.</p>"},{"location":"03-python-basics/01-variables-and-types/#basic-math-operations","title":"Basic Math Operations","text":"<p>Python can do math with numbers:</p> <pre><code>a = 10\nb = 3\n\nprint(a + b)    # Addition: 13\nprint(a - b)    # Subtraction: 7\nprint(a * b)    # Multiplication: 30\nprint(a / b)    # Division: 3.333...\nprint(a // b)   # Integer division: 3 (no decimal)\nprint(a % b)    # Remainder: 1 (10 \u00f7 3 = 3 remainder 1)\nprint(a ** b)   # Power: 1000 (10^3)\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#math-in-robot-code","title":"Math in Robot Code","text":"<pre><code># Calculate wheel circumference\ndiameter = 4  # inches\npi = 3.14159\ncircumference = diameter * pi  # 12.566...\n\n# Convert joystick percentage to motor velocity\njoystick_value = 75  # 75% forward\nmax_velocity = 200   # RPM\nmotor_velocity = (joystick_value / 100) * max_velocity  # 150 RPM\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#push-back-scoring-math","title":"Push Back Scoring Math","text":"<p>In the Push Back competition, you use math to calculate your score:</p> <pre><code>flowchart LR\n    subgraph \"Block Score Calculation\"\n        A[\"blocks_scored = 5\"] --&gt; B[\"points_per_block = 3\"]\n        B --&gt; C[\"total = 5 * 3\"]\n        C --&gt; D[\"total = 15 points\"]\n    end\n\n    style A fill:#e3f2fd,stroke:#1565c0\n    style D fill:#c8e6c9,stroke:#2e7d32</code></pre> <pre><code># Push Back scoring example\nblocks_scored = 5\npoints_per_block = 3\nblock_points = blocks_scored * points_per_block  # 15 points\n\n# Zone control bonus (if you have more blocks in a goal)\nlong_goal_bonus = 10\ncenter_goal_bonus = 6\n\n# Total score calculation\ntotal_score = block_points + long_goal_bonus\nprint(\"Total: \" + str(total_score) + \" points\")  # Total: 25 points\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#string-operations","title":"String Operations","text":"<p>You can combine strings:</p> <pre><code>first_name = \"VEX\"\nlast_name = \"Bot\"\n\n# Concatenation (joining strings)\nfull_name = first_name + \" \" + last_name\nprint(full_name)  # Output: \"VEX Bot\"\n\n# Repetition\ncheer = \"Go! \" * 3\nprint(cheer)  # Output: \"Go! Go! Go! \"\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#converting-types","title":"Converting Types","text":"<p>Sometimes you need to convert between types:</p> <pre><code>speed = 50                    # This is an int\nmessage = \"Speed: \" + str(speed)  # Convert to string\nprint(message)                # Output: \"Speed: 50\"\n\ntext_number = \"42\"            # This is a string\nactual_number = int(text_number)  # Convert to int\nprint(actual_number + 8)      # Output: 50\n</code></pre> <p>Common Conversions: | Function | Does What | Example | |----------|-----------|---------| | <code>str()</code> | \u2192 string | <code>str(42)</code> \u2192 <code>\"42\"</code> | | <code>int()</code> | \u2192 integer | <code>int(\"42\")</code> \u2192 <code>42</code> | | <code>float()</code> | \u2192 decimal | <code>float(\"3.14\")</code> \u2192 <code>3.14</code> |</p>"},{"location":"03-python-basics/01-variables-and-types/#code-connection-variables-in-utilspy","title":"Code Connection: Variables in utils.py","text":"<p>Look at <code>src/utils.py</code>:</p> <pre><code>def clamp(value, min_val, max_val):\n    \"\"\"\n    Clamp a value between minimum and maximum bounds.\n    \"\"\"\n    return max(min_val, min(value, max_val))\n</code></pre> <p>Here, <code>value</code>, <code>min_val</code>, and <code>max_val</code> are variables that get their values when the function is called:</p> <pre><code>result = clamp(150, 0, 100)  # value=150, min_val=0, max_val=100\n# result is 100 (clamped to maximum)\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#push-back-variables-in-action","title":"Push Back Variables in Action","text":"<p>Here's how variables are used throughout a Push Back match:</p> <pre><code># \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n# PUSH BACK GAME VARIABLES\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n# Match timing\nAUTONOMOUS_TIME = 15      # int - seconds for autonomous\nDRIVER_TIME = 105         # int - 1 minute 45 seconds\nTOTAL_MATCH_TIME = 120    # int - 2 minutes total\n\n# Scoring values\nPOINTS_PER_BLOCK = 3      # int - each block scored\nLONG_GOAL_BONUS = 10      # int - controlling long goal zone\nCENTER_UPPER_BONUS = 8    # int - center upper zone\nCENTER_LOWER_BONUS = 6    # int - center lower zone\nONE_ROBOT_PARK = 8        # int - one robot parked\nTWO_ROBOT_PARK = 30       # int - both robots parked\n\n# Game tracking (these change during the match)\nblocks_scored = 0         # int - starts at zero\nis_parked = False         # bool - not parked yet\nhas_zone_control = False  # bool - no control yet\nmatch_phase = \"auto\"      # str - current phase\n\n# Robot configuration (from robot_config.py)\nwheel_diameter_mm = 101.6   # float - 4 inches = 101.6mm\nwheel_circumference = 319.19  # float - distance per rotation\ntrack_width_mm = 295.0      # float - distance between wheels\n\n# Alliance information\nalliance_color = \"red\"      # str - \"red\" or \"blue\"\nstarting_position = \"left\"  # str - \"left\" or \"right\"\n\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n# CALCULATING FINAL SCORE\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n# During autonomous, you score blocks\nblocks_scored = 4\nblock_points = blocks_scored * POINTS_PER_BLOCK  # 12 points\n\n# Check zone control\nred_blocks_in_long_goal = 5\nblue_blocks_in_long_goal = 3\nhas_zone_control = red_blocks_in_long_goal &gt; blue_blocks_in_long_goal  # True\n\n# Add bonus if we control the zone\nif has_zone_control:\n    zone_bonus = LONG_GOAL_BONUS  # 10 points\nelse:\n    zone_bonus = 0\n\n# Parking bonus\nrobots_parked = 2\nif robots_parked == 2:\n    park_bonus = TWO_ROBOT_PARK  # 30 points\nelif robots_parked == 1:\n    park_bonus = ONE_ROBOT_PARK  # 8 points\nelse:\n    park_bonus = 0\n\n# Total score\ntotal_score = block_points + zone_bonus + park_bonus\nprint(\"Match Score: \" + str(total_score))  # Match Score: 52\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#common-mistakes-with-variables","title":"Common Mistakes with Variables","text":""},{"location":"03-python-basics/01-variables-and-types/#mistake-1-using-the-wrong-data-type","title":"Mistake 1: Using the Wrong Data Type","text":"<pre><code># WRONG: Trying to add a string and an integer\nmotor_port = \"1\"         # This is a string!\nnext_port = motor_port + 1   # ERROR: can't add str + int\n\n# RIGHT: Keep consistent types\nmotor_port = 1           # This is an integer\nnext_port = motor_port + 1   # Works: 2\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#mistake-2-forgetting-to-convert-for-print","title":"Mistake 2: Forgetting to Convert for Print","text":"<pre><code># WRONG: Can't concatenate string and int\nscore = 42\nprint(\"Score: \" + score)     # ERROR!\n\n# RIGHT: Convert to string first\nprint(\"Score: \" + str(score))  # Works: \"Score: 42\"\n\n# ALSO RIGHT: Use comma (prints with space)\nprint(\"Score:\", score)         # Works: \"Score: 42\"\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#mistake-3-using-instead-of-in-comparisons","title":"Mistake 3: Using = Instead of == in Comparisons","text":"<pre><code># WRONG: This is assignment, not comparison!\nif speed = 50:    # SyntaxError!\n    print(\"Half speed\")\n\n# RIGHT: Use == to compare\nif speed == 50:   # This checks if speed equals 50\n    print(\"Half speed\")\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#mistake-4-invalid-variable-names","title":"Mistake 4: Invalid Variable Names","text":"<pre><code># WRONG: These names are not allowed\nmy-speed = 50     # Hyphens look like subtraction\n2fast = 100       # Can't start with a number\nclass = \"A\"       # \"class\" is a reserved word\n\n# RIGHT: Valid variable names\nmy_speed = 50     # Underscores are OK\nfast_2 = 100      # Numbers OK after first character\nclass_name = \"A\"  # Add suffix to avoid reserved words\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#how-variables-connect-to-push-back","title":"How Variables Connect to Push Back","text":"<p>In the Push Back competition, variables track everything about your match:</p> What You Track Variable Type Example Blocks scored <code>int</code> <code>blocks = 8</code> Zone control status <code>bool</code> <code>has_control = True</code> Wheel circumference <code>float</code> <code>circumference = 319.19</code> Alliance color <code>str</code> <code>alliance = \"red\"</code> Match phase <code>str</code> <code>phase = \"driver\"</code> Parking status <code>bool</code> <code>is_parked = False</code> Score calculation <code>int</code> <code>score = blocks * 3</code>"},{"location":"03-python-basics/01-variables-and-types/#why-variables-matter-in-robot-code","title":"Why Variables Matter in Robot Code","text":"<ol> <li>Configuration: <code>WHEEL_TRAVEL_MM</code> stores your wheel size once, use it everywhere</li> <li>Calculations: Math with motor speeds, distances, and angles</li> <li>Decisions: Boolean variables track what's happening</li> <li>Display: String messages on the Brain screen</li> <li>Scoring: Track points throughout the match</li> </ol> <p>Every line of robot code uses variables - they're the foundation of programming!</p>"},{"location":"03-python-basics/01-variables-and-types/#summary","title":"Summary","text":"Concept What It Means Example Variable Named storage <code>speed = 50</code> int Whole number <code>42</code>, <code>-7</code> float Decimal number <code>3.14</code>, <code>0.5</code> str Text in quotes <code>\"Hello\"</code> bool True or False <code>True</code>, <code>False</code> Assignment Store value <code>x = 10</code> Operations Math and combining <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>"},{"location":"03-python-basics/01-variables-and-types/#exercise-create-robot-variables","title":"Exercise: Create Robot Variables","text":"<p>Goal: Create variables that describe your robot.</p> <pre><code># Fill in these variables with appropriate values:\n\n# What's your team number? (int)\nteam_number = _____\n\n# What's your robot's name? (str)\nrobot_name = \"_____\"\n\n# How many motors does your robot have? (int)\nmotor_count = _____\n\n# What's your wheel diameter in inches? (float)\nwheel_diameter = _____\n\n# Is your robot competition ready? (bool)\nis_ready = _____\n\n# BONUS: Calculate your wheel circumference\npi = 3.14159\nwheel_circumference = wheel_diameter * _____\n\nprint(\"Team \" + str(team_number) + \": \" + robot_name)\nprint(\"Wheel circumference: \" + str(wheel_circumference) + \" inches\")\n</code></pre>"},{"location":"03-python-basics/01-variables-and-types/#sample-answers","title":"Sample Answers","text":"<pre><code>team_number = 12345\nrobot_name = \"Push Bot\"\nmotor_count = 4\nwheel_diameter = 4.0\nis_ready = False\n\npi = 3.14159\nwheel_circumference = wheel_diameter * pi\n\nprint(\"Team \" + str(team_number) + \": \" + robot_name)\nprint(\"Wheel circumference: \" + str(wheel_circumference) + \" inches\")\n</code></pre> <p>Output: <pre><code>Team 12345: Push Bot\nWheel circumference: 12.56636 inches\n</code></pre></p> <p>\u2190 Previous: Thinking with Flowcharts | Next: Functions \u2192</p>"},{"location":"03-python-basics/02-functions/","title":"Tutorial 3.2: Functions","text":"<p>Time: ~15 minutes Prerequisites: Tutorial 3.1: Variables and Types</p>"},{"location":"03-python-basics/02-functions/#what-is-a-function","title":"What is a Function?","text":"<p>A function is like a recipe: a set of instructions with a name. You can use the recipe over and over without writing the instructions each time.</p> <pre><code>    Real World:                      In Python:\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     def make_sandwich():\n    \u2502   MAKE A SANDWICH       \u2502         get_bread()\n    \u2502                         \u2502         add_peanut_butter()\n    \u2502   1. Get bread          \u2502         add_jelly()\n    \u2502   2. Add peanut butter  \u2502         put_together()\n    \u2502   3. Add jelly          \u2502\n    \u2502   4. Put together       \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Instead of writing all 4 steps every time, you just say <code>make_sandwich()</code>.</p>"},{"location":"03-python-basics/02-functions/#creating-a-function","title":"Creating a Function","text":"<p>The basic pattern is:</p> <pre><code>def function_name():\n    # Code inside the function\n    # (indented with 4 spaces)\n    do_something()\n    do_something_else()\n</code></pre> <p>Example: <pre><code>def say_hello():\n    print(\"Hello, World!\")\n    print(\"I am a VEX robot!\")\n</code></pre></p>"},{"location":"03-python-basics/02-functions/#function-anatomy-flowchart","title":"Function Anatomy Flowchart","text":"<pre><code>flowchart TD\n    subgraph \"Function Definition\"\n        A[\"def\"] --&gt; B[\"function_name\"]\n        B --&gt; C[\"( )\"]\n        C --&gt; D[\":\"]\n    end\n    E[\"    indented code\"] --&gt; F[\"Part of the function\"]\n\n    style A fill:#e8f5e9,stroke:#2e7d32\n    style B fill:#bbdefb,stroke:#1565c0\n    style C fill:#fff9c4,stroke:#f57f17\n    style D fill:#f8bbd9,stroke:#c2185b</code></pre> Part Meaning <code>def</code> Keyword that starts a function definition <code>function_name</code> The name you give your function <code>( )</code> Parentheses hold parameters (inputs) <code>:</code> Colon marks the start of the function body indented code The instructions inside the function (4 spaces) <p>Using (calling) the function: <pre><code>say_hello()  # This runs both print statements\n</code></pre></p> <p>Output: <pre><code>Hello, World!\nI am a VEX robot!\n</code></pre></p>"},{"location":"03-python-basics/02-functions/#function-call-flowchart","title":"Function Call Flowchart","text":"<p>When you call a function, the computer \"jumps\" to run that function's code, then returns:</p> <pre><code>flowchart TD\n    A[\"Your code runs...\"] --&gt; B[\"say_hello()\"]\n    B --&gt; C[\"Jump to function definition\"]\n    C --&gt; D[\"Execute: print('Hello, World!')\"]\n    D --&gt; E[\"Execute: print('I am a VEX robot!')\"]\n    E --&gt; F[\"Return to calling code\"]\n    F --&gt; G[\"Continue with next line\"]\n\n    style B fill:#fff9c4,stroke:#f57f17\n    style C fill:#e3f2fd,stroke:#1565c0\n    style F fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"03-python-basics/02-functions/#parameters-giving-functions-information","title":"Parameters: Giving Functions Information","text":"<p>Parameters are like ingredients - information you give to the function:</p> <pre><code>    Real World:                      In Python:\n\n    MAKE SANDWICH with:              def make_sandwich(bread_type, filling):\n    - Bread type: white                  get_bread(bread_type)\n    - Filling: turkey                    add_filling(filling)\n</code></pre> <pre><code>def greet(name):\n    print(\"Hello, \" + name + \"!\")\n\ngreet(\"Alice\")   # Output: Hello, Alice!\ngreet(\"Bob\")     # Output: Hello, Bob!\n</code></pre>"},{"location":"03-python-basics/02-functions/#parameters-and-arguments-flowchart","title":"Parameters and Arguments Flowchart","text":"<pre><code>flowchart LR\n    subgraph \"Function Call\"\n        A[\"greet('Alice')\"] --&gt; B[\"'Alice' is the ARGUMENT\"]\n    end\n    subgraph \"Function Definition\"\n        C[\"def greet(name):\"] --&gt; D[\"name is the PARAMETER\"]\n    end\n    B --&gt; D\n    D --&gt; E[\"name = 'Alice' inside function\"]\n\n    style A fill:#fff9c4,stroke:#f57f17\n    style B fill:#e8f5e9,stroke:#2e7d32\n    style D fill:#bbdefb,stroke:#1565c0</code></pre> <p>Remember: - Parameter = the variable in the function definition (placeholder) - Argument = the actual value you pass when calling (the real data)</p>"},{"location":"03-python-basics/02-functions/#multiple-parameters","title":"Multiple Parameters","text":"<pre><code>def introduce(name, age, team):\n    print(\"I am \" + name)\n    print(\"I am \" + str(age) + \" years old\")\n    print(\"I am on team \" + str(team))\n\nintroduce(\"VEX Bot\", 1, 12345)\n</code></pre> <p>Output: <pre><code>I am VEX Bot\nI am 1 years old\nI am on team 12345\n</code></pre></p>"},{"location":"03-python-basics/02-functions/#return-values-getting-information-back","title":"Return Values: Getting Information Back","text":"<p>Functions can give you results back using <code>return</code>:</p> <pre><code>    Real World:                  In Python:\n\n    CALCULATOR:                  def add(a, b):\n    \"What's 5 + 3?\"                  result = a + b\n    \"The answer is 8\"                return result\n</code></pre>"},{"location":"03-python-basics/02-functions/#return-value-flowchart","title":"Return Value Flowchart","text":"<pre><code>flowchart LR\n    A[\"add(5, 3)\"] --&gt; B[\"a=5, b=3\"]\n    B --&gt; C[\"result = 5 + 3\"]\n    C --&gt; D[\"return 8\"]\n    D --&gt; E[\"sum = 8\"]\n\n    style A fill:#fff9c4,stroke:#f57f17\n    style D fill:#e8f5e9,stroke:#2e7d32\n    style E fill:#bbdefb,stroke:#1565c0</code></pre> <pre><code>def add(a, b):\n    result = a + b\n    return result\n\n# Use the returned value\nsum = add(5, 3)\nprint(sum)  # Output: 8\n</code></pre>"},{"location":"03-python-basics/02-functions/#why-return-matters","title":"Why Return Matters","text":"<pre><code># WITHOUT return - you can't use the result\ndef add_no_return(a, b):\n    result = a + b\n    print(result)  # Just prints, doesn't give back\n\nx = add_no_return(5, 3)  # x is None!\n\n# WITH return - you can use the result\ndef add_with_return(a, b):\n    result = a + b\n    return result\n\ny = add_with_return(5, 3)  # y is 8!\nprint(y * 2)  # You can use it! Output: 16\n</code></pre>"},{"location":"03-python-basics/02-functions/#code-connection-functions-in-utilspy","title":"Code Connection: Functions in utils.py","text":"<p>Let's examine a real function from <code>src/utils.py</code>:</p> <pre><code>def deadband(value, threshold=5.0):\n    \"\"\"\n    Apply deadband to joystick input to prevent drift.\n\n    Args:\n        value: The input value (typically -100 to 100)\n        threshold: Values below this are treated as zero\n\n    Returns:\n        0 if within deadband, otherwise the original value\n    \"\"\"\n    if abs(value) &lt; threshold:\n        return 0.0\n    return value\n</code></pre> <p>Let's break this down:</p> <pre><code>    def deadband(value, threshold=5.0):\n    \u2191      \u2191            \u2191\n    |      |            |\n    |      |            Default value (optional parameter)\n    |      Function name\n    Keyword to define a function\n\n    if abs(value) &lt; threshold:\n       \u2191\n       Built-in function: absolute value (makes negative positive)\n\n    return 0.0\n           \u2191\n           Give back zero if input is small\n\n    return value\n           \u2191\n           Otherwise, give back original\n</code></pre>"},{"location":"03-python-basics/02-functions/#deadband-function-flowchart","title":"deadband() Function Flowchart","text":"<pre><code>flowchart TD\n    A[\"deadband(value, threshold=5)\"] --&gt; B{\"Is |value| &lt; threshold?\"}\n    B --&gt;|\"Yes: Small input\\n(joystick drift)\"| C[\"return 0.0\\n(ignore it)\"]\n    B --&gt;|\"No: Real input\\n(driver moving)\"| D[\"return value\\n(use it)\"]\n\n    subgraph \"Push Back Examples\"\n        E[\"Joystick at 3%\"] --&gt; F[\"deadband(3) \u2192 0\"]\n        G[\"Joystick at 50%\"] --&gt; H[\"deadband(50) \u2192 50\"]\n    end\n\n    style C fill:#ffcdd2,stroke:#c62828\n    style D fill:#c8e6c9,stroke:#2e7d32\n    style F fill:#fff9c4,stroke:#f57f17\n    style H fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"03-python-basics/02-functions/#using-deadband","title":"Using deadband()","text":"<pre><code># Normal use\nresult1 = deadband(50)     # Returns 50 (above threshold)\nresult2 = deadband(3)      # Returns 0 (below 5 threshold)\nresult3 = deadband(-4)     # Returns 0 (abs(-4) = 4 &lt; 5)\n\n# With custom threshold\nresult4 = deadband(8, threshold=10)   # Returns 0 (below 10)\nresult5 = deadband(15, threshold=10)  # Returns 15 (above 10)\n</code></pre>"},{"location":"03-python-basics/02-functions/#default-parameters","title":"Default Parameters","text":"<p>Notice <code>threshold=5.0</code>? That's a default parameter:</p> <pre><code># If you don't specify threshold, it uses 5.0\ndeadband(50)              # Same as deadband(50, 5.0)\n\n# But you CAN specify a different value\ndeadband(50, 10)          # Uses 10 as threshold\ndeadband(50, threshold=10) # Same thing, more readable\n</code></pre>"},{"location":"03-python-basics/02-functions/#more-functions-from-utilspy","title":"More Functions from utils.py","text":""},{"location":"03-python-basics/02-functions/#clamp","title":"clamp()","text":"<pre><code>def clamp(value, min_val, max_val):\n    \"\"\"Clamp a value between minimum and maximum bounds.\"\"\"\n    return max(min_val, min(value, max_val))\n\n# Examples:\nclamp(150, 0, 100)   # Returns 100 (capped at max)\nclamp(-50, 0, 100)   # Returns 0 (raised to min)\nclamp(50, 0, 100)    # Returns 50 (already in range)\n</code></pre>"},{"location":"03-python-basics/02-functions/#curve_input","title":"curve_input()","text":"<pre><code>def curve_input(value, exponent=2.0):\n    \"\"\"Apply exponential curve for finer control at low speeds.\"\"\"\n    sign = 1 if value &gt;= 0 else -1\n    normalized = abs(value) / 100.0\n    curved = (normalized ** exponent) * 100.0\n    return sign * curved\n\n# Examples:\ncurve_input(50)      # Returns 25 (50% input \u2192 25% output)\ncurve_input(100)     # Returns 100 (max stays max)\ncurve_input(-50)     # Returns -25 (preserves direction)\n</code></pre> <p>Why is this useful? It gives more precise control at low speeds!</p>"},{"location":"03-python-basics/02-functions/#curve_input-flowchart","title":"curve_input() Flowchart","text":"<pre><code>flowchart TD\n    subgraph \"Why Curve Input for Push Back?\"\n        A[\"Precise block\\npositioning\"] --&gt; B[\"Low speed =\\nfine control\"]\n        C[\"Fast field\\ncrossing\"] --&gt; D[\"High speed =\\nfull power\"]\n    end\n\n    subgraph \"curve_input(50) calculation\"\n        E[\"50% joystick\"] --&gt; F[\"normalize: 0.5\"]\n        F --&gt; G[\"square: 0.25\"]\n        G --&gt; H[\"scale: 25% output\"]\n    end\n\n    style B fill:#c8e6c9,stroke:#2e7d32\n    style D fill:#fff3e0,stroke:#ef6c00\n    style H fill:#bbdefb,stroke:#1565c0</code></pre> <pre><code>    LINEAR (no curve):          CURVED (exponent=2):\n\n    Joystick  \u2192  Motor          Joystick  \u2192  Motor\n       0%     \u2192    0%              0%     \u2192    0%\n      25%     \u2192   25%             25%     \u2192    6.25%  \u2190 More precision!\n      50%     \u2192   50%             50%     \u2192   25%\n      75%     \u2192   75%             75%     \u2192   56.25%\n     100%     \u2192  100%            100%     \u2192  100%\n</code></pre> <p>Why this matters for Push Back: When you're carefully pushing blocks into a goal, you need precise, slow movements. curve_input() lets you make small adjustments without overshooting!</p>"},{"location":"03-python-basics/02-functions/#functions-calling-functions","title":"Functions Calling Functions","text":"<p>Functions can use other functions:</p> <pre><code>def process_joystick(raw_value):\n    \"\"\"Process raw joystick input with deadband and curve.\"\"\"\n    # First, apply deadband\n    after_deadband = deadband(raw_value)\n\n    # Then, apply curve\n    final_value = curve_input(after_deadband)\n\n    return final_value\n\n# Use it:\nspeed = process_joystick(25)  # Goes through both processing steps\n</code></pre>"},{"location":"03-python-basics/02-functions/#the-docstring","title":"The Docstring","text":"<p>The text in triple quotes <code>\"\"\"...\"\"\"</code> is called a docstring:</p> <pre><code>def deadband(value, threshold=5.0):\n    \"\"\"\n    Apply deadband to joystick input to prevent drift.\n\n    Args:\n        value: The input value (typically -100 to 100)\n        threshold: Values below this are treated as zero\n\n    Returns:\n        0 if within deadband, otherwise the original value\n    \"\"\"\n</code></pre> <p>It explains what the function does. Good practice!</p>"},{"location":"03-python-basics/02-functions/#summary","title":"Summary","text":"Concept What It Means Example Function Reusable set of instructions <code>def say_hello():</code> Parameter Input to a function <code>def greet(name):</code> Return Output from a function <code>return result</code> Default Optional parameter with preset value <code>threshold=5.0</code> Calling Using a function <code>say_hello()</code> Docstring Documentation in <code>\"\"\"...\"\"\"</code> Explains the function"},{"location":"03-python-basics/02-functions/#exercise-write-your-own-functions","title":"Exercise: Write Your Own Functions","text":"<p>Challenge 1: Write a function that calculates the area of a rectangle:</p> <pre><code>def rectangle_area(width, height):\n    # Your code here\n    pass\n\n# Test it:\nprint(rectangle_area(5, 3))  # Should print 15\n</code></pre> <p>Challenge 2: Write a function that converts motor percent to RPM:</p> <pre><code>def percent_to_rpm(percent, max_rpm=200):\n    # Your code here\n    # Hint: 100% = max_rpm, 50% = half of max_rpm\n    pass\n\n# Test it:\nprint(percent_to_rpm(100))      # Should print 200\nprint(percent_to_rpm(50))       # Should print 100\nprint(percent_to_rpm(75, 600))  # Should print 450 (using blue cartridge max)\n</code></pre> <p>Challenge 3: Look at <code>utils.py</code> and try to understand <code>scale_input()</code>. What does it do?</p> <p>Challenge 4 (Push Back): Write a function called <code>parking_bonus</code> that takes <code>num_robots</code> (0, 1, or 2) and returns the correct bonus points (0, 8, or 30).</p> <p>Challenge 5 (Push Back): Write a function called <code>check_awp_requirements</code> that checks if an alliance meets the Autonomous Win Point requirements: - 7+ blocks scored - Blocks in 3+ different goals - 3+ blocks removed from loaders</p>"},{"location":"03-python-basics/02-functions/#push-back-helper-functions","title":"Push Back Helper Functions","text":"<p>Here are specialized functions for the Push Back competition:</p> <pre><code># \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n# PUSH BACK SCORING FUNCTIONS\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\ndef calculate_block_score(blocks):\n    \"\"\"\n    Calculate points from blocks scored in Push Back.\n\n    Args:\n        blocks: Number of blocks pushed into goals\n\n    Returns:\n        Total block points (3 points per block)\n    \"\"\"\n    POINTS_PER_BLOCK = 3\n    return blocks * POINTS_PER_BLOCK\n\n\ndef check_zone_control(our_blocks, opponent_blocks):\n    \"\"\"\n    Determine if we control a goal zone in Push Back.\n\n    Args:\n        our_blocks: Number of our alliance's blocks in the zone\n        opponent_blocks: Number of opponent's blocks in the zone\n\n    Returns:\n        True if we have majority, False otherwise\n    \"\"\"\n    return our_blocks &gt; opponent_blocks\n\n\ndef get_zone_bonus(zone_type, have_control):\n    \"\"\"\n    Get bonus points for controlling a goal zone.\n\n    Args:\n        zone_type: \"long\", \"center_upper\", or \"center_lower\"\n        have_control: True if we have majority in the zone\n\n    Returns:\n        Bonus points for that zone (0 if no control)\n    \"\"\"\n    if not have_control:\n        return 0\n\n    if zone_type == \"long\":\n        return 10\n    elif zone_type == \"center_upper\":\n        return 8\n    elif zone_type == \"center_lower\":\n        return 6\n    else:\n        return 0\n\n\ndef parking_bonus(num_robots):\n    \"\"\"\n    Calculate parking bonus based on robots parked.\n\n    Args:\n        num_robots: Number of alliance robots parked (0, 1, or 2)\n\n    Returns:\n        Parking bonus points\n    \"\"\"\n    if num_robots == 2:\n        return 30\n    elif num_robots == 1:\n        return 8\n    else:\n        return 0\n\n\ndef calculate_total_score(blocks, zone_controls, robots_parked):\n    \"\"\"\n    Calculate complete alliance score for a Push Back match.\n\n    Args:\n        blocks: Total blocks scored\n        zone_controls: List of (zone_type, have_control) tuples\n        robots_parked: Number of robots in park zone (0, 1, or 2)\n\n    Returns:\n        Total match score\n    \"\"\"\n    # Block points\n    score = calculate_block_score(blocks)\n\n    # Zone control bonuses\n    for zone_type, have_control in zone_controls:\n        score = score + get_zone_bonus(zone_type, have_control)\n\n    # Parking bonus\n    score = score + parking_bonus(robots_parked)\n\n    return score\n\n\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n# USING THE FUNCTIONS\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n# Example match scenario\nblocks_scored = 8\nzone_controls = [\n    (\"long\", True),           # We control a long goal: +10\n    (\"center_upper\", False),  # Opponent controls center: +0\n]\nrobots_parked = 2             # Both robots parked: +30\n\n# Calculate final score\nfinal_score = calculate_total_score(blocks_scored, zone_controls, robots_parked)\nprint(\"Match Score: \" + str(final_score))  # 24 + 10 + 30 = 64 points\n</code></pre>"},{"location":"03-python-basics/02-functions/#common-mistakes-with-functions","title":"Common Mistakes with Functions","text":""},{"location":"03-python-basics/02-functions/#mistake-1-forgetting-parentheses-when-calling","title":"Mistake 1: Forgetting Parentheses When Calling","text":"<pre><code># WRONG: This doesn't call the function!\nresult = add    # Just refers to the function object, doesn't run it\n\n# RIGHT: Parentheses call the function\nresult = add(5, 3)  # Actually runs add() and returns 8\n</code></pre>"},{"location":"03-python-basics/02-functions/#mistake-2-forgetting-to-return","title":"Mistake 2: Forgetting to Return","text":"<pre><code># WRONG: Function doesn't return anything useful\ndef add(a, b):\n    result = a + b\n    # Forgot return! result is calculated but lost\n\nx = add(5, 3)    # x is None, not 8!\n\n# RIGHT: Return the result\ndef add(a, b):\n    result = a + b\n    return result  # Now the value comes back\n\ny = add(5, 3)    # y is 8\n</code></pre>"},{"location":"03-python-basics/02-functions/#mistake-3-wrong-indentation","title":"Mistake 3: Wrong Indentation","text":"<pre><code># WRONG: Code not indented inside function\ndef greet():\nprint(\"Hello\")    # ERROR: IndentationError!\n\n# RIGHT: Indent with 4 spaces\ndef greet():\n    print(\"Hello\")  # This is inside the function\n</code></pre>"},{"location":"03-python-basics/02-functions/#mistake-4-missing-colon","title":"Mistake 4: Missing Colon","text":"<pre><code># WRONG: Missing colon after function definition\ndef say_hello()   # SyntaxError!\n    print(\"Hello\")\n\n# RIGHT: Colon marks start of function body\ndef say_hello():\n    print(\"Hello\")\n</code></pre>"},{"location":"03-python-basics/02-functions/#mistake-5-modifying-parameters-doesnt-change-original","title":"Mistake 5: Modifying Parameters Doesn't Change Original","text":"<pre><code># This might surprise you:\ndef double(x):\n    x = x * 2    # This only changes x inside the function\n    return x\n\nmy_speed = 50\ndouble(my_speed)          # Returns 100, but...\nprint(my_speed)           # Still 50! Original wasn't changed\n\n# If you want to change the original:\nmy_speed = double(my_speed)  # Now my_speed is 100\n</code></pre>"},{"location":"03-python-basics/02-functions/#how-functions-connect-to-push-back","title":"How Functions Connect to Push Back","text":"<p>Functions organize your Push Back robot code into reusable pieces:</p> Function Purpose in Push Back <code>deadband()</code> Stops joystick drift when positioning blocks precisely <code>clamp()</code> Keeps motor speeds valid when using turbo mode <code>curve_input()</code> Gives precise control for careful block placement <code>autonomous_routine()</code> Runs your 15-second scoring sequence <code>driver_control_loop()</code> Controls robot during 1:45 driver period <code>calculate_block_score()</code> Tracks your alliance's points"},{"location":"03-python-basics/02-functions/#why-functions-matter","title":"Why Functions Matter","text":"<p>Without functions, you'd have to: 1. Copy the same code everywhere you need it 2. Fix bugs in multiple places 3. Make your code impossible to read</p> <p>With functions, you: 1. Write code once, use it everywhere 2. Fix bugs in one place 3. Give meaningful names to complex operations</p> <pre><code># Without functions: Confusing!\nleft_speed = controller.axis3.position()\nif abs(left_speed) &lt; 5:\n    left_speed = 0\n# ... repeated everywhere you need deadband\n\n# With functions: Clear!\nleft_speed = deadband(controller.axis3.position())\n# One line, easy to understand\n</code></pre>"},{"location":"03-python-basics/02-functions/#answers","title":"Answers","text":"<p>Challenge 1: <pre><code>def rectangle_area(width, height):\n    area = width * height\n    return area\n</code></pre></p> <p>Challenge 2: <pre><code>def percent_to_rpm(percent, max_rpm=200):\n    rpm = (percent / 100) * max_rpm\n    return rpm\n</code></pre></p> <p>Challenge 3: <code>scale_input()</code> converts a value from one range to another. Example: convert a 0-1023 sensor reading to 0-100% output.</p> <p>\u2190 Previous: Variables and Types | Next: Loops and Conditionals \u2192</p>"},{"location":"03-python-basics/03-loops-and-conditionals/","title":"Tutorial 3.3: Loops and Conditionals","text":"<p>Time: ~15 minutes Prerequisites: Tutorial 3.2: Functions</p>"},{"location":"03-python-basics/03-loops-and-conditionals/#what-are-conditionals","title":"What are Conditionals?","text":"<p>Conditionals let your code make decisions: \"If this is true, do this. Otherwise, do that.\"</p> <pre><code>    Real World:                      In Python:\n\n    \"If it's raining,                if is_raining:\n     take an umbrella.                   take_umbrella()\n     Otherwise, wear sunglasses.\"    else:\n                                         wear_sunglasses()\n</code></pre> <p>This is how your robot decides what to do based on conditions!</p>"},{"location":"03-python-basics/03-loops-and-conditionals/#the-if-statement","title":"The if Statement","text":"<pre><code>button_pressed = True\n\nif button_pressed:\n    print(\"Button is pressed!\")\n</code></pre> <p>The code inside the <code>if</code> block (indented) only runs if the condition is <code>True</code>.</p>"},{"location":"03-python-basics/03-loops-and-conditionals/#if-else","title":"if-else","text":"<pre><code>speed = 50\n\nif speed &gt; 75:\n    print(\"Going fast!\")\nelse:\n    print(\"Going slow or medium\")\n</code></pre>"},{"location":"03-python-basics/03-loops-and-conditionals/#if-elif-else","title":"if-elif-else","text":"<p>When you have multiple conditions:</p> <pre><code>speed = 50\n\nif speed &gt; 75:\n    print(\"Fast!\")\nelif speed &gt; 25:\n    print(\"Medium\")\nelse:\n    print(\"Slow\")\n</code></pre>"},{"location":"03-python-basics/03-loops-and-conditionals/#if-elif-else-flowchart","title":"if-elif-else Flowchart","text":"<pre><code>flowchart TD\n    A[\"speed = 50\"] --&gt; B{\"speed &gt; 75?\"}\n    B --&gt;|Yes| C[\"Print: 'Fast!'\"]\n    B --&gt;|No| D{\"speed &gt; 25?\"}\n    D --&gt;|Yes| E[\"Print: 'Medium'\"]\n    D --&gt;|No| F[\"Print: 'Slow'\"]\n\n    style E fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px\n    style C fill:#fff9c4,stroke:#f57f17\n    style F fill:#ffcdd2,stroke:#c62828</code></pre> <p>With <code>speed = 50</code>: 1. Is 50 &gt; 75? No \u2192 skip \"Fast!\" 2. Is 50 &gt; 25? Yes \u2192 print \"Medium\" \u2190 This runs!</p>"},{"location":"03-python-basics/03-loops-and-conditionals/#comparison-operators","title":"Comparison Operators","text":"<p>These are used to compare values:</p> Operator Meaning Example Result <code>==</code> Equal to <code>5 == 5</code> <code>True</code> <code>!=</code> Not equal <code>5 != 3</code> <code>True</code> <code>&gt;</code> Greater than <code>5 &gt; 3</code> <code>True</code> <code>&lt;</code> Less than <code>5 &lt; 3</code> <code>False</code> <code>&gt;=</code> Greater or equal <code>5 &gt;= 5</code> <code>True</code> <code>&lt;=</code> Less or equal <code>3 &lt;= 5</code> <code>True</code>"},{"location":"03-python-basics/03-loops-and-conditionals/#comparison-results-flowchart","title":"Comparison Results Flowchart","text":"<pre><code>flowchart LR\n    subgraph \"Comparison Results\"\n        A[\"5 == 5\"] --&gt; B[\"True\"]\n        C[\"5 != 3\"] --&gt; D[\"True\"]\n        E[\"5 &gt; 10\"] --&gt; F[\"False\"]\n        G[\"3 &lt;= 5\"] --&gt; H[\"True\"]\n    end\n\n    style B fill:#c8e6c9,stroke:#2e7d32\n    style D fill:#c8e6c9,stroke:#2e7d32\n    style F fill:#ffcdd2,stroke:#c62828\n    style H fill:#c8e6c9,stroke:#2e7d32</code></pre> <p>:warning: Common mistake: Using <code>=</code> instead of <code>==</code> - <code>=</code> assigns a value: <code>x = 5</code> - <code>==</code> compares values: <code>if x == 5:</code></p>"},{"location":"03-python-basics/03-loops-and-conditionals/#logical-operators","title":"Logical Operators","text":"<p>Combine multiple conditions:</p> Operator Meaning Example <code>and</code> Both must be true <code>if speed &gt; 0 and button_pressed:</code> <code>or</code> At least one true <code>if speed &gt; 75 or turbo_mode:</code> <code>not</code> Opposite <code>if not button_pressed:</code> <pre><code># Example: Robot safety check\nmotors_ready = True\nbattery_good = True\n\nif motors_ready and battery_good:\n    print(\"Robot is safe to run!\")\nelse:\n    print(\"Check motors or battery!\")\n</code></pre>"},{"location":"03-python-basics/03-loops-and-conditionals/#logical-operators-flowchart","title":"Logical Operators Flowchart","text":"<pre><code>flowchart TD\n    subgraph \"AND: Both must be True\"\n        A1[\"motors_ready = True\"] --&gt; C1{\"motors_ready\\nAND\\nbattery_good?\"}\n        B1[\"battery_good = True\"] --&gt; C1\n        C1 --&gt;|\"Both True\"| D1[\"Safe to run!\"]\n        C1 --&gt;|\"Either False\"| E1[\"Check robot!\"]\n    end\n\n    subgraph \"OR: At least one True\"\n        A2[\"speed &gt; 75: False\"] --&gt; C2{\"speed &gt; 75\\nOR\\nturbo_mode?\"}\n        B2[\"turbo_mode: True\"] --&gt; C2\n        C2 --&gt;|\"One is True\"| D2[\"Go fast!\"]\n    end\n\n    style D1 fill:#c8e6c9,stroke:#2e7d32\n    style D2 fill:#c8e6c9,stroke:#2e7d32\n    style E1 fill:#ffcdd2,stroke:#c62828</code></pre>"},{"location":"03-python-basics/03-loops-and-conditionals/#what-are-loops","title":"What are Loops?","text":"<p>Loops repeat code over and over. Essential for robot control!</p>"},{"location":"03-python-basics/03-loops-and-conditionals/#while-loop","title":"while Loop","text":"<p>Repeats while a condition is true:</p> <pre><code>count = 0\n\nwhile count &lt; 5:\n    print(count)\n    count = count + 1\n\n# Output: 0, 1, 2, 3, 4\n</code></pre>"},{"location":"03-python-basics/03-loops-and-conditionals/#while-loop-flowchart","title":"while Loop Flowchart","text":"<pre><code>flowchart TD\n    A[\"count = 0\"] --&gt; B{\"count &lt; 5?\"}\n    B --&gt;|Yes| C[\"print(count)\"]\n    C --&gt; D[\"count = count + 1\"]\n    D --&gt; B\n    B --&gt;|No| E[\"Loop ends!\"]\n\n    style B fill:#fff9c4,stroke:#f57f17\n    style E fill:#c8e6c9,stroke:#2e7d32</code></pre> <p>The loop keeps going back to check the condition until it's False.</p>"},{"location":"03-python-basics/03-loops-and-conditionals/#while-true-forever-loop","title":"while True (Forever Loop)","text":"<p>The most common loop in robot code:</p> <pre><code>while True:\n    # This runs forever!\n    read_sensors()\n    control_motors()\n    wait(20, MSEC)\n</code></pre> <p>This is how <code>driver_control_loop()</code> works - it runs continuously!</p>"},{"location":"03-python-basics/03-loops-and-conditionals/#code-connection-driver_controlpy","title":"Code Connection: driver_control.py","text":"<p>Let's examine the real driver control loop:</p> <pre><code>def driver_control_loop():\n    brain.screen.print(\"Driver Control Active\")\n\n    while True:\n        # Get joystick positions (-100 to 100)\n        left_speed = controller.axis3.position()\n        right_speed = controller.axis2.position()\n\n        # Apply deadband to prevent motor drift\n        left_speed = deadband(left_speed, threshold=5)\n        right_speed = deadband(right_speed, threshold=5)\n\n        # Set motor velocities and spin\n        left_motors.set_velocity(left_speed, PERCENT)\n        right_motors.set_velocity(right_speed, PERCENT)\n\n        left_motors.spin(FORWARD)\n        right_motors.spin(FORWARD)\n\n        # Small delay to prevent CPU overload\n        wait(20, MSEC)\n</code></pre>"},{"location":"03-python-basics/03-loops-and-conditionals/#driver-control-loop-flowchart","title":"Driver Control Loop Flowchart","text":"<pre><code>flowchart TD\n    A[\"while True:\"] --&gt; B[\"Read joysticks\\n(axis3, axis2)\"]\n    B --&gt; C[\"Apply deadband\\n(remove drift)\"]\n    C --&gt; D[\"Set motor velocities\"]\n    D --&gt; E[\"Spin motors\"]\n    E --&gt; F[\"wait(20, MSEC)\"]\n    F --&gt; B\n\n    subgraph \"Push Back Context\"\n        G[\"Controls pushing\\nblocks into goals\"]\n    end\n\n    style A fill:#fff9c4,stroke:#f57f17\n    style F fill:#e3f2fd,stroke:#1565c0</code></pre> <p>Why this loop runs forever: During driver control, you need to constantly read the joysticks and update motors. This runs 50 times per second (every 20 milliseconds) for smooth control!</p> <p>Why wait(20, MSEC)? - Without it, the loop runs millions of times per second - Uses too much CPU power - 20ms = 50 updates per second (smooth control)</p>"},{"location":"03-python-basics/03-loops-and-conditionals/#for-loops","title":"for Loops","text":"<p>When you know exactly how many times to repeat:</p> <pre><code># Print numbers 0 to 4\nfor i in range(5):\n    print(i)\n# Output: 0, 1, 2, 3, 4\n\n# Print \"Go!\" three times\nfor i in range(3):\n    print(\"Go!\")\n# Output: Go! Go! Go!\n</code></pre>"},{"location":"03-python-basics/03-loops-and-conditionals/#range-function","title":"range() Function","text":"Code Produces <code>range(5)</code> 0, 1, 2, 3, 4 <code>range(1, 6)</code> 1, 2, 3, 4, 5 <code>range(0, 10, 2)</code> 0, 2, 4, 6, 8"},{"location":"03-python-basics/03-loops-and-conditionals/#for-loop-flowchart","title":"for Loop Flowchart","text":"<pre><code>flowchart LR\n    subgraph \"range(5) produces these values:\"\n        A[\"i = 0\"] --&gt; B[\"i = 1\"]\n        B --&gt; C[\"i = 2\"]\n        C --&gt; D[\"i = 3\"]\n        D --&gt; E[\"i = 4\"]\n        E --&gt; F[\"Stop\"]\n    end\n\n    style A fill:#e3f2fd,stroke:#1565c0\n    style F fill:#c8e6c9,stroke:#2e7d32</code></pre> <p>Note: <code>range(5)</code> gives you 5 values: 0, 1, 2, 3, 4. It stops before 5!</p>"},{"location":"03-python-basics/03-loops-and-conditionals/#combining-loops-and-conditionals","title":"Combining Loops and Conditionals","text":"<p>Real robot code uses both together:</p> <pre><code>def driver_control_with_button():\n    while True:\n        # Normal driving\n        left_speed = controller.axis3.position()\n        right_speed = controller.axis2.position()\n\n        # Check for turbo button\n        if controller.buttonR1.pressing():\n            # Double the speed!\n            left_speed = left_speed * 2\n            right_speed = right_speed * 2\n\n        # Limit to valid range\n        left_speed = clamp(left_speed, -100, 100)\n        right_speed = clamp(right_speed, -100, 100)\n\n        left_motors.spin(FORWARD, left_speed, PERCENT)\n        right_motors.spin(FORWARD, right_speed, PERCENT)\n\n        wait(20, MSEC)\n</code></pre>"},{"location":"03-python-basics/03-loops-and-conditionals/#push-back-button-mode-flowchart","title":"Push Back Button Mode Flowchart","text":"<p>This flowchart shows how conditionals inside a loop control robot behavior:</p> <pre><code>flowchart TD\n    A[\"Get joystick input\"] --&gt; B{\"Button X\\npressed?\"}\n    B --&gt;|Yes| C[\"Reverse mode\\nspeed \u00d7 -1\"]\n    B --&gt;|No| D{\"Button R1\\npressed?\"}\n    D --&gt;|Yes| E[\"Turbo mode\\nspeed \u00d7 1.5\"]\n    D --&gt;|No| F{\"Button L1\\npressed?\"}\n    F --&gt;|Yes| G[\"Precision mode\\nspeed \u00d7 0.5\"]\n    F --&gt;|No| H[\"Normal mode\"]\n\n    C --&gt; I[\"clamp(-100, 100)\"]\n    E --&gt; I\n    G --&gt; I\n    H --&gt; I\n    I --&gt; J[\"Spin motors\"]\n\n    style C fill:#ffcdd2,stroke:#c62828\n    style E fill:#fff3e0,stroke:#ef6c00\n    style G fill:#e3f2fd,stroke:#1565c0\n    style H fill:#c8e6c9,stroke:#2e7d32</code></pre> <p>This gives the driver multiple control modes during Push Back matches!</p>"},{"location":"03-python-basics/03-loops-and-conditionals/#breaking-out-of-loops","title":"Breaking Out of Loops","text":"<p>Use <code>break</code> to exit a loop early:</p> <pre><code>while True:\n    if controller.buttonA.pressing():\n        print(\"Button A pressed - stopping!\")\n        break  # Exit the loop!\n\n    # Normal operation\n    drive_robot()\n</code></pre> <p>Use <code>continue</code> to skip to the next iteration:</p> <pre><code>while True:\n    if not is_safe():\n        continue  # Skip this iteration, don't drive\n\n    drive_robot()  # Only runs if is_safe() is True\n</code></pre>"},{"location":"03-python-basics/03-loops-and-conditionals/#break-vs-continue-flowchart","title":"break vs continue Flowchart","text":"<pre><code>flowchart TD\n    subgraph \"break: Exit loop completely\"\n        A1[\"while True:\"] --&gt; B1{\"Button A?\"}\n        B1 --&gt;|No| C1[\"drive_robot()\"]\n        C1 --&gt; A1\n        B1 --&gt;|Yes| D1[\"break\"]\n        D1 --&gt; E1[\"Exit loop\\nCode after loop runs\"]\n    end\n\n    subgraph \"continue: Skip to next iteration\"\n        A2[\"while True:\"] --&gt; B2{\"is_safe()?\"}\n        B2 --&gt;|No| C2[\"continue\"]\n        C2 --&gt; A2\n        B2 --&gt;|Yes| D2[\"drive_robot()\"]\n        D2 --&gt; A2\n    end\n\n    style D1 fill:#ffcdd2,stroke:#c62828\n    style E1 fill:#c8e6c9,stroke:#2e7d32\n    style C2 fill:#fff9c4,stroke:#f57f17</code></pre> <p>Key difference: - <code>break</code> = STOP the entire loop - <code>continue</code> = SKIP this round, go to next</p>"},{"location":"03-python-basics/03-loops-and-conditionals/#push-back-control-logic","title":"Push Back Control Logic","text":"<p>Here's a complete driver control with Push Back-specific features:</p> <pre><code># \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n# PUSH BACK DRIVER CONTROL WITH MODES\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\ndef push_back_driver_control():\n    \"\"\"Enhanced driver control for Push Back competition.\"\"\"\n    brain.screen.print(\"Push Back Mode Active\")\n\n    scoring_mode = False  # Toggle for precision block placement\n\n    while True:\n        # Get base joystick input\n        left_speed = controller.axis3.position()\n        right_speed = controller.axis2.position()\n\n        # Apply deadband to remove joystick drift\n        left_speed = deadband(left_speed, threshold=5)\n        right_speed = deadband(right_speed, threshold=5)\n\n        # Toggle scoring mode with Button A\n        if controller.buttonA.pressing():\n            scoring_mode = not scoring_mode\n            brain.screen.print(\"Scoring: \" + str(scoring_mode))\n            wait(200, MSEC)  # Debounce button\n\n        # Apply speed modifiers based on mode\n        if scoring_mode:\n            # Slow, precise control for pushing blocks into goals\n            left_speed = left_speed * 0.3\n            right_speed = right_speed * 0.3\n        elif controller.buttonR1.pressing():\n            # Turbo for crossing field quickly\n            left_speed = left_speed * 1.5\n            right_speed = right_speed * 1.5\n        elif controller.buttonL1.pressing():\n            # Half speed for careful maneuvering\n            left_speed = left_speed * 0.5\n            right_speed = right_speed * 0.5\n\n        # Reverse controls with Button X\n        if controller.buttonX.pressing():\n            left_speed = left_speed * -1\n            right_speed = right_speed * -1\n\n        # Always clamp to valid motor range\n        left_speed = clamp(left_speed, -100, 100)\n        right_speed = clamp(right_speed, -100, 100)\n\n        # Drive the motors\n        left_motors.spin(FORWARD, left_speed, PERCENT)\n        right_motors.spin(FORWARD, right_speed, PERCENT)\n\n        wait(20, MSEC)\n\n\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n# PUSH BACK AUTONOMOUS WITH DECISIONS\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\ndef push_back_autonomous():\n    \"\"\"15-second autonomous routine with strategic decisions.\"\"\"\n    setup_autonomous()\n\n    # Track our progress\n    blocks_pushed = 0\n    time_remaining = 15\n\n    # Push blocks while we have time\n    while time_remaining &gt; 3:  # Keep 3 seconds for parking\n        # Push toward goal\n        drivetrain.drive_for(FORWARD, 500, MM)\n        blocks_pushed = blocks_pushed + 1\n\n        # Back up for next push\n        drivetrain.drive_for(REVERSE, 200, MM)\n\n        # Update time estimate (simplified)\n        time_remaining = time_remaining - 2.5\n\n        brain.screen.print(\"Blocks: \" + str(blocks_pushed))\n\n    # Use remaining time to park\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    drivetrain.drive_for(FORWARD, 400, MM)\n    brain.screen.print(\"PARKED!\")\n\n\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n# AWP CHECKER - Check Autonomous Win Point requirements\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\ndef check_awp_progress(blocks, goals_used, loader_blocks):\n    \"\"\"\n    Check progress toward Autonomous Win Point.\n\n    Requirements:\n    - 7+ blocks scored\n    - Blocks in 3+ different goals\n    - 3+ blocks removed from loaders\n    \"\"\"\n    requirements_met = 0\n\n    # Check block count\n    if blocks &gt;= 7:\n        print(\"Blocks: MET (7+)\")\n        requirements_met = requirements_met + 1\n    else:\n        print(\"Blocks: NEED \" + str(7 - blocks) + \" more\")\n\n    # Check goal diversity\n    if goals_used &gt;= 3:\n        print(\"Goals: MET (3+)\")\n        requirements_met = requirements_met + 1\n    else:\n        print(\"Goals: NEED \" + str(3 - goals_used) + \" more\")\n\n    # Check loader blocks\n    if loader_blocks &gt;= 3:\n        print(\"Loader: MET (3+)\")\n        requirements_met = requirements_met + 1\n    else:\n        print(\"Loader: NEED \" + str(3 - loader_blocks) + \" more\")\n\n    # Final verdict\n    if requirements_met == 3:\n        print(\"AWP REQUIREMENTS MET!\")\n        return True\n    else:\n        print(\"AWP: \" + str(requirements_met) + \"/3 requirements\")\n        return False\n</code></pre>"},{"location":"03-python-basics/03-loops-and-conditionals/#common-mistakes-with-loops-and-conditionals","title":"Common Mistakes with Loops and Conditionals","text":""},{"location":"03-python-basics/03-loops-and-conditionals/#mistake-1-infinite-loop-forgetting-to-update","title":"Mistake 1: Infinite Loop (Forgetting to Update)","text":"<pre><code># WRONG: count never changes, runs forever!\ncount = 0\nwhile count &lt; 5:\n    print(count)\n    # Forgot: count = count + 1\n\n# RIGHT: Update the variable\ncount = 0\nwhile count &lt; 5:\n    print(count)\n    count = count + 1  # This makes the loop eventually stop\n</code></pre>"},{"location":"03-python-basics/03-loops-and-conditionals/#mistake-2-using-instead-of","title":"Mistake 2: Using = Instead of ==","text":"<pre><code># WRONG: = is assignment, not comparison\nif speed = 50:     # SyntaxError!\n    print(\"Half speed\")\n\n# RIGHT: == compares values\nif speed == 50:    # This checks if speed equals 50\n    print(\"Half speed\")\n</code></pre>"},{"location":"03-python-basics/03-loops-and-conditionals/#mistake-3-forgetting-the-colon","title":"Mistake 3: Forgetting the Colon","text":"<pre><code># WRONG: Missing colon after condition\nif x &gt; 5          # SyntaxError!\n    print(\"Big\")\n\nwhile count &lt; 10  # SyntaxError!\n    print(count)\n\n# RIGHT: Colon marks start of the block\nif x &gt; 5:\n    print(\"Big\")\n\nwhile count &lt; 10:\n    print(count)\n</code></pre>"},{"location":"03-python-basics/03-loops-and-conditionals/#mistake-4-wrong-indentation","title":"Mistake 4: Wrong Indentation","text":"<pre><code># WRONG: Code outside the if block\nif button_pressed:\nprint(\"Pressed\")   # ERROR: not indented\n\n# RIGHT: Indented code is inside the block\nif button_pressed:\n    print(\"Pressed\")  # This is part of the if\n</code></pre>"},{"location":"03-python-basics/03-loops-and-conditionals/#mistake-5-off-by-one-with-range","title":"Mistake 5: Off-by-One with range()","text":"<pre><code># If you want to print 1 through 5:\n\n# WRONG: This prints 0, 1, 2, 3, 4\nfor i in range(5):\n    print(i)\n\n# RIGHT: Start at 1, stop at 6\nfor i in range(1, 6):\n    print(i)  # Prints 1, 2, 3, 4, 5\n</code></pre>"},{"location":"03-python-basics/03-loops-and-conditionals/#how-loops-and-conditionals-connect-to-push-back","title":"How Loops and Conditionals Connect to Push Back","text":""},{"location":"03-python-basics/03-loops-and-conditionals/#conditionals-in-push-back","title":"Conditionals in Push Back","text":"Condition Action <code>if turbo_button:</code> Increase speed to cross field fast <code>if scoring_mode:</code> Reduce speed for precise block placement <code>if blocks &gt;= 7:</code> AWP block requirement met <code>if time_remaining &lt; 5:</code> Switch to parking strategy <code>if is_autonomous:</code> Run pre-programmed routine"},{"location":"03-python-basics/03-loops-and-conditionals/#loops-in-push-back","title":"Loops in Push Back","text":"Loop Purpose <code>while True:</code> Driver control - constantly reads joysticks <code>for i in range(5):</code> Score 5 blocks in sequence <code>while time &gt; 0:</code> Autonomous - keep working until time's up"},{"location":"03-python-basics/03-loops-and-conditionals/#the-big-picture","title":"The Big Picture","text":"<p>Your entire robot program during a match looks like this:</p> <pre><code>flowchart TD\n    A[\"Match Start\"] --&gt; B{\"Autonomous\\nperiod?\"}\n    B --&gt;|Yes| C[\"autonomous_routine()\\n15 seconds\"]\n    B --&gt;|No| D{\"Driver control\\nperiod?\"}\n    C --&gt; D\n    D --&gt;|Yes| E[\"while True:\\n  read_controller()\\n  drive_motors()\\n  wait(20ms)\"]\n    D --&gt;|No| F[\"Match Over\"]\n    E --&gt;|\"1:45 later\"| F\n\n    style C fill:#fff3e0,stroke:#ef6c00\n    style E fill:#c8e6c9,stroke:#2e7d32</code></pre> <p>Every robot program is loops and conditionals!</p>"},{"location":"03-python-basics/03-loops-and-conditionals/#summary","title":"Summary","text":"Concept What It Does Example <code>if</code> Run code if condition true <code>if x &gt; 5:</code> <code>else</code> Run if condition false <code>else:</code> <code>elif</code> Additional conditions <code>elif x &gt; 3:</code> <code>while</code> Repeat while true <code>while running:</code> <code>while True</code> Repeat forever <code>while True:</code> <code>for</code> Repeat specific times <code>for i in range(5):</code> <code>break</code> Exit loop early <code>break</code> <code>continue</code> Skip to next iteration <code>continue</code>"},{"location":"03-python-basics/03-loops-and-conditionals/#exercise-add-button-detection","title":"Exercise: Add Button Detection","text":"<p>Goal: Modify driver control to reverse when button X is pressed.</p> <pre><code>def driver_control_with_reverse():\n    while True:\n        left_speed = controller.axis3.position()\n        right_speed = controller.axis2.position()\n\n        # YOUR CODE HERE:\n        # If buttonX is pressing, multiply speeds by -1\n        # Hint: if controller.buttonX.pressing():\n\n        left_motors.spin(FORWARD, left_speed, PERCENT)\n        right_motors.spin(FORWARD, right_speed, PERCENT)\n\n        wait(20, MSEC)\n</code></pre> <p>Bonus: Add multiple buttons: - Button X = reverse (multiply by -1) - Button R1 = turbo (multiply by 1.5, then clamp) - Button L1 = slow mode (multiply by 0.5)</p>"},{"location":"03-python-basics/03-loops-and-conditionals/#answer","title":"Answer","text":"<pre><code>def driver_control_with_reverse():\n    while True:\n        left_speed = controller.axis3.position()\n        right_speed = controller.axis2.position()\n\n        # Reverse when X is pressed\n        if controller.buttonX.pressing():\n            left_speed = left_speed * -1\n            right_speed = right_speed * -1\n\n        left_motors.spin(FORWARD, left_speed, PERCENT)\n        right_motors.spin(FORWARD, right_speed, PERCENT)\n\n        wait(20, MSEC)\n</code></pre> <p>Bonus Answer: <pre><code>def driver_control_with_modes():\n    while True:\n        left_speed = controller.axis3.position()\n        right_speed = controller.axis2.position()\n\n        # Reverse mode\n        if controller.buttonX.pressing():\n            left_speed = left_speed * -1\n            right_speed = right_speed * -1\n\n        # Turbo mode\n        if controller.buttonR1.pressing():\n            left_speed = left_speed * 1.5\n            right_speed = right_speed * 1.5\n\n        # Slow mode\n        if controller.buttonL1.pressing():\n            left_speed = left_speed * 0.5\n            right_speed = right_speed * 0.5\n\n        # Always clamp to valid range\n        left_speed = clamp(left_speed, -100, 100)\n        right_speed = clamp(right_speed, -100, 100)\n\n        left_motors.spin(FORWARD, left_speed, PERCENT)\n        right_motors.spin(FORWARD, right_speed, PERCENT)\n\n        wait(20, MSEC)\n</code></pre></p> <p>\u2190 Previous: Functions | Next: Drive Control \u2192 | Review Q&amp;A</p>"},{"location":"03-python-basics/04-review-qa/","title":"Python Basics Q&amp;A: Self-Assessment Guide","text":"<p>Purpose: Test your understanding of Python basics for VEX V5 robotics Total Questions: 45 (15 per topic) Estimated Time: 30-45 minutes Prerequisites: Complete Tutorials 3.1, 3.2, and 3.3</p>"},{"location":"03-python-basics/04-review-qa/#how-to-use-this-guide","title":"How to Use This Guide","text":"<ol> <li>Try First: Answer each question before looking at the answer</li> <li>Write It Down: Writing helps you remember better</li> <li>Check Yourself: Compare to the Answer Key at the end</li> <li>Review: Go back to the tutorial for any topics you struggled with</li> <li>Practice: Try the code examples in VEXcode or Python</li> </ol>"},{"location":"03-python-basics/04-review-qa/#scoring-guide","title":"Scoring Guide","text":"Score What It Means 40-45 correct Excellent! Ready for advanced topics 30-39 correct Good understanding, review missed topics 20-29 correct Needs more practice, re-read tutorials Below 20 Start over with Tutorial 3.1"},{"location":"03-python-basics/04-review-qa/#section-1-variables-and-types","title":"Section 1: Variables and Types","text":""},{"location":"03-python-basics/04-review-qa/#conceptual-questions-q1-q5","title":"Conceptual Questions (Q1-Q5)","text":"<p>Q1: What is a variable in Python? Explain using a real-world analogy.</p> <p>Q2: In Python, what's the difference between <code>=</code> (single equals) and <code>==</code> (double equals)?</p> <p>Q3: Why do we use ALL_CAPS names for some variables like <code>WHEEL_TRAVEL_MM</code> in robot_config.py?</p> <p>Q4: Name the four basic data types in Python and give one example of each that you might use in a Push Back robot.</p> <p>Q5: What happens when you run <code>speed = speed + 10</code> if <code>speed</code> was originally 50? Walk through step by step.</p>"},{"location":"03-python-basics/04-review-qa/#code-reading-questions-q6-q10","title":"Code Reading Questions (Q6-Q10)","text":"<p>Q6: What is the final value of <code>x</code> after these lines run? <pre><code>x = 10\nx = x * 2\nx = x - 5\n</code></pre></p> <p>Q7: What data type is each of these variables? <pre><code>a = 42\nb = 3.14\nc = \"VEX\"\nd = True\ne = \"100\"\n</code></pre></p> <p>Q8: What does this code output? <pre><code>blocks = 5\npoints_per_block = 3\ntotal = blocks * points_per_block\nprint(\"Score: \" + str(total))\n</code></pre></p> <p>Q9: This code has an error. What is it, and how would you fix it? <pre><code>motor_port = \"1\"\nactual_port = motor_port + 1\n</code></pre></p> <p>Q10: What is wrong with this variable name? How would you fix it? <pre><code>my-robot-speed = 50\n</code></pre></p>"},{"location":"03-python-basics/04-review-qa/#push-back-application-questions-q11-q15","title":"Push Back Application Questions (Q11-Q15)","text":"<p>Q11: Write Python code to calculate your alliance's block score if you scored 8 blocks at 3 points each. Print the result.</p> <p>Q12: Create variables to store the following information about your Push Back robot: - Your team number (a whole number) - Your robot's name (text) - Whether your robot is parked in the zone (yes/no) - Your wheel diameter in inches (a decimal number)</p> <p>Q13: The Push Back field is 12 feet by 12 feet. Write Python code to: 1. Store the field size in feet 2. Convert it to millimeters (1 foot = 304.8 mm) 3. Print both values</p> <p>Q14: In Push Back, parking bonuses are: - 1 robot parked = 8 points - 2 robots parked = 30 points</p> <p>Write code that stores how many robots are parked (use 2) and calculates the bonus points.</p> <p>Q15: Look at this code from robot_config.py: <pre><code>WHEEL_TRAVEL_MM = 319.19\nTRACK_WIDTH_MM = 295\n</code></pre> What do these numbers represent? Why are they in ALL_CAPS? What data types are they?</p>"},{"location":"03-python-basics/04-review-qa/#section-2-functions","title":"Section 2: Functions","text":""},{"location":"03-python-basics/04-review-qa/#conceptual-questions-q16-q20","title":"Conceptual Questions (Q16-Q20)","text":"<p>Q16: What is a function in Python? Explain using the recipe analogy.</p> <p>Q17: What is the difference between a parameter and an argument? Give an example.</p> <p>Q18: Why is <code>return</code> important in a function? What happens if you forget it?</p> <p>Q19: What is a default parameter? Look at the <code>deadband()</code> function in utils.py: <pre><code>def deadband(value, threshold=5.0):\n</code></pre> What is the default value for <code>threshold</code>?</p> <p>Q20: In driver_control.py, motor control code is inside a function called <code>driver_control_loop()</code>. Why is it better to put code in a function instead of writing it directly?</p>"},{"location":"03-python-basics/04-review-qa/#code-reading-questions-q21-q25","title":"Code Reading Questions (Q21-Q25)","text":"<p>Q21: What does this function return when called with <code>calculate_area(4, 5)</code>? <pre><code>def calculate_area(width, height):\n    area = width * height\n    return area\n</code></pre></p> <p>Q22: This function has TWO errors. Find them both: <pre><code>def add_numbers(a, b)\n    result = a + b\n    return result\n</code></pre></p> <p>Q23: What does this code output? (There are two function calls) <pre><code>def greet(name=\"Robot\"):\n    print(\"Hello, \" + name + \"!\")\n\ngreet()\ngreet(\"Team 12345\")\n</code></pre></p> <p>Q24: Trace through <code>deadband(3, threshold=5)</code> step by step. What value is returned and why? <pre><code>def deadband(value, threshold=5.0):\n    if abs(value) &lt; threshold:\n        return 0.0\n    return value\n</code></pre></p> <p>Q25: What does <code>clamp(150, 0, 100)</code> return? Explain why. <pre><code>def clamp(value, min_val, max_val):\n    return max(min_val, min(value, max_val))\n</code></pre></p>"},{"location":"03-python-basics/04-review-qa/#push-back-application-questions-q26-q30","title":"Push Back Application Questions (Q26-Q30)","text":"<p>Q26: Write a function called <code>calculate_block_score</code> that: - Takes the number of blocks as a parameter - Returns the total points (each block is worth 3 points) - Include a docstring explaining what it does</p> <p>Q27: Write a function called <code>check_zone_control</code> that: - Takes two parameters: <code>our_blocks</code> and <code>opponent_blocks</code> - Returns <code>True</code> if we have more blocks than the opponent - Returns <code>False</code> otherwise</p> <p>Q28: The <code>deadband()</code> function helps with Push Back driving. Answer these questions: 1. What problem does it solve? 2. Why is this important when positioning blocks near goals? 3. What happens if joystick drift causes the robot to move when you're not touching it?</p> <p>Q29: Write a function called <code>parking_bonus</code> that: - Takes <code>num_robots</code> as a parameter (0, 1, or 2) - Returns the correct bonus: 0 points, 8 points, or 30 points</p> <p>Q30: Modify this function to have a default speed of 50: <pre><code>def drive_forward(distance, speed):\n    drivetrain.set_drive_velocity(speed, PERCENT)\n    drivetrain.drive_for(FORWARD, distance, MM)\n</code></pre> After modifying, what happens if you call <code>drive_forward(500)</code> without specifying speed?</p>"},{"location":"03-python-basics/04-review-qa/#section-3-loops-and-conditionals","title":"Section 3: Loops and Conditionals","text":""},{"location":"03-python-basics/04-review-qa/#conceptual-questions-q31-q35","title":"Conceptual Questions (Q31-Q35)","text":"<p>Q31: What is a conditional statement? Give a real-world example and its Python equivalent.</p> <p>Q32: What is the difference between <code>=</code> and <code>==</code>? Why is this a common mistake?</p> <p>Q33: When would you use <code>while True:</code> in robot code? Give a specific example.</p> <p>Q34: What is the difference between <code>break</code> and <code>continue</code> in a loop?</p> <p>Q35: In the driver control loop, we use <code>wait(20, MSEC)</code>. Why is this necessary? What would happen without it?</p>"},{"location":"03-python-basics/04-review-qa/#code-reading-questions-q36-q40","title":"Code Reading Questions (Q36-Q40)","text":"<p>Q36: What does this code print? <pre><code>score = 45\n\nif score &gt; 50:\n    print(\"Great!\")\nelif score &gt; 30:\n    print(\"Good\")\nelse:\n    print(\"Keep trying\")\n</code></pre></p> <p>Q37: How many times does this loop run, and what does it print? <pre><code>for i in range(3):\n    print(\"Block \" + str(i + 1))\n</code></pre></p> <p>Q38: This code has a serious bug. What is it, and what will happen? <pre><code>count = 0\nwhile count &lt; 5:\n    print(count)\n</code></pre></p> <p>Q39: What does this code output? <pre><code>x = 10\nif x &gt; 5 and x &lt; 15:\n    print(\"In range\")\nelse:\n    print(\"Out of range\")\n</code></pre></p> <p>Q40: Trace through this code. What numbers are printed? <pre><code>for i in range(5):\n    if i == 3:\n        break\n    print(i)\n</code></pre></p>"},{"location":"03-python-basics/04-review-qa/#push-back-application-questions-q41-q45","title":"Push Back Application Questions (Q41-Q45)","text":"<p>Q41: Write an if-elif-else statement that checks your alliance's block count: - If 7 or more blocks: print \"AWP Block Goal Met!\" - If 4-6 blocks: print \"Getting there!\" - Otherwise: print \"Need more blocks!\"</p> <p>Use <code>blocks_scored = 8</code> to test.</p> <p>Q42: Write a while loop that: - Continuously reads the controller button A - If the button is pressed, prints \"Button pressed!\" and exits the loop - Waits 20 milliseconds between checks (use <code>wait(20, MSEC)</code>)</p> <p>Q43: In Push Back driver control, write code that handles three button modes: - If R1 is pressed: multiply speed by 1.5 (turbo mode) - If L1 is pressed: multiply speed by 0.5 (precision mode) - Always clamp the result between -100 and 100</p> <p>Start with <code>speed = 80</code>.</p> <p>Q44: Write a for loop that simulates scoring 5 blocks by: - Printing \"Scoring block X\" where X is the block number (1-5) - After the loop, print \"Total blocks scored: 5\"</p> <p>Q45: The Push Back autonomous period is 15 seconds. Write a simplified autonomous routine that: - Uses a while loop to check if time is remaining - Drives forward for each iteration - Stops when time runs out - Prints how many push attempts were made</p> <pre><code># Start with these variables:\ntime_remaining = 15\npush_attempts = 0\ntime_per_push = 3  # seconds per push attempt\n</code></pre>"},{"location":"03-python-basics/04-review-qa/#answer-key","title":"Answer Key","text":""},{"location":"03-python-basics/04-review-qa/#section-1-answers-variables-and-types","title":"Section 1 Answers: Variables and Types","text":"<p>A1: A variable is like a labeled container that holds information. Think of labeled boxes in a kitchen: one labeled \"SUGAR\" holds sugar, one labeled \"FLOUR\" holds flour. In Python, <code>speed = 50</code> creates a box labeled \"speed\" that holds the number 50. You can change what's inside the box, and you can use the label to get the contents.</p> <p>A2: - <code>=</code> (single equals) is the assignment operator - it stores a value in a variable: <code>speed = 50</code> - <code>==</code> (double equals) is the comparison operator - it checks if two values are equal: <code>if speed == 50:</code> - Common mistake: using <code>=</code> when you mean <code>==</code> in conditions!</p> <p>A3: ALL_CAPS names (like <code>WHEEL_TRAVEL_MM</code>) follow Python convention for constants - values that shouldn't change during the program. They're not truly protected, but the naming tells other programmers \"don't modify this value.\" These are typically configuration values like wheel measurements.</p> <p>A4: Four basic data types: | Type | Example for Push Back Robot | |------|----------------------------| | <code>int</code> (integer) | <code>team_number = 12345</code> or <code>blocks_scored = 8</code> | | <code>float</code> (decimal) | <code>wheel_diameter = 4.0</code> or <code>gear_ratio = 2.5</code> | | <code>str</code> (string) | <code>alliance = \"red\"</code> or <code>robot_name = \"Push Bot\"</code> | | <code>bool</code> (boolean) | <code>is_parked = True</code> or <code>has_zone_control = False</code> |</p> <p>A5: Step by step: 1. Initially: <code>speed = 50</code> (speed holds 50) 2. Python evaluates the right side first: <code>speed + 10</code> = <code>50 + 10</code> = <code>60</code> 3. Then stores the result back in speed: <code>speed = 60</code> 4. Final value: 60</p> <p>A6: Tracing through: 1. <code>x = 10</code> \u2192 x is 10 2. <code>x = x * 2</code> \u2192 x is 10 * 2 = 20 3. <code>x = x - 5</code> \u2192 x is 20 - 5 = 15</p> <p>Final value: 15</p> <p>A7: - <code>a = 42</code> \u2192 int (whole number) - <code>b = 3.14</code> \u2192 float (decimal number) - <code>c = \"VEX\"</code> \u2192 str (text in quotes) - <code>d = True</code> \u2192 bool (boolean) - <code>e = \"100\"</code> \u2192 str (it's in quotes, so it's text, not a number!)</p> <p>A8: Output: <pre><code>Score: 15\n</code></pre> Explanation: 5 * 3 = 15, then <code>str(15)</code> converts it to \"15\" for concatenation.</p> <p>A9: The error: You can't add a string and an integer! - <code>motor_port</code> is <code>\"1\"</code> (a string) - You can't do <code>\"1\" + 1</code></p> <p>Fix: <pre><code>motor_port = 1  # Make it an integer\nactual_port = motor_port + 1  # Now works: 2\n</code></pre></p> <p>A10: The problem: Variable names can't contain hyphens (<code>-</code>) because Python thinks it's subtraction!</p> <p>Fix: Use underscores instead: <pre><code>my_robot_speed = 50\n</code></pre></p> <p>A11: <pre><code>blocks_scored = 8\npoints_per_block = 3\ntotal_score = blocks_scored * points_per_block\nprint(\"Alliance block score: \" + str(total_score))\n# Output: Alliance block score: 24\n</code></pre></p> <p>A12: <pre><code>team_number = 12345          # int - whole number\nrobot_name = \"Push Bot\"      # str - text in quotes\nis_parked = True             # bool - True or False\nwheel_diameter = 4.0         # float - decimal number\n</code></pre></p> <p>A13: <pre><code>field_feet = 12\nmm_per_foot = 304.8\nfield_mm = field_feet * mm_per_foot\n\nprint(\"Field size: \" + str(field_feet) + \" feet\")\nprint(\"Field size: \" + str(field_mm) + \" mm\")\n# Output:\n# Field size: 12 feet\n# Field size: 3657.6 mm\n</code></pre></p> <p>A14: <pre><code>robots_parked = 2\n\nif robots_parked == 2:\n    parking_bonus = 30\nelif robots_parked == 1:\n    parking_bonus = 8\nelse:\n    parking_bonus = 0\n\nprint(\"Parking bonus: \" + str(parking_bonus))\n# Output: Parking bonus: 30\n</code></pre></p> <p>A15: - <code>WHEEL_TRAVEL_MM = 319.19</code> represents the distance traveled in one wheel rotation (circumference) in millimeters. This is for 4-inch omni wheels. - <code>TRACK_WIDTH_MM = 295</code> is the distance between the left and right wheels. - ALL_CAPS because these are constants that shouldn't change during the program. - <code>WHEEL_TRAVEL_MM</code> is a float (has decimal). <code>TRACK_WIDTH_MM</code> is an int (but could be float).</p>"},{"location":"03-python-basics/04-review-qa/#section-2-answers-functions","title":"Section 2 Answers: Functions","text":"<p>A16: A function is like a recipe - a set of instructions with a name. Instead of writing all the steps every time you want to make a sandwich, you just say \"make a sandwich.\" In Python, instead of writing 10 lines of motor control code everywhere, you define <code>drive_forward()</code> once and call it by name whenever needed.</p> <p>A17: - Parameter: A variable in the function definition that receives a value. It's like a placeholder. - Argument: The actual value you pass when calling the function.</p> <p>Example: <pre><code>def greet(name):      # \"name\" is the PARAMETER\n    print(\"Hello, \" + name)\n\ngreet(\"Alice\")        # \"Alice\" is the ARGUMENT\n</code></pre></p> <p>A18: <code>return</code> gives a result back to the code that called the function. - Without <code>return</code>: The function does its work but gives back <code>None</code>. You can't use the result. - With <code>return</code>: You get a usable value back.</p> <pre><code># Without return\ndef add_no_return(a, b):\n    result = a + b\n    # forgot return!\n\nx = add_no_return(5, 3)  # x is None!\n\n# With return\ndef add_with_return(a, b):\n    return a + b\n\ny = add_with_return(5, 3)  # y is 8\n</code></pre> <p>A19: A default parameter has a preset value that's used if you don't provide one.</p> <p>In <code>def deadband(value, threshold=5.0):</code>, the default for <code>threshold</code> is 5.0.</p> <ul> <li><code>deadband(50)</code> uses threshold=5.0 (default)</li> <li><code>deadband(50, 10)</code> uses threshold=10 (overridden)</li> </ul> <p>A20: Benefits of putting code in a function: 1. Reusability: Call it from multiple places without copying code 2. Organization: Easier to understand what each part does 3. Maintainability: Fix bugs in one place, fixed everywhere 4. Testing: Can test the function independently 5. Readability: <code>driver_control_loop()</code> is clearer than 50 lines of code</p> <p>A21: The function returns 20. - <code>calculate_area(4, 5)</code> passes width=4, height=5 - <code>area = 4 * 5 = 20</code> - <code>return area</code> returns 20</p> <p>A22: Two errors: 1. Missing colon after the function definition: should be <code>def add_numbers(a, b):</code> 2. Missing indentation on the body (though this might not show in the formatting)</p> <p>Correct version: <pre><code>def add_numbers(a, b):\n    result = a + b\n    return result\n</code></pre></p> <p>A23: Output: <pre><code>Hello, Robot!\nHello, Team 12345!\n</code></pre> - First call <code>greet()</code> uses default parameter \"Robot\" - Second call <code>greet(\"Team 12345\")</code> uses the provided argument</p> <p>A24: Tracing <code>deadband(3, threshold=5)</code>: 1. <code>value = 3</code>, <code>threshold = 5</code> 2. Check: <code>abs(3) &lt; 5</code>? \u2192 <code>3 &lt; 5</code>? \u2192 True 3. Since True, execute <code>return 0.0</code> 4. Returns 0.0</p> <p>The joystick value 3 is below the threshold, so it's treated as zero (no drift).</p> <p>A25: <code>clamp(150, 0, 100)</code> returns 100.</p> <p>Breaking it down: 1. <code>min(150, 100)</code> = 100 (smaller of 150 and 100) 2. <code>max(0, 100)</code> = 100 (larger of 0 and 100) 3. Result: 100</p> <p>The value 150 is clamped down to the maximum of 100.</p> <p>A26: <pre><code>def calculate_block_score(blocks):\n    \"\"\"\n    Calculate total points from scored blocks in Push Back.\n\n    Args:\n        blocks: Number of blocks scored\n\n    Returns:\n        Total points (3 points per block)\n    \"\"\"\n    points_per_block = 3\n    return blocks * points_per_block\n\n# Test:\nprint(calculate_block_score(8))  # Output: 24\n</code></pre></p> <p>A27: <pre><code>def check_zone_control(our_blocks, opponent_blocks):\n    \"\"\"Check if our alliance controls a goal zone.\"\"\"\n    if our_blocks &gt; opponent_blocks:\n        return True\n    else:\n        return False\n    # Or simply: return our_blocks &gt; opponent_blocks\n\n# Test:\nprint(check_zone_control(5, 3))  # True\nprint(check_zone_control(2, 4))  # False\n</code></pre></p> <p>A28: 1. Problem it solves: Joystick drift - even when you're not touching the controller, it might not read exactly 0. It might read 2 or -3.</p> <ol> <li> <p>Why important for block positioning: When you're carefully positioning blocks near a goal, tiny unwanted movements could push the block the wrong way or miss the goal. deadband ensures the robot stays still when you want it still.</p> </li> <li> <p>Without deadband: The robot would constantly creep or drift even when you're not touching the joystick, making precise positioning nearly impossible.</p> </li> </ol> <p>A29: <pre><code>def parking_bonus(num_robots):\n    \"\"\"Calculate parking bonus based on robots parked.\"\"\"\n    if num_robots == 2:\n        return 30\n    elif num_robots == 1:\n        return 8\n    else:\n        return 0\n\n# Test:\nprint(parking_bonus(0))  # 0\nprint(parking_bonus(1))  # 8\nprint(parking_bonus(2))  # 30\n</code></pre></p> <p>A30: <pre><code>def drive_forward(distance, speed=50):  # Added =50 default\n    drivetrain.set_drive_velocity(speed, PERCENT)\n    drivetrain.drive_for(FORWARD, distance, MM)\n\n# Now drive_forward(500) uses speed=50 automatically\n# drive_forward(500, 75) would use speed=75\n</code></pre></p>"},{"location":"03-python-basics/04-review-qa/#section-3-answers-loops-and-conditionals","title":"Section 3 Answers: Loops and Conditionals","text":"<p>A31: A conditional statement lets code make decisions based on whether something is true or false.</p> <p>Real-world: \"If it's raining, take an umbrella. Otherwise, wear sunglasses.\"</p> <p>Python: <pre><code>if is_raining:\n    take_umbrella()\nelse:\n    wear_sunglasses()\n</code></pre></p> <p>A32: - <code>=</code> is assignment (store a value): <code>speed = 50</code> - <code>==</code> is comparison (check equality): <code>if speed == 50:</code></p> <p>Common mistake: Writing <code>if speed = 50:</code> (syntax error!) instead of <code>if speed == 50:</code></p> <p>Memory trick: \"Double equals to compare, single equals to declare.\"</p> <p>A33: <code>while True:</code> creates an infinite loop that runs forever (until you <code>break</code> or the robot turns off).</p> <p>Use in robot code: The driver control loop <pre><code>while True:\n    # Read joysticks\n    # Control motors\n    wait(20, MSEC)\n</code></pre> This runs continuously during the driver control period, constantly updating motor speeds based on joystick position.</p> <p>A34: - <code>break</code>: Exits the entire loop immediately - <code>continue</code>: Skips the rest of this iteration and goes to the next one</p> <pre><code>for i in range(5):\n    if i == 2:\n        break      # Stops at 2, prints: 0, 1\n        # continue  # Skips 2, prints: 0, 1, 3, 4\n    print(i)\n</code></pre> <p>A35: <code>wait(20, MSEC)</code> pauses for 20 milliseconds (0.02 seconds).</p> <p>Why necessary: 1. Without it, the loop runs millions of times per second 2. Uses excessive CPU power 3. Can cause the V5 Brain to overheat or lag 4. 20ms = 50 updates per second, which is smooth enough for control</p> <p>Without it: The brain would be overwhelmed, controls would be sluggish, and the robot might become unresponsive.</p> <p>A36: Output: \"Good\"</p> <p>Tracing: 1. <code>score = 45</code> 2. Is <code>45 &gt; 50</code>? No \u2192 skip \"Great!\" 3. Is <code>45 &gt; 30</code>? Yes \u2192 print \"Good\" and stop checking</p> <p>A37: The loop runs 3 times and prints: <pre><code>Block 1\nBlock 2\nBlock 3\n</code></pre></p> <p><code>range(3)</code> produces 0, 1, 2. We add 1 to each for display.</p> <p>A38: Infinite loop! The code will run forever because <code>count</code> never changes.</p> <p>The loop checks <code>count &lt; 5</code> (0 &lt; 5 = True), prints 0, then checks again... forever printing 0.</p> <p>Fix: Add <code>count = count + 1</code> inside the loop: <pre><code>count = 0\nwhile count &lt; 5:\n    print(count)\n    count = count + 1  # This was missing!\n</code></pre></p> <p>A39: Output: \"In range\"</p> <p>Tracing: - <code>x = 10</code> - Is <code>x &gt; 5</code>? \u2192 <code>10 &gt; 5</code> \u2192 True - Is <code>x &lt; 15</code>? \u2192 <code>10 &lt; 15</code> \u2192 True - <code>True and True</code> \u2192 True \u2192 print \"In range\"</p> <p>A40: Output: <pre><code>0\n1\n2\n</code></pre></p> <p>Tracing: - i=0: Is 0==3? No \u2192 print 0 - i=1: Is 1==3? No \u2192 print 1 - i=2: Is 2==3? No \u2192 print 2 - i=3: Is 3==3? Yes \u2192 break (exit loop immediately)</p> <p>3 and 4 are never printed because <code>break</code> exits before printing.</p> <p>A41: <pre><code>blocks_scored = 8\n\nif blocks_scored &gt;= 7:\n    print(\"AWP Block Goal Met!\")\nelif blocks_scored &gt;= 4:\n    print(\"Getting there!\")\nelse:\n    print(\"Need more blocks!\")\n\n# Output: AWP Block Goal Met!\n</code></pre></p> <p>A42: <pre><code>while True:\n    if controller.buttonA.pressing():\n        print(\"Button pressed!\")\n        break\n    wait(20, MSEC)\n</code></pre></p> <p>A43: <pre><code>speed = 80\n\nif controller.buttonR1.pressing():\n    speed = speed * 1.5  # Turbo: 80 * 1.5 = 120\nelif controller.buttonL1.pressing():\n    speed = speed * 0.5  # Precision: 80 * 0.5 = 40\n\n# Clamp to valid range\nspeed = clamp(speed, -100, 100)\n\n# If R1 was pressed: speed is now 100 (clamped from 120)\n# If L1 was pressed: speed is now 40\n# If neither: speed stays 80\n</code></pre></p> <p>A44: <pre><code>for block_number in range(1, 6):  # 1, 2, 3, 4, 5\n    print(\"Scoring block \" + str(block_number))\n\nprint(\"Total blocks scored: 5\")\n</code></pre></p> <p>Output: <pre><code>Scoring block 1\nScoring block 2\nScoring block 3\nScoring block 4\nScoring block 5\nTotal blocks scored: 5\n</code></pre></p> <p>A45: <pre><code>time_remaining = 15\npush_attempts = 0\ntime_per_push = 3\n\nwhile time_remaining &gt; 0:\n    # Simulate pushing\n    print(\"Push attempt \" + str(push_attempts + 1))\n    # drivetrain.drive_for(FORWARD, 500, MM)  # In real code\n\n    push_attempts = push_attempts + 1\n    time_remaining = time_remaining - time_per_push\n\nprint(\"Autonomous complete!\")\nprint(\"Total push attempts: \" + str(push_attempts))\n</code></pre></p> <p>Output: <pre><code>Push attempt 1\nPush attempt 2\nPush attempt 3\nPush attempt 4\nPush attempt 5\nAutonomous complete!\nTotal push attempts: 5\n</code></pre></p>"},{"location":"03-python-basics/04-review-qa/#score-tracker","title":"Score Tracker","text":"Section Your Score Out Of Variables and Types ___ 15 Functions ___ 15 Loops and Conditionals ___ 15 TOTAL ___ 45 <p>\u2190 Previous: Loops and Conditionals | Next: Drive Control \u2192</p>"},{"location":"04-drive-control/00-controller-basics/","title":"Tutorial 4.0: VEX Controller Basics","text":"<p>Time: ~15 minutes Prerequisites: Tutorial 2.1: Brain and Controller (review recommended) Math Review: Negative numbers, percentages, basic number lines</p>"},{"location":"04-drive-control/00-controller-basics/#before-we-drive-understanding-the-controller","title":"Before We Drive: Understanding the Controller","text":"<p>Before we learn tank drive or arcade drive, let's make sure we understand how the VEX controller talks to our robot. This tutorial covers the fundamentals that every driver needs to know!</p>"},{"location":"04-drive-control/00-controller-basics/#part-1-the-controller-layout","title":"Part 1: The Controller Layout","text":"<p>The VEX V5 Controller has two joysticks and twelve buttons:</p> <pre><code>    VEX V5 CONTROLLER (front view)\n\n    [L1]                               [R1]    &lt;- Bumper buttons\n    [L2]                               [R2]    &lt;- Trigger buttons\n\n    +-------+                       +-------+\n    |       |                       |       |\n    |   O   |  &lt;- Left Joystick     |   O   |  &lt;- Right Joystick\n    |       |                       |       |\n    +-------+                       +-------+\n\n                [UP]\n           [LEFT]  [RIGHT]     [X]   [A]\n                [DOWN]              [B]   [Y]\n</code></pre>"},{"location":"04-drive-control/00-controller-basics/#joystick-movement-directions","title":"Joystick Movement Directions","text":"<p>Each joystick can move in TWO directions: - Y-axis = Up and Down (vertical) - X-axis = Left and Right (horizontal)</p> <pre><code>flowchart TB\n    subgraph Joystick Coordinate System\n        direction TB\n        Yplus[\"Y+ (Up)\"]\n        Xminus[\"X- (Left)\"] --- Center[\"\u25cf Center\"]\n        Center --- Xplus[\"X+ (Right)\"]\n        Center --- Yminus[\"Y- (Down)\"]\n        Yplus --- Center\n    end</code></pre>"},{"location":"04-drive-control/00-controller-basics/#part-2-axis-numbers-why-axis3-and-axis2","title":"Part 2: Axis Numbers (Why axis3 and axis2?)","text":"<p>VEX gave each joystick direction a NUMBER. Here's the full map:</p> <pre><code>    LEFT JOYSTICK                    RIGHT JOYSTICK\n\n         axis3                           axis2\n           \u2191                               \u2191\n           |                               |\n    axis4 \u2190\u25cf\u2192 axis4                 axis1 \u2190\u25cf\u2192 axis1\n           |                               |\n           \u2193                               \u2193\n         axis3                           axis2\n\n\n    QUICK REFERENCE:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  axis1 = Right stick, Left/Right (X)  \u2502\n    \u2502  axis2 = Right stick, Up/Down    (Y)  \u2502\n    \u2502  axis3 = Left stick,  Up/Down    (Y)  \u2502\n    \u2502  axis4 = Left stick,  Left/Right (X)  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"04-drive-control/00-controller-basics/#memory-trick","title":"Memory Trick","text":"<p>Think of it as reading right-to-left: 3-2 goes Left-to-Right for Y-axes!</p> <pre><code>    Y-axes:  3 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 2\n             Left stick          Right stick\n\n    X-axes:  4 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 1\n             Left stick          Right stick\n</code></pre>"},{"location":"04-drive-control/00-controller-basics/#what-does-axis3position-mean","title":"What Does axis3.position() Mean?","text":"<p>When you write <code>controller.axis3.position()</code>: - <code>controller</code> = The VEX controller - <code>axis3</code> = Left joystick, up/down movement - <code>position()</code> = \"Tell me where the joystick is right now\"</p>"},{"location":"04-drive-control/00-controller-basics/#part-3-joystick-values-100-to-100","title":"Part 3: Joystick Values (-100 to +100)","text":"<p>When you move a joystick, it returns a number between -100 and +100:</p> <pre><code>    JOYSTICK Y-AXIS (up/down):\n\n            Full UP = +100\n                \u2191\n               +75\n                \u2191\n               +50\n                \u2191\n               +25\n                \u2191\n    Center \u2192    0   \u2190 Joystick at rest\n                \u2193\n               -25\n                \u2193\n               -50\n                \u2193\n               -75\n                \u2193\n            Full DOWN = -100\n\n\n    IT'S LIKE A THERMOMETER:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Positive = \"hot\" = forward \u2502\n    \u2502 Negative = \"cold\" = back   \u2502\n    \u2502 Zero = \"room temp\" = stop  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"04-drive-control/00-controller-basics/#real-examples","title":"Real Examples","text":"Joystick Position axis3 Returns Motor Response All the way up +100 Full speed forward Halfway up +50 Half speed forward At rest (center) 0 Motor stops Halfway down -50 Half speed backward All the way down -100 Full speed backward"},{"location":"04-drive-control/00-controller-basics/#part-4-vex-api-constants-explained","title":"Part 4: VEX API Constants Explained","text":"<p>When you see code like this:</p> <pre><code>left_motors.spin(FORWARD, left_speed, PERCENT)\nwait(20, MSEC)\n</code></pre> <p>What do <code>FORWARD</code>, <code>PERCENT</code>, and <code>MSEC</code> mean? Let's break them down:</p>"},{"location":"04-drive-control/00-controller-basics/#forward-and-reverse","title":"FORWARD and REVERSE","text":"<p>These are direction references, NOT commands to move forward!</p> <pre><code>    FORWARD  = \"When speed is positive, spin this way\"\n               (clockwise when looking at the motor shaft)\n\n    REVERSE  = \"When speed is positive, spin the OTHER way\"\n\n\n    HOW IT WORKS:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  spin(FORWARD, +50, PERCENT)  \u2192  Forward at 50% \u2502\n    \u2502  spin(FORWARD, -50, PERCENT)  \u2192  Backward at 50%\u2502\n    \u2502                                                 \u2502\n    \u2502  The SIGN of the speed controls direction!      \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Think of <code>FORWARD</code> like a light switch that says \"follow the number's sign\": - Positive number = spin forward - Negative number = spin backward</p>"},{"location":"04-drive-control/00-controller-basics/#percent","title":"PERCENT","text":"<p>This tells the motor what unit the speed is in:</p> <pre><code>    PERCENT means \"out of 100\"\n\n    Examples:\n    - 100 PERCENT = Maximum speed (100%)\n    - 50 PERCENT  = Half speed (50%)\n    - 0 PERCENT   = Stopped (0%)\n\n    Just like your test grades:\n    - 100% = perfect\n    - 50%  = half right\n    - 0%   = nothing\n</code></pre>"},{"location":"04-drive-control/00-controller-basics/#msec-milliseconds","title":"MSEC (Milliseconds)","text":"<p>This is a unit of time. There are 1000 milliseconds in 1 second:</p> <pre><code>    TIME CONVERSION:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  1000 MSEC  =  1 second       \u2502\n    \u2502   500 MSEC  =  0.5 seconds    \u2502\n    \u2502   100 MSEC  =  0.1 seconds    \u2502\n    \u2502    20 MSEC  =  0.02 seconds   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Why wait(20, MSEC)?\n    - 20 milliseconds = 0.02 seconds\n    - 1000 \u00f7 20 = 50 times per second\n    - The loop runs 50 times per second (smooth control!)\n</code></pre> <p>Think of it like video game frame rates: - 60 FPS game = 60 frames per second - Our robot = 50 updates per second</p>"},{"location":"04-drive-control/00-controller-basics/#part-5-why-joysticks-drift","title":"Part 5: Why Joysticks Drift","text":"<p>Have you ever noticed that when you let go of the joystick, the value isn't exactly 0? Maybe it shows 2 or -3 instead?</p>"},{"location":"04-drive-control/00-controller-basics/#this-is-called-drift","title":"This is Called \"Drift\"","text":"<pre><code>    IDEAL WORLD:                  REAL WORLD:\n\n    +-----+                       +-----+\n    |  \u25cf  | = 0                   |  \u25cf  | = 2 or -1 or 3\n    +-----+                       +-----+\n\n    Joystick at rest should       But actually returns\n    return exactly 0              a small number\n</code></pre>"},{"location":"04-drive-control/00-controller-basics/#why-does-drift-happen","title":"Why Does Drift Happen?","text":"<p>Analogy: The Shopping Cart</p> <p>Imagine a shopping cart with slightly bent wheels:</p> <pre><code>    PERFECT CART:                 REAL CART:\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2510                       \u250c\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502     \u2502 Goes perfectly        \u2502     \u2502 Drifts a little\n    \u2502  \u25cf  \u2502 straight              \u2502  \u25cf  \u2502 even when you\n    \u2514\u2500\u2500\u252c\u2500\u2500\u2518                       \u2514\u2500\u2500\u252c\u2500\u2500\u2518 push straight\n       \u2502                             \u2197\n       \u2193                           (slight drift)\n</code></pre> <p>Joysticks are the same! They use: - Springs that wear out over time - Sensors with tiny manufacturing differences - Materials affected by temperature</p> <p>Result: The \"center\" position is never perfectly zero.</p>"},{"location":"04-drive-control/00-controller-basics/#the-solution-deadband","title":"The Solution: Deadband","text":"<p>We'll learn about this in the next tutorial, but the idea is simple:</p> <pre><code>    WITHOUT DEADBAND:           WITH DEADBAND:\n\n    Joystick = 2                Joystick = 2\n    Motor speed = 2             Motor speed = 0  \u2190 Treated as zero!\n    Robot slowly creeps...      Robot stays still!\n\n    We ignore small values (like -5 to +5) so drift doesn't\n    cause the robot to creep around.\n</code></pre>"},{"location":"04-drive-control/00-controller-basics/#part-6-math-review-for-drive-control","title":"Part 6: Math Review for Drive Control","text":"<p>Before we dive into drive code, let's review three math concepts you'll see:</p>"},{"location":"04-drive-control/00-controller-basics/#1-absolute-value-x","title":"1. Absolute Value: |x|","text":"<p>Absolute value means \"distance from zero\" - ignore the negative sign!</p> <pre><code>    |5|   = 5     (5 is 5 units from zero)\n    |-5|  = 5     (-5 is also 5 units from zero)\n    |-100| = 100  (100 units from zero)\n    |0|   = 0     (0 is 0 units from zero)\n\n    REAL WORLD EXAMPLE:\n    Walking 5 blocks LEFT = walking 5 blocks RIGHT\n    Same DISTANCE, different direction!\n</code></pre>"},{"location":"04-drive-control/00-controller-basics/#2-exponents-xn","title":"2. Exponents: x^n","text":"<p>An exponent means \"multiply by itself n times\":</p> <pre><code>    2^2 = 2 \u00d7 2 = 4\n    3^2 = 3 \u00d7 3 = 9\n    10^2 = 10 \u00d7 10 = 100\n\n    With decimals:\n    0.5^2 = 0.5 \u00d7 0.5 = 0.25\n    0.25^2 = 0.25 \u00d7 0.25 = 0.0625\n\n    REAL WORLD EXAMPLE:\n    Area of a square = side \u00d7 side = side\u00b2\n    A 5-foot square has area 5\u00b2 = 25 square feet\n</code></pre>"},{"location":"04-drive-control/00-controller-basics/#3-normalized-values-0-to-1-range","title":"3. Normalized Values (0 to 1 range)","text":"<p>\"Normalizing\" means converting a value to a 0-to-1 scale:</p> <pre><code>    To normalize: divide by the maximum\n\n    50 out of 100 = 50/100 = 0.5 (normalized)\n    75 out of 100 = 75/100 = 0.75 (normalized)\n    25 out of 100 = 25/100 = 0.25 (normalized)\n\n    REAL WORLD EXAMPLE:\n    Test score: 85 out of 100\n    Normalized: 85/100 = 0.85 = 85%\n</code></pre>"},{"location":"04-drive-control/00-controller-basics/#quick-reference","title":"Quick Reference","text":"<pre><code>    AXIS NUMBERS:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  axis1 = Right X (right joystick \u2190\u2192) \u2502\n    \u2502  axis2 = Right Y (right joystick \u2191\u2193) \u2502\n    \u2502  axis3 = Left Y  (left joystick \u2191\u2193)  \u2502\n    \u2502  axis4 = Left X  (left joystick \u2190\u2192)  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    VALUES:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  Joystick range: -100 to +100        \u2502\n    \u2502  Center = 0                          \u2502\n    \u2502  Up/Right = positive                 \u2502\n    \u2502  Down/Left = negative                \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    CONSTANTS:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  FORWARD = direction reference       \u2502\n    \u2502  PERCENT = speed unit (0-100%)       \u2502\n    \u2502  MSEC = milliseconds (1000 = 1 sec)  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"04-drive-control/00-controller-basics/#exercise-controller-exploration","title":"Exercise: Controller Exploration","text":"<p>Goal: Explore your controller values in real-time</p> <p>Step 1: Add this code to display joystick values:</p> <pre><code>while True:\n    # Read all four axes\n    left_y = controller.axis3.position()\n    left_x = controller.axis4.position()\n    right_y = controller.axis2.position()\n    right_x = controller.axis1.position()\n\n    # Display on brain screen\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n    brain.screen.print(\"Left Y (axis3): \", left_y)\n    brain.screen.set_cursor(2, 1)\n    brain.screen.print(\"Left X (axis4): \", left_x)\n    brain.screen.set_cursor(3, 1)\n    brain.screen.print(\"Right Y (axis2): \", right_y)\n    brain.screen.set_cursor(4, 1)\n    brain.screen.print(\"Right X (axis1): \", right_x)\n\n    wait(50, MSEC)\n</code></pre> <p>Step 2: Download and run. Watch the screen as you move the joysticks!</p> <p>Questions to Answer: 1. What value do you see when the left stick is all the way up? 2. What value do you see when the right stick is at rest? 3. Is the \"at rest\" value exactly 0, or does it drift? 4. Move the left stick in a circle - what happens to axis3 and axis4?</p> <p>\u2190 Previous: Loops and Conditionals | Next: Tank Drive \u2192</p>"},{"location":"04-drive-control/01-tank-drive/","title":"Tutorial 4.1: Tank Drive","text":"<p>Time: ~10 minutes Prerequisites: Tutorial 3: Python Basics</p>"},{"location":"04-drive-control/01-tank-drive/#what-is-tank-drive","title":"What is Tank Drive?","text":"<p>Tank drive is the simplest way to control a robot: each joystick controls one side of the drivetrain, just like driving a tank!</p> <pre><code>flowchart LR\n    subgraph Controller\n        LS1[\"Left Stick \u2191\"]\n        RS1[\"Right Stick \u2191\"]\n        LS2[\"Left Stick \u2191\"]\n        RS2[\"Right Stick \u2193\"]\n        LS3[\"Left Stick \u2193\"]\n        RS3[\"Right Stick \u2191\"]\n    end\n\n    subgraph Response1[\"Both Forward\"]\n        LW1[\"Left Wheels \u2191 Forward\"]\n        RW1[\"Right Wheels \u2191 Forward\"]\n    end\n\n    subgraph Response2[\"Spin Left\"]\n        LW2[\"Left Wheels \u2191 Forward\"]\n        RW2[\"Right Wheels \u2193 Backward\"]\n    end\n\n    subgraph Response3[\"Spin Right\"]\n        LW3[\"Left Wheels \u2193 Backward\"]\n        RW3[\"Right Wheels \u2191 Forward\"]\n    end\n\n    LS1 --&gt; LW1\n    RS1 --&gt; RW1\n    LS2 --&gt; LW2\n    RS2 --&gt; RW2\n    LS3 --&gt; LW3\n    RS3 --&gt; RW3</code></pre>"},{"location":"04-drive-control/01-tank-drive/#understanding-axis3-and-axis2","title":"Understanding axis3 and axis2","text":"<p>These are the NAMES that VEX gave to joystick directions:</p> <pre><code>    LEFT JOYSTICK                RIGHT JOYSTICK\n\n         axis3                        axis2\n           \u2191                            \u2191\n           |                            |\n    axis4 \u2190\u25cf\u2192 axis4             axis1 \u2190\u25cf\u2192 axis1\n           |                            |\n           \u2193                            \u2193\n         axis3                        axis2\n\n\n    QUICK REFERENCE:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  axis3 = Left stick, up-down movement (Y-axis)  \u2502\n    \u2502  axis2 = Right stick, up-down movement (Y-axis) \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Think of the axis numbers as addresses: - axis3 = \"Left stick, up-down movement\" - axis2 = \"Right stick, up-down movement\"</p> <p>Memory Trick: \"3-2\" reads left-to-right, just like the sticks on the controller!</p>"},{"location":"04-drive-control/01-tank-drive/#the-tank-drive-logic","title":"The Tank Drive Logic","text":"<p>The code is surprisingly simple:</p> <pre><code>while True:\n    # Read left joystick Y-axis (axis3)\n    left_speed = controller.axis3.position()\n\n    # Read right joystick Y-axis (axis2)\n    right_speed = controller.axis2.position()\n\n    # Send to motors\n    left_motors.spin(FORWARD, left_speed, PERCENT)\n    right_motors.spin(FORWARD, right_speed, PERCENT)\n\n    wait(20, MSEC)\n</code></pre> <p>That's it! The joystick value (-100 to +100) directly becomes the motor speed.</p>"},{"location":"04-drive-control/01-tank-drive/#wait-what-does-forward-mean-here","title":"Wait, What Does FORWARD Mean Here?","text":"<p>Here's what might confuse you:</p> <pre><code>    left_motors.spin(FORWARD, left_speed, PERCENT)\n                       \u2191          \u2191          \u2191\n                       |          |          |\n                       |          |          Unit of speed (out of 100)\n                       |          The actual speed number\n                       Direction reference point\n</code></pre> <p>FORWARD doesn't mean \"go forward\"! It means: - \"Spin in the positive direction when speed is positive\" - \"Spin in the negative direction when speed is negative\"</p> <pre><code>    HOW IT WORKS:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  If left_speed = +50:                           \u2502\n    \u2502      Motors spin FORWARD at 50% speed           \u2502\n    \u2502                                                 \u2502\n    \u2502  If left_speed = -50:                           \u2502\n    \u2502      Motors spin BACKWARD at 50% speed          \u2502\n    \u2502                                                 \u2502\n    \u2502  FORWARD just means \"follow the number's sign\"  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>PERCENT tells the motor what unit the speed is in: - 100 PERCENT = maximum speed - 50 PERCENT = half speed - 0 PERCENT = stopped</p>"},{"location":"04-drive-control/01-tank-drive/#code-walkthrough-driver_controlpy","title":"Code Walkthrough: driver_control.py","text":"<p>Let's look at the full implementation in <code>src/driver_control.py</code>:</p> <pre><code>def driver_control_loop():\n    \"\"\"\n    Main driver control loop using tank drive.\n    \"\"\"\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n    brain.screen.print(\"Driver Control Active\")\n\n    while True:\n        # Get joystick positions (-100 to 100)\n        left_speed = controller.axis3.position()   # Left joystick Y\n        right_speed = controller.axis2.position()  # Right joystick Y\n\n        # Apply deadband to prevent motor drift\n        left_speed = deadband(left_speed, threshold=5)\n        right_speed = deadband(right_speed, threshold=5)\n\n        # Set motor velocities and spin\n        left_motors.set_velocity(left_speed, PERCENT)\n        right_motors.set_velocity(right_speed, PERCENT)\n\n        left_motors.spin(FORWARD)\n        right_motors.spin(FORWARD)\n\n        wait(20, MSEC)\n</code></pre>"},{"location":"04-drive-control/01-tank-drive/#why-deadband","title":"Why Deadband?","text":"<p>Joysticks are never perfectly centered. There's always a tiny bit of drift:</p> <p>Joystick at rest ideally returns 0, but in reality returns small values like 2, 3, or -1. Without deadband, motors creep slowly! With deadband, values under the threshold become 0.</p>"},{"location":"04-drive-control/01-tank-drive/#deadband-step-by-step","title":"Deadband Step-by-Step","text":"<p>Let's trace what happens with <code>threshold=5</code>:</p> <pre><code>flowchart TD\n    subgraph Example1[\"Example 1: Joystick returns 3\"]\n        Input1[\"Input: 3\"] --&gt; Check1{\"|3| &lt; 5?\"}\n        Check1 --&gt;|\"YES (3 &lt; 5)\"| Output1[\"Output: 0&lt;br/&gt;Motor stays still\"]\n    end</code></pre> <pre><code>flowchart TD\n    subgraph Example2[\"Example 2: Joystick returns -50\"]\n        Input2[\"Input: -50\"] --&gt; Check2{\"|-50| &lt; 5?\"}\n        Check2 --&gt;|\"NO (50 &gt;= 5)\"| Output2[\"Output: -50&lt;br/&gt;Motor runs at 50% reverse\"]\n    end</code></pre> <pre><code>flowchart TD\n    subgraph Example3[\"Example 3: Joystick returns 5\"]\n        Input3[\"Input: 5\"] --&gt; Check3{\"|5| &lt; 5?\"}\n        Check3 --&gt;|\"NO (5 = 5, not less than)\"| Output3[\"Output: 5&lt;br/&gt;Motor runs at 5% forward\"]\n    end</code></pre> <p>General Deadband Decision Flow:</p> <pre><code>flowchart TD\n    Start[\"Joystick Value\"] --&gt; AbsCheck{\"|value| &lt; threshold?\"}\n    AbsCheck --&gt;|YES| Zero[\"Return 0&lt;br/&gt;(Ignore drift)\"]\n    AbsCheck --&gt;|NO| Original[\"Return original value&lt;br/&gt;(Real movement)\"]\n    Zero --&gt; Motor1[\"Motor stays still\"]\n    Original --&gt; Motor2[\"Motor spins at given speed\"]</code></pre>"},{"location":"04-drive-control/01-tank-drive/#movement-patterns","title":"Movement Patterns","text":""},{"location":"04-drive-control/01-tank-drive/#forward","title":"Forward","text":"<pre><code>    Left Stick: \u2191 (+100)     Left Motors:  \u2191 Forward\n    Right Stick: \u2191 (+100)    Right Motors: \u2191 Forward\n</code></pre>"},{"location":"04-drive-control/01-tank-drive/#backward","title":"Backward","text":"<pre><code>    Left Stick: \u2193 (-100)     Left Motors:  \u2193 Backward\n    Right Stick: \u2193 (-100)    Right Motors: \u2193 Backward\n</code></pre>"},{"location":"04-drive-control/01-tank-drive/#turn-left-pivot","title":"Turn Left (Pivot)","text":"<pre><code>    Left Stick: \u2193 (-100)     Left Motors:  \u2193 Backward\n    Right Stick: \u2191 (+100)    Right Motors: \u2191 Forward\n\n    Robot pivots counter-clockwise!\n</code></pre>"},{"location":"04-drive-control/01-tank-drive/#turn-right-pivot","title":"Turn Right (Pivot)","text":"<pre><code>    Left Stick: \u2191 (+100)     Left Motors:  \u2191 Forward\n    Right Stick: \u2193 (-100)    Right Motors: \u2193 Backward\n\n    Robot pivots clockwise!\n</code></pre>"},{"location":"04-drive-control/01-tank-drive/#arc-turn-gradual","title":"Arc Turn (Gradual)","text":"<pre><code>    Left Stick: \u2191 (+100)     Left Motors:  \u2191 Forward (100%)\n    Right Stick: \u2191 (+50)     Right Motors: \u2191 Forward (50%)\n\n    Robot arcs to the right!\n</code></pre>"},{"location":"04-drive-control/01-tank-drive/#practice-pattern-dimensions","title":"Practice Pattern Dimensions","text":"<p>When practicing movement patterns, use these recommended sizes:</p> <pre><code>    STRAIGHT LINE TEST:\n    \u25cf\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u25cf\n    START                      END\n\n    Distance: 6 feet (~1.8 meters)\n    Goal: Drive without veering left or right\n\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n    PIVOT TEST:\n\n         \u21ba\n        \u2571 \u2572\n       \u2502 \u25cf \u2502    Spin 360\u00b0 in place\n        \u2572 \u2571\n         \u21bb\n\n    Goal: End facing the same direction you started\n\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n    ARC TURN TEST:\n\n    \u25cf\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    START           \u2551  Width: 3 feet (~90 cm)\n                    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2605 END\n\n    Goal: Smooth curve, no jerky corrections\n</code></pre>"},{"location":"04-drive-control/01-tank-drive/#tank-drive-diagram","title":"Tank Drive Diagram","text":"<pre><code>    CONTROLLER                          ROBOT (top view)\n\n    +-----+                              +--------+\n    | \u2191   |  axis3.position()       \u2192    [LF][LB]  (left side)\n    +-----+                              |        |\n                                         |        |\n    +-----+                              |        |\n    | \u2191   |  axis2.position()       \u2192    [RF][RB]  (right side)\n    +-----+                              +--------+\n\n    Each stick controls one side independently!\n</code></pre>"},{"location":"04-drive-control/01-tank-drive/#pros-and-cons-of-tank-drive","title":"Pros and Cons of Tank Drive","text":""},{"location":"04-drive-control/01-tank-drive/#advantages","title":"Advantages","text":"<ul> <li>Simple to understand - one stick = one side</li> <li>Easy to code - just read two axes</li> <li>Precise turning - independent control of each side</li> <li>Good for beginners - intuitive mapping</li> </ul>"},{"location":"04-drive-control/01-tank-drive/#disadvantages","title":"Disadvantages","text":"<ul> <li>Requires both hands - can't drive one-handed</li> <li>Harder for curves - need to coordinate both sticks</li> <li>Can be jerky - small stick differences cause wobble</li> </ul>"},{"location":"04-drive-control/01-tank-drive/#exercise-experiment-with-deadband","title":"Exercise: Experiment with Deadband","text":"<p>Goal: Change the deadband threshold and observe the effect.</p> <p>Step 1: Open <code>src/driver_control.py</code></p> <p>Step 2: Find these lines: <pre><code>left_speed = deadband(left_speed, threshold=5)\nright_speed = deadband(right_speed, threshold=5)\n</code></pre></p> <p>Step 3: Try different values: - <code>threshold=0</code> - No deadband (any small movement = motor movement) - <code>threshold=10</code> - Larger deadband (need to push stick further) - <code>threshold=20</code> - Very large deadband (significant push required)</p> <p>Questions: 1. What happens with <code>threshold=0</code>? Does the robot drift? 2. What happens with <code>threshold=20</code>? Is it hard to make small movements? 3. What's the best balance for your driving style?</p> <p>\u2190 Previous: Controller Basics | Next: Arcade Drive \u2192</p>"},{"location":"04-drive-control/02-arcade-drive/","title":"Tutorial 4.2: Arcade Drive","text":"<p>Time: ~10 minutes Prerequisites: Tutorial 4.1: Tank Drive</p>"},{"location":"04-drive-control/02-arcade-drive/#what-is-arcade-drive","title":"What is Arcade Drive?","text":"<p>Arcade drive uses one joystick for everything: forward/backward AND turning. It's called \"arcade\" because it's like driving in a video game!</p> <pre><code>    Controller:              Robot Response:\n\n    LEFT STICK only:\n\n         \u2191               = Forward\n         \u2193               = Backward\n         \u2190               = Turn left\n         \u2192               = Turn right\n         \u2197               = Forward + Turn right (arc)\n</code></pre>"},{"location":"04-drive-control/02-arcade-drive/#the-arcade-drive-math","title":"The Arcade Drive Math","text":"<p>The magic is in how we mix the joystick values:</p> <pre><code>flowchart TD\n    subgraph Inputs[\"Joystick Inputs\"]\n        Y[\"Forward = Y-axis&lt;br/&gt;(up/down)\"]\n        X[\"Turn = X-axis&lt;br/&gt;(left/right)\"]\n    end\n\n    subgraph Mixing[\"Arcade Mixing Formula\"]\n        L[\"Left Motor Speed = Forward + Turn\"]\n        R[\"Right Motor Speed = Forward - Turn\"]\n    end\n\n    Y --&gt; L\n    Y --&gt; R\n    X --&gt; L\n    X --&gt; R</code></pre>"},{"location":"04-drive-control/02-arcade-drive/#why-does-this-work","title":"Why Does This Work?","text":"<pre><code>flowchart TD\n    subgraph FWD[\"FORWARD ONLY (Y=100, X=0)\"]\n        F1[\"Left = 100 + 0 = 100\"]\n        F2[\"Right = 100 - 0 = 100\"]\n        F3[\"Both motors go forward&lt;br/&gt;at same speed!\"]\n        F1 --&gt; F3\n        F2 --&gt; F3\n    end\n\n    subgraph TURN[\"TURN RIGHT (Y=0, X=50)\"]\n        T1[\"Left = 0 + 50 = 50\"]\n        T2[\"Right = 0 - 50 = -50\"]\n        T3[\"Robot pivots right!\"]\n        T1 --&gt; T3\n        T2 --&gt; T3\n    end\n\n    subgraph ARC[\"FORWARD + RIGHT ARC (Y=80, X=20)\"]\n        A1[\"Left = 80 + 20 = 100\"]\n        A2[\"Right = 80 - 20 = 60\"]\n        A3[\"Robot curves right&lt;br/&gt;while moving forward!\"]\n        A1 --&gt; A3\n        A2 --&gt; A3\n    end</code></pre>"},{"location":"04-drive-control/02-arcade-drive/#lets-do-the-math-together-step-by-step","title":"Let's Do The Math Together (Step-by-Step)","text":"<p>EXAMPLE 1: Driving Forward Only</p> <p>You push the joystick straight up to 80%.</p> <pre><code>flowchart LR\n    subgraph Input[\"INPUT\"]\n        Y[\"Y-axis (forward) = 80\"]\n        X[\"X-axis (turn) = 0\"]\n    end\n\n    subgraph Calc[\"CALCULATION\"]\n        L[\"Left Motor = 80 + 0 = 80%\"]\n        R[\"Right Motor = 80 - 0 = 80%\"]\n    end\n\n    subgraph Result[\"RESULT\"]\n        RES[\"Both motors at 80%&lt;br/&gt;Robot goes STRAIGHT FORWARD\"]\n    end\n\n    Y --&gt; L\n    Y --&gt; R\n    X --&gt; L\n    X --&gt; R\n    L --&gt; RES\n    R --&gt; RES</code></pre> <p>EXAMPLE 2: Turning While Driving</p> <p>You push the joystick up AND right.</p> <pre><code>flowchart LR\n    subgraph Input[\"INPUT\"]\n        Y[\"Y-axis (forward) = 60\"]\n        X[\"X-axis (turn) = 30\"]\n    end\n\n    subgraph Calc[\"CALCULATION\"]\n        L[\"Left Motor = 60 + 30 = 90%&lt;br/&gt;(Faster!)\"]\n        R[\"Right Motor = 60 - 30 = 30%&lt;br/&gt;(Slower!)\"]\n    end\n\n    subgraph Result[\"RESULT\"]\n        RES[\"Left faster than right&lt;br/&gt;Robot CURVES RIGHT\"]\n    end\n\n    Y --&gt; L\n    Y --&gt; R\n    X --&gt; L\n    X --&gt; R\n    L --&gt; RES\n    R --&gt; RES</code></pre> <p>EXAMPLE 3: Spin in Place</p> <p>You push the joystick RIGHT only (no forward/backward).</p> <pre><code>flowchart LR\n    subgraph Input[\"INPUT\"]\n        Y[\"Y-axis (forward) = 0\"]\n        X[\"X-axis (turn) = 100\"]\n    end\n\n    subgraph Calc[\"CALCULATION\"]\n        L[\"Left Motor = 0 + 100 = 100%&lt;br/&gt;(Forward!)\"]\n        R[\"Right Motor = 0 - 100 = -100%&lt;br/&gt;(Backward!)\"]\n    end\n\n    subgraph Result[\"RESULT\"]\n        RES[\"Left forward, right backward&lt;br/&gt;Robot SPINS RIGHT\"]\n    end\n\n    Y --&gt; L\n    Y --&gt; R\n    X --&gt; L\n    X --&gt; R\n    L --&gt; RES\n    R --&gt; RES</code></pre>"},{"location":"04-drive-control/02-arcade-drive/#code-walkthrough-arcade_drive_loop","title":"Code Walkthrough: arcade_drive_loop()","text":"<p>From <code>src/driver_control.py</code>:</p> <pre><code>def arcade_drive_loop():\n    \"\"\"\n    Alternative driver control using arcade drive.\n    \"\"\"\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n    brain.screen.print(\"Arcade Drive Active\")\n\n    while True:\n        # Get joystick positions\n        forward = controller.axis3.position()  # Left Y = forward/back\n        turn = controller.axis4.position()     # Left X = turn\n\n        # Apply deadband\n        forward = deadband(forward, threshold=5)\n        turn = deadband(turn, threshold=5)\n\n        # Calculate motor speeds (arcade mixing)\n        left_speed = forward + turn\n        right_speed = forward - turn\n\n        # Clamp to valid range (-100 to 100)\n        left_speed = max(-100, min(100, left_speed))\n        right_speed = max(-100, min(100, right_speed))\n\n        # Set motor velocities and spin\n        left_motors.set_velocity(left_speed, PERCENT)\n        right_motors.set_velocity(right_speed, PERCENT)\n\n        left_motors.spin(FORWARD)\n        right_motors.spin(FORWARD)\n\n        wait(20, MSEC)\n</code></pre>"},{"location":"04-drive-control/02-arcade-drive/#why-clamp","title":"Why Clamp?","text":"<p>When you push both forward AND turn at the same time, the values can add up beyond 100:</p> <pre><code>Forward = 80, Turn = 50\n\nLeft  = 80 + 50 = 130   \u2190 Over 100!\nRight = 80 - 50 = 30\n\nAfter clamping:\nLeft  = 100  \u2190 Clamped to max\nRight = 30\n</code></pre> <p>Without clamping, motors would receive invalid values!</p>"},{"location":"04-drive-control/02-arcade-drive/#clamping-visualized-number-line-method","title":"Clamping Visualized: Number Line Method","text":"<p>Motors can only accept values from -100 to +100. Here's what clamping does:</p> <pre><code>    THE VALID RANGE:\n\n    -100 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 +100\n      \u2191                                      \u2191\n      \u2502         VALID MOTOR VALUES           \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n    WHAT HAPPENS TO 130?\n\n         100  130\n          \u2193   \u2193\n    \u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2550\u2550\u2550\u00d7\u2500\u2500 \u2192 gets pulled back \u2192 \u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\n          \u2502   \u2502                              \u2502\n          \u2514\u2500\u2500\u2500\u2518                              \u2514\u2500\u2500 Clamped to 100!\n          Too far!\n\n\n    WHAT HAPPENS TO -150?\n\n    -150   -100\n      \u2193     \u2193\n    \u2500\u2500\u00d7\u2550\u2550\u2550\u2550\u2550\u25cf\u2500\u2500\u2500\u2500\u2500\u2500 \u2192 gets pulled back \u2192 \u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\n      \u2502     \u2502                                  \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2518                                  \u2514\u2500\u2500 Clamped to -100!\n      Too far!\n</code></pre>"},{"location":"04-drive-control/02-arcade-drive/#tracing-the-clamp-code","title":"Tracing the Clamp Code","text":"<p>The code <code>max(-100, min(100, left_speed))</code> works in two steps:</p> <pre><code>flowchart TD\n    subgraph Example1[\"EXAMPLE: left_speed = 130\"]\n        A1[\"Input: 130\"] --&gt; B1{Is value &gt; 100?}\n        B1 --&gt;|Yes| C1[\"min(100, 130) = 100\"]\n        C1 --&gt; D1{Is value &lt; -100?}\n        D1 --&gt;|No| E1[\"Result: 100\"]\n    end\n\n    subgraph Example2[\"EXAMPLE: left_speed = -150\"]\n        A2[\"Input: -150\"] --&gt; B2{Is value &gt; 100?}\n        B2 --&gt;|No| C2[\"min(100, -150) = -150\"]\n        C2 --&gt; D2{Is value &lt; -100?}\n        D2 --&gt;|Yes| E2[\"max(-100, -150) = -100\"]\n        E2 --&gt; F2[\"Result: -100\"]\n    end\n\n    subgraph Example3[\"EXAMPLE: left_speed = 75\"]\n        A3[\"Input: 75\"] --&gt; B3{Is value &gt; 100?}\n        B3 --&gt;|No| C3[\"min(100, 75) = 75\"]\n        C3 --&gt; D3{Is value &lt; -100?}\n        D3 --&gt;|No| E3[\"Result: 75 (unchanged)\"]\n    end</code></pre>"},{"location":"04-drive-control/02-arcade-drive/#tank-vs-arcade-comparison","title":"Tank vs. Arcade Comparison","text":"<pre><code>flowchart LR\n    subgraph Tank[\"TANK DRIVE\"]\n        direction LR\n        LY1[\"Left Y-axis\"] --&gt; LM[\"Left Motor\"]\n        RY1[\"Right Y-axis\"] --&gt; RM[\"Right Motor\"]\n    end\n\n    subgraph Arcade[\"ARCADE DRIVE\"]\n        direction LR\n        LY2[\"Left Y-axis\"] --&gt; MIX[\"MIX\"]\n        LX2[\"Left X-axis\"] --&gt; MIX\n        MIX --&gt; Motors[\"Motors\"]\n    end</code></pre> <p>Key Differences: - Tank: Direct mapping, 2 sticks needed, independent control - Arcade: Mixed calculation, 1 stick needed, coordinated control</p> Feature Tank Arcade Sticks used Both One One-handed? No Yes Forward/back Intuitive Intuitive Precise turns Excellent Good Smooth curves Harder Easier Best for Precise maneuvering Smooth driving"},{"location":"04-drive-control/02-arcade-drive/#quick-decision-guide","title":"Quick Decision Guide","text":"<p>Ask yourself these questions to choose the right drive mode:</p> <pre><code>    QUESTION                              ANSWER\n\n    \"Do I need to push against\n     defenders?\"                      \u2192   TANK\n                                          (more precise pivot control)\n\n    \"Am I scoring blocks in goals?\"   \u2192   EITHER\n                                          (depends on driver preference)\n\n    \"Am I new to driving robots?\"     \u2192   ARCADE\n                                          (easier to learn)\n\n    \"Do I want one hand free\n     for buttons?\"                    \u2192   ARCADE\n                                          (only uses left stick)\n\n    \"Am I doing driver skills\n     (solo run)?\"                     \u2192   TANK\n                                          (maximum control authority)\n\n    \"Do I need to spin quickly\n     to block opponents?\"             \u2192   TANK\n                                          (faster pivot response)\n</code></pre>"},{"location":"04-drive-control/02-arcade-drive/#movement-patterns","title":"Movement Patterns","text":""},{"location":"04-drive-control/02-arcade-drive/#forwardbackward-same-as-tank","title":"Forward/Backward (Same as Tank)","text":"<pre><code>    Arcade (Y=100, X=0):         Tank (L=100, R=100):\n\n    Left  = 100 + 0 = 100        Left  = 100\n    Right = 100 - 0 = 100        Right = 100\n\n    Same result!\n</code></pre>"},{"location":"04-drive-control/02-arcade-drive/#turn-in-place","title":"Turn in Place","text":"<pre><code>    Arcade (Y=0, X=100):         Tank (L=100, R=-100):\n\n    Left  = 0 + 100 = 100        Left  = 100\n    Right = 0 - 100 = -100       Right = -100\n\n    Same result!\n</code></pre>"},{"location":"04-drive-control/02-arcade-drive/#arc-turn-where-arcade-shines","title":"Arc Turn (Where Arcade Shines)","text":"<pre><code>    Arcade (Y=60, X=30):         Tank equivalent is harder!\n\n    Left  = 60 + 30 = 90\n    Right = 60 - 30 = 30\n\n    Smooth arc - easy with one stick!\n    In tank drive, you'd need to precisely\n    hold left at 90% and right at 30%.\n</code></pre>"},{"location":"04-drive-control/02-arcade-drive/#switching-between-drive-modes","title":"Switching Between Drive Modes","text":"<p>To switch to arcade drive, modify <code>src/main.py</code>:</p> <pre><code>def main():\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n    brain.screen.print(\"Robot Ready!\")\n\n    wait(500, MSEC)\n\n    # Option 1: Tank drive (default)\n    # driver_control_loop()\n\n    # Option 2: Arcade drive\n    arcade_drive_loop()\n</code></pre> <p>Just uncomment the mode you want!</p>"},{"location":"04-drive-control/02-arcade-drive/#which-should-you-use","title":"Which Should You Use?","text":""},{"location":"04-drive-control/02-arcade-drive/#choose-tank-if","title":"Choose Tank If:","text":"<ul> <li>You need precise maneuvering</li> <li>You're pushing/defending (need to spin in place quickly)</li> <li>Your driver practiced with tank controls</li> <li>You want maximum control authority</li> </ul>"},{"location":"04-drive-control/02-arcade-drive/#choose-arcade-if","title":"Choose Arcade If:","text":"<ul> <li>You want smooth, curved movements</li> <li>Your driver is new to robotics</li> <li>You need one-handed operation (other hand for buttons)</li> <li>You prioritize ease of use</li> </ul>"},{"location":"04-drive-control/02-arcade-drive/#pro-tip-many-teams-use-both","title":"Pro Tip: Many Teams Use Both!","text":"<pre><code>if controller.buttonA.pressing():\n    arcade_drive()\nelse:\n    tank_drive()\n</code></pre>"},{"location":"04-drive-control/02-arcade-drive/#exercise-try-arcade-drive","title":"Exercise: Try Arcade Drive","text":"<p>Step 1: Modify <code>main.py</code> to use <code>arcade_drive_loop()</code> instead of <code>driver_control_loop()</code></p> <p>Step 2: Download and test the robot</p> <p>Step 3: Practice these maneuvers: - Drive in a straight line - Make a U-turn - Drive in a figure-8 pattern - Drive in a circle</p> <p>Step 4: Switch back to tank drive and try the same maneuvers</p> <p>Question: Which felt more natural for you?</p> <p>\u2190 Previous: Tank Drive | Next: Driver Practice \u2192</p>"},{"location":"04-drive-control/03-driver-practice/","title":"Tutorial 4.3: Driver Practice","text":"<p>Time: ~10 minutes Prerequisites: Tutorial 4.2: Arcade Drive</p>"},{"location":"04-drive-control/03-driver-practice/#why-practice-matters","title":"Why Practice Matters","text":"<p>The best robot in the world is useless with an unpracticed driver. Driver skill can be the difference between winning and losing!</p> <pre><code>    Beginner Driver              Practiced Driver\n\n    ~~~~zigzag~~~~&gt;              \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501&gt;\n\n    Overshoots turns             Hits targets precisely\n    Bumps into walls             Smooth movements\n    Slow reactions               Quick reflexes\n</code></pre>"},{"location":"04-drive-control/03-driver-practice/#practice-patterns","title":"Practice Patterns","text":""},{"location":"04-drive-control/03-driver-practice/#pattern-1-the-straight-line","title":"Pattern 1: The Straight Line","text":"<p>Goal: Drive in a perfectly straight line</p> <pre><code>    START                                    END\n      \u25cf\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u25cf\n\n    Set up two markers and drive between them\n    without veering left or right.\n</code></pre> <p>Tips: - Look ahead, not at your robot - Small corrections, not jerky movements - Use tank drive for best straight-line control</p>"},{"location":"04-drive-control/03-driver-practice/#pattern-2-the-square","title":"Pattern 2: The Square","text":"<p>Goal: Drive in a perfect square</p> <pre><code>    \u25cf\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u25cf\n    \u2502          \u2502\n    \u2502          \u2502\n    \u2502          \u2502\n    \u25cf\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u25cf\n\n    Drive forward, turn 90\u00b0, repeat 4 times.\n    End exactly where you started!\n</code></pre> <p>Challenge: Can you make the square with no gaps or overlaps?</p>"},{"location":"04-drive-control/03-driver-practice/#practice-pattern-specifications","title":"Practice Pattern Specifications","text":"<p>Here are the exact dimensions to set up each pattern:</p> <pre><code>    PATTERN 1 - THE STRAIGHT LINE:\n\n    \u25cf\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u25cf\n    START                              END\n\n    Distance: 6 feet (1.8 meters)\n    Goal: End within 3 inches of the centerline\n    Setup: Use tape or cones to mark start and end\n\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n    PATTERN 2 - THE SQUARE:\n\n    \u25cf\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u25cf\n    \u2502          \u2502   Side length: 3 feet (90 cm)\n    \u2502          \u2502   Total distance: 12 feet\n    \u2502          \u2502   Goal: End within 6 inches of start\n    \u25cf\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u25cf\n\n    Setup: Mark 4 corners with tape or small objects\n\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n    PATTERN 3 - THE SLALOM:\n\n         \u25cf           \u25cf           \u25cf\n       \u2571   \u2572       \u2571   \u2572       \u2571   \u2572\n    \u2501\u2501\u25cf\u2501\u2501\u2501\u2501\u2501\u25cf\u2501\u2501\u2501\u2501\u2501\u25cf\u2501\u2501\u2501\u2501\u2501\u25cf\u2501\u2501\u2501\u2501\u2501\u25cf\u2501\u2501\u2501\u2501\u2501\u25cf\u2501\u2501&gt;\n               \u2572       \u2571   \u2572       \u2571\n                \u25cf           \u25cf\n\n    Cone spacing: 2 feet (60 cm) apart\n    Lane width: 2 feet (60 cm) total\n    Number of cones: 5-7\n    Goal: Don't touch any cones!\n\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n    PATTERN 4 - THE FIGURE-8:\n\n         \u256d\u2500\u2500\u2500\u256e\n        \u2571     \u2572      Circle radius: 18 inches (45 cm)\n       \u2502       \u2502     Total distance: ~9 feet\n        \u2572     \u2571      Goal: Smooth curves, no jerky turns\n         \u2573\u2500\u2500\u2500\u2573       Setup: Mark center crossover point\n        \u2571     \u2572\n       \u2502       \u2502\n        \u2572     \u2571\n         \u2570\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"04-drive-control/03-driver-practice/#pattern-3-the-figure-8","title":"Pattern 3: The Figure-8","text":"<p>Goal: Continuous smooth curves</p> <pre><code>         \u256d\u2500\u2500\u2500\u256e\n        \u2571     \u2572\n       \u2502       \u2502\n        \u2572     \u2571\n         \u2573\u2500\u2500\u2500\u2573    \u2190 Cross in the middle\n        \u2571     \u2572\n       \u2502       \u2502\n        \u2572     \u2571\n         \u2570\u2500\u2500\u2500\u256f\n</code></pre> <p>Tips: - Arcade drive works well here - Keep constant speed - Smooth joystick movements</p>"},{"location":"04-drive-control/03-driver-practice/#pattern-4-the-slalom","title":"Pattern 4: The Slalom","text":"<p>Goal: Weave between obstacles</p> <pre><code>         \u25cf           \u25cf           \u25cf\n       \u2571   \u2572       \u2571   \u2572       \u2571   \u2572\n    \u2501\u2501\u25cf\u2501\u2501\u2501\u2501\u2501\u25cf\u2501\u2501\u2501\u2501\u2501\u25cf\u2501\u2501\u2501\u2501\u2501\u25cf\u2501\u2501\u2501\u2501\u2501\u25cf\u2501\u2501\u2501\u2501\u2501\u25cf\u2501\u2501&gt;\n               \u2572       \u2571   \u2572       \u2571\n                \u25cf           \u25cf\n</code></pre> <p>Tips: - Plan your path ahead - Look at the NEXT obstacle, not the current one - Smooth steering inputs</p>"},{"location":"04-drive-control/03-driver-practice/#fine-control-with-curve_input","title":"Fine Control with curve_input()","text":"<p>For precise driving, we can apply a curve to joystick input:</p> <pre><code>def curve_input(value, exponent=2.0):\n    \"\"\"Apply exponential curve for finer control at low speeds.\"\"\"\n    sign = 1 if value &gt;= 0 else -1\n    normalized = abs(value) / 100.0\n    curved = (normalized ** exponent) * 100.0\n    return sign * curved\n</code></pre>"},{"location":"04-drive-control/03-driver-practice/#how-it-helps","title":"How It Helps","text":"<pre><code>    LINEAR INPUT               CURVED INPUT (exponent=2)\n\n    Joystick  Motor            Joystick  Motor\n    25%   \u2192   25%              25%   \u2192   6.25%  \u2190 More precision!\n    50%   \u2192   50%              50%   \u2192   25%\n    75%   \u2192   75%              75%   \u2192   56.25%\n    100%  \u2192   100%             100%  \u2192   100%\n\n    The middle range is                   Small movements\n    equally sensitive                     are much finer\n</code></pre>"},{"location":"04-drive-control/03-driver-practice/#understanding-curve_input-math-complete-breakdown","title":"Understanding curve_input() Math (Complete Breakdown)","text":"<p>The formula might look intimidating, but let's break it down step by step:</p> <pre><code>def curve_input(value, exponent=2.0):\n    sign = 1 if value &gt;= 0 else -1     # Step 1: Remember direction\n    normalized = abs(value) / 100.0     # Step 2: Convert to 0-1 scale\n    curved = (normalized ** exponent) * 100.0  # Step 3: Apply curve\n    return sign * curved                # Step 4: Restore direction\n</code></pre> <p>COMPLETE TRACE: curve_input(50, exponent=2)</p> <pre><code>flowchart TD\n    A[\"INPUT: value = 50, exponent = 2\"] --&gt; B[\"STEP 1: GET THE SIGN\"]\n    B --&gt; C{\"Is 50 &gt;= 0?\"}\n    C --&gt;|YES| D[\"sign = 1 (positive, forward)\"]\n    D --&gt; E[\"STEP 2: NORMALIZE\"]\n    E --&gt; F[\"abs(50) = 50\"]\n    F --&gt; G[\"normalized = 50 / 100.0 = 0.5\"]\n    G --&gt; H[\"STEP 3: APPLY THE CURVE\"]\n    H --&gt; I[\"curved = (0.5 ** 2) * 100.0\"]\n    I --&gt; J[\"= 0.5 \u00d7 0.5 \u00d7 100.0 = 25.0\"]\n    J --&gt; K[\"STEP 4: RESTORE THE SIGN\"]\n    K --&gt; L[\"result = sign \u00d7 curved = 1 \u00d7 25.0 = 25.0\"]\n    L --&gt; M[\"FINAL: 50 \u2192 25 (50% input becomes 25% motor speed)\"]</code></pre> <p>Why each step matters: - Step 1: Remember if joystick was pushed forward (+) or backward (-) before using absolute value - Step 2: Convert joystick range (-100 to +100) to 0-1 scale for easy math - Step 3: Squaring a number less than 1 makes it SMALLER (0.5 \u00d7 0.5 = 0.25) - this gives more precision at low speeds - Step 4: Restore the original direction (positive or negative)</p> <p>COMPLETE TRACE: curve_input(-40, exponent=2)</p> <pre><code>    INPUT: value = -40, exponent = 2\n\n    STEP 1: GET THE SIGN\n    Is -40 &gt;= 0?  NO!\n    sign = -1  (negative, meaning \"backward\")\n\n    STEP 2: NORMALIZE\n    abs(-40) = 40\n    normalized = 40 / 100.0 = 0.4\n\n    STEP 3: APPLY THE CURVE\n    curved = (0.4 ** 2) * 100.0\n           = (0.4 \u00d7 0.4) * 100.0\n           = 0.16 * 100.0\n           = 16.0\n\n    STEP 4: RESTORE THE SIGN\n    result = -1 * 16.0\n           = -16.0\n\n    FINAL ANSWER: -40 \u2192 -16\n    (40% backward becomes 16% backward)\n</code></pre> <p>WHY PRESERVING SIGN MATTERS</p> <pre><code>    WITHOUT preserving sign:\n    (-40)^2 = 1600  \u2190 WRONG! (positive and way too big)\n\n    WITH preserving sign:\n    abs(-40) = 40\n    (0.4)^2 = 0.16\n    0.16 \u00d7 100 = 16\n    -1 \u00d7 16 = -16  \u2190 CORRECT! (negative and right size)\n</code></pre>"},{"location":"04-drive-control/03-driver-practice/#visual-comparison-linear-vs-curved","title":"Visual Comparison: Linear vs Curved","text":"<pre><code>    WITHOUT CURVE (exponent = 1):\n\n    Output\n    100% \u2502                        \u25cf\n         \u2502                   \u25cf\n         \u2502              \u25cf\n         \u2502         \u25cf\n         \u2502    \u25cf\n       0 \u2514\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Input\n              0    25   50   75  100%\n\n    Everything is proportional: 50% \u2192 50%\n\n\n    WITH CURVE (exponent = 2):\n\n    Output\n    100% \u2502                        \u25cf\n         \u2502                   \u25cf\n         \u2502              \u25cf\n         \u2502         \u25cf\n         \u2502    \u25cf\n       0 \u2514\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Input\n              0    25   50   75  100%\n                   \u2193    \u2193    \u2193\n                  6%   25%  56%\n\n    Low inputs are \"squished\" down for finer control!\n</code></pre>"},{"location":"04-drive-control/03-driver-practice/#adding-curve-to-drive-code","title":"Adding Curve to Drive Code","text":"<pre><code>def driver_control_with_curve():\n    while True:\n        left_speed = controller.axis3.position()\n        right_speed = controller.axis2.position()\n\n        # Apply deadband\n        left_speed = deadband(left_speed)\n        right_speed = deadband(right_speed)\n\n        # Apply curve for finer control\n        left_speed = curve_input(left_speed, exponent=2.0)\n        right_speed = curve_input(right_speed, exponent=2.0)\n\n        left_motors.spin(FORWARD, left_speed, PERCENT)\n        right_motors.spin(FORWARD, right_speed, PERCENT)\n\n        wait(20, MSEC)\n</code></pre>"},{"location":"04-drive-control/03-driver-practice/#competition-driving-tips","title":"Competition Driving Tips","text":""},{"location":"04-drive-control/03-driver-practice/#before-the-match","title":"Before the Match","text":"<ol> <li>Check controller battery - Dead controller = dead robot</li> <li>Test all buttons - Make sure everything works</li> <li>Warm up your hands - Cold fingers are slow fingers</li> <li>Watch your opponents - Know their robot's capabilities</li> </ol>"},{"location":"04-drive-control/03-driver-practice/#during-driver-control","title":"During Driver Control","text":"<ol> <li>Know your field - Where are the goals? Where are the blocks?</li> <li>Communicate - Your partner is your teammate!</li> <li>Don't panic - Smooth is fast, jerky is slow</li> <li>Watch the clock - Know when to rush, when to be careful</li> </ol>"},{"location":"04-drive-control/03-driver-practice/#push-back-specific-tips","title":"Push Back Specific Tips","text":"<pre><code>    SCORING PRIORITY:\n\n    1. Blocks in goals (3 pts each)\n    2. Zone control (6-10 pts)\n    3. PARKING (8 or 30 pts!) \u2190 Don't forget!\n\n    In the last 10 seconds:\n    - Stop scoring blocks\n    - Get to the parking zone!\n    - Two robots parked = 30 points!\n</code></pre>"},{"location":"04-drive-control/03-driver-practice/#push-back-driving-scenarios","title":"Push Back Driving Scenarios","text":"<p>Let's walk through specific situations you'll face in competition:</p> <p>SCENARIO 1: Approaching a Goal to Score</p> <pre><code>    You're 3 feet from the goal with a block.\n\n    WRONG APPROACH:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  Full speed ahead \u2192 overshoot!              \u2502\n    \u2502  Block falls out of robot or misses goal   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    RIGHT APPROACH (with curve_input):\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  1. Start at 50% stick \u2192 25% motor speed    \u2502\n    \u2502     (smooth acceleration)                   \u2502\n    \u2502                                             \u2502\n    \u2502  2. Slow to 25% stick \u2192 6% motor speed      \u2502\n    \u2502     (precision placement)                   \u2502\n    \u2502                                             \u2502\n    \u2502  3. Gently push block into goal             \u2502\n    \u2502                                             \u2502\n    \u2502  4. Back away slowly                        \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    The curve gives you fine control when it matters most!\n</code></pre> <p>SCENARIO 2: Defending Your Zone</p> <pre><code>    Opponent is trying to descore your blocks.\n\n    TANK DRIVE ADVANTAGE:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  Pivot turns are FAST with tank drive!      \u2502\n    \u2502                                             \u2502\n    \u2502  Left stick UP + Right stick DOWN:          \u2502\n    \u2502                                             \u2502\n    \u2502         \u21bb                                   \u2502\n    \u2502        \u2571 \u2572                                  \u2502\n    \u2502       \u2502 \u25cf \u2502  \u2190 You spin to block opponent  \u2502\n    \u2502        \u2572 \u2571                                  \u2502\n    \u2502         \u21ba                                   \u2502\n    \u2502                                             \u2502\n    \u2502  You can react to their movement instantly! \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    This is why many teams use tank for defense.\n</code></pre> <p>SCENARIO 3: Parking with 10 Seconds Left</p> <pre><code>    The clock shows 0:10 remaining!\n\n    PRIORITY ORDER:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  1. COMMUNICATE: Yell \"PARKING NOW!\" to     \u2502\n    \u2502     your partner                            \u2502\n    \u2502                                             \u2502\n    \u2502  2. ABANDON current task - don't finish     \u2502\n    \u2502     that block you were scoring             \u2502\n    \u2502                                             \u2502\n    \u2502  3. DRIVE DIRECTLY to park zone             \u2502\n    \u2502     (shortest path, ignore everything)      \u2502\n    \u2502                                             \u2502\n    \u2502  4. FIT BOTH ROBOTS:                        \u2502\n    \u2502                                             \u2502\n    \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                       \u2502\n    \u2502     \u2502 \u250c\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2510  \u2502 \u2190 Park zone           \u2502\n    \u2502     \u2502 \u2502 R1\u2502  \u2502 R2\u2502  \u2502   (18\" \u00d7 16\")         \u2502\n    \u2502     \u2502 \u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2518  \u2502                       \u2502\n    \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                       \u2502\n    \u2502                                             \u2502\n    \u2502  5. STOP MOVING before buzzer!              \u2502\n    \u2502     (movement at buzzer = NOT parked)       \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    POINTS COMPARISON:\n    - 0 robots parked: 0 points\n    - 1 robot parked: 8 points\n    - 2 robots parked: 30 points (!!)\n\n    The 30-point bonus is HUGE - it can win matches!\n</code></pre> <p>SCENARIO 4: Recovering from a Tip</p> <pre><code>    Your robot has tipped onto its side!\n\n    DON'T PANIC:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  1. Check if your wheels can touch ground   \u2502\n    \u2502                                             \u2502\n    \u2502  2. If wheels touch: Try driving to         \u2502\n    \u2502     flip yourself back over                 \u2502\n    \u2502                                             \u2502\n    \u2502  3. If wheels don't touch: Signal partner   \u2502\n    \u2502     for help (they can push you back up)    \u2502\n    \u2502                                             \u2502\n    \u2502  4. If you're stuck: Focus on PARKING       \u2502\n    \u2502     at match end - even a tipped robot      \u2502\n    \u2502     in the zone counts!                     \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"04-drive-control/03-driver-practice/#controller-button-layout","title":"Controller Button Layout","text":"<p>Plan your button assignments:</p> <pre><code>    SUGGESTED LAYOUT:\n\n    [L1] = Intake In         [R1] = Turbo Mode\n    [L2] = Intake Out        [R2] = Slow Mode\n\n    +------+                  +------+\n    | LEFT |                  | RIGHT|\n    | STICK|    [A] Unused    | STICK|\n    | Drive|    [B] Unused    | (Tank)|\n    +------+    [X] Reverse   +------+\n                [Y] Toggle Mode\n</code></pre> <p>Document your layout in a comment:</p> <pre><code># BUTTON ASSIGNMENTS:\n# L1 = Intake forward\n# L2 = Intake reverse\n# R1 = Turbo mode (1.5x speed)\n# R2 = Slow mode (0.5x speed)\n# X  = Reverse direction\n</code></pre>"},{"location":"04-drive-control/03-driver-practice/#exercise-tune-your-drive-feel","title":"Exercise: Tune Your Drive Feel","text":"<p>Goal: Experiment with curve exponent to find your preference</p> <p>Step 1: Add <code>curve_input()</code> to your driver control:</p> <pre><code>left_speed = curve_input(left_speed, exponent=2.0)\nright_speed = curve_input(right_speed, exponent=2.0)\n</code></pre> <p>Step 2: Try different exponent values: - <code>1.0</code> = Linear (no curve) - <code>2.0</code> = Squared (default, good for most) - <code>3.0</code> = Cubed (very fine control at low speed) - <code>1.5</code> = Mild curve</p> <p>Step 3: Test with the slalom pattern</p> <p>Question: What exponent gives you the best control?</p>"},{"location":"04-drive-control/03-driver-practice/#timed-challenges","title":"Timed Challenges","text":"<p>Set up these challenges and time yourself:</p>"},{"location":"04-drive-control/03-driver-practice/#challenge-1-speed-run","title":"Challenge 1: Speed Run","text":"<ul> <li>Set up two cones 3 meters apart</li> <li>Drive from one to the other and back</li> <li>Best time wins!</li> </ul>"},{"location":"04-drive-control/03-driver-practice/#challenge-2-precision-park","title":"Challenge 2: Precision Park","text":"<ul> <li>Set up a small box (slightly larger than your robot)</li> <li>Park inside the box as fast as possible</li> <li>Touching the walls = 5 second penalty</li> </ul>"},{"location":"04-drive-control/03-driver-practice/#challenge-3-block-push","title":"Challenge 3: Block Push","text":"<ul> <li>Place a block on the field</li> <li>Push it into a goal</li> <li>Don't let it fall out!</li> </ul> <p>Ready to test your knowledge? Check out the Drive Control Q&amp;A Review!</p> <p>\u2190 Previous: Arcade Drive | Next: Autonomous \u2192 | Review Q&amp;A</p>"},{"location":"04-drive-control/04-review-qa/","title":"Drive Control Q&amp;A Review","text":"<p>Purpose: Test your understanding of VEX V5 drive control concepts How to Use: Answer each question, then check your answers in the Answer Key at the end Total Questions: 70</p>"},{"location":"04-drive-control/04-review-qa/#section-1-controller-basics-15-questions","title":"Section 1: Controller Basics (15 Questions)","text":""},{"location":"04-drive-control/04-review-qa/#conceptual-questions","title":"Conceptual Questions","text":"<p>Q1. What range of values can <code>axis3.position()</code> return?</p> <p>Q2. Which axis number corresponds to the LEFT joystick's up-down movement?</p> <p>Q3. Which axis number corresponds to the RIGHT joystick's up-down movement?</p> <p>Q4. What does the constant <code>FORWARD</code> mean in <code>motor.spin(FORWARD, 50, PERCENT)</code>?</p> <p>Q5. What does <code>MSEC</code> stand for, and how many milliseconds are in 1 second?</p> <p>Q6. A joystick at rest shows value 3 instead of 0. What is this called, and why does it happen?</p> <p>Q7. What value does <code>axis3</code> return when the left joystick is pushed all the way UP?</p> <p>Q8. What value does <code>axis3</code> return when the left joystick is pushed all the way DOWN?</p> <p>Q9. What does <code>PERCENT</code> mean when used with motor speed?</p> <p>Q10. In <code>wait(20, MSEC)</code>, how many times per second does the loop run?</p>"},{"location":"04-drive-control/04-review-qa/#code-tracing-questions","title":"Code Tracing Questions","text":"<p>Q11. What direction will the motor spin? <pre><code>left_motors.spin(FORWARD, -50, PERCENT)\n</code></pre></p> <p>Q12. What is the output of this code if the joystick returns 75? <pre><code>speed = controller.axis3.position()  # Returns 75\nbrain.screen.print(speed)\n</code></pre></p> <p>Q13. If <code>axis4.position()</code> returns -30, which direction is the left joystick pushed?</p> <p>Q14. What does \"normalized\" mean in the context of joystick values?</p> <p>Q15. Calculate: What is |\u221275|? (absolute value)</p>"},{"location":"04-drive-control/04-review-qa/#section-2-tank-drive-15-questions","title":"Section 2: Tank Drive (15 Questions)","text":""},{"location":"04-drive-control/04-review-qa/#conceptual-questions_1","title":"Conceptual Questions","text":"<p>Q16. In tank drive, which joystick controls the RIGHT motors?</p> <p>Q17. In tank drive, which joystick controls the LEFT motors?</p> <p>Q18. How do you make a robot spin LEFT in place using tank drive?</p> <p>Q19. How do you make a robot spin RIGHT in place using tank drive?</p> <p>Q20. What happens if you push both sticks UP equally in tank drive?</p> <p>Q21. What happens if you push both sticks DOWN equally in tank drive?</p> <p>Q22. What is deadband and why is it needed?</p> <p>Q23. Name TWO advantages of tank drive.</p> <p>Q24. Name TWO disadvantages of tank drive.</p> <p>Q25. Why is there a <code>wait(20, MSEC)</code> at the end of the drive loop?</p>"},{"location":"04-drive-control/04-review-qa/#code-tracing-questions_1","title":"Code Tracing Questions","text":"<p>Q26. Trace: What does <code>deadband(4, threshold=5)</code> return?</p> <p>Q27. Trace: What does <code>deadband(-50, threshold=5)</code> return?</p> <p>Q28. Trace: What does <code>deadband(5, threshold=5)</code> return?</p> <p>Q29. In this code, what happens when axis3 = 100 and axis2 = -100? <pre><code>left_speed = controller.axis3.position()   # 100\nright_speed = controller.axis2.position()  # -100\nleft_motors.spin(FORWARD, left_speed, PERCENT)\nright_motors.spin(FORWARD, right_speed, PERCENT)\n</code></pre></p> <p>Q30. What movement pattern results when axis3 = 80 and axis2 = 40?</p>"},{"location":"04-drive-control/04-review-qa/#section-3-arcade-drive-15-questions","title":"Section 3: Arcade Drive (15 Questions)","text":""},{"location":"04-drive-control/04-review-qa/#conceptual-questions_2","title":"Conceptual Questions","text":"<p>Q31. In arcade drive, which joystick controls EVERYTHING?</p> <p>Q32. In arcade drive, what does the Y-axis (axis3) control?</p> <p>Q33. In arcade drive, what does the X-axis (axis4) control?</p> <p>Q34. Write the arcade mixing formula for LEFT motor speed.</p> <p>Q35. Write the arcade mixing formula for RIGHT motor speed.</p> <p>Q36. Why is the turn value SUBTRACTED for the right motor?</p> <p>Q37. What is clamping and why is it needed in arcade drive?</p> <p>Q38. How do you drive STRAIGHT FORWARD in arcade drive?</p> <p>Q39. How do you SPIN IN PLACE to the right with arcade drive?</p> <p>Q40. Name TWO advantages of arcade drive over tank drive.</p>"},{"location":"04-drive-control/04-review-qa/#calculation-questions","title":"Calculation Questions","text":"<p>Q41. Calculate: forward=80, turn=0. What are the left and right motor speeds?</p> <p>Q42. Calculate: forward=0, turn=50. What are the left and right motor speeds?</p> <p>Q43. Calculate: forward=60, turn=30. What are the left and right motor speeds?</p> <p>Q44. Calculate: forward=80, turn=50. What are the motor speeds BEFORE clamping?</p> <p>Q45. Calculate: forward=80, turn=50. What are the motor speeds AFTER clamping?</p>"},{"location":"04-drive-control/04-review-qa/#code-tracing-questions_2","title":"Code Tracing Questions","text":"<p>Q46. Code trace: What is <code>max(-100, min(100, 130))</code>?</p> <p>Q47. Code trace: What is <code>max(-100, min(100, -150))</code>?</p> <p>Q48. Code trace: What is <code>max(-100, min(100, 75))</code>?</p> <p>Q49. In this scenario, which direction does the robot curve? <pre><code>forward = 70, turn = 25\nleft_speed = 70 + 25 = 95\nright_speed = 70 - 25 = 45\n</code></pre></p> <p>Q50. What happens if you set forward=100 and turn=100 without clamping?</p>"},{"location":"04-drive-control/04-review-qa/#section-4-driver-practice-tuning-15-questions","title":"Section 4: Driver Practice &amp; Tuning (15 Questions)","text":""},{"location":"04-drive-control/04-review-qa/#conceptual-questions_3","title":"Conceptual Questions","text":"<p>Q51. What is <code>curve_input()</code> used for?</p> <p>Q52. What does \"normalized\" mean in the curve_input formula?</p> <p>Q53. Why do we preserve the sign separately in curve_input()?</p> <p>Q54. What exponent gives LINEAR response (no curve)?</p> <p>Q55. Which exponent gives MORE precision at low speeds: 2 or 3?</p> <p>Q56. Name the four practice patterns covered in the tutorial.</p> <p>Q57. What should you check BEFORE every match?</p> <p>Q58. In Push Back, how many points for BOTH robots parked?</p> <p>Q59. In Push Back, how many points for ONE robot parked?</p> <p>Q60. What is the recommended cone spacing for the slalom pattern?</p>"},{"location":"04-drive-control/04-review-qa/#code-tracing-questions-step-by-step","title":"Code Tracing Questions (Step-by-Step)","text":"<p>Q61. Trace <code>curve_input(50, exponent=2)</code> step by step: - Step 1: What is sign? - Step 2: What is normalized? - Step 3: What is curved? - Step 4: What is the final return value?</p> <p>Q62. Trace <code>curve_input(-40, exponent=2)</code> step by step: - Step 1: What is sign? - Step 2: What is normalized? - Step 3: What is curved? - Step 4: What is the final return value?</p> <p>Q63. Trace <code>curve_input(100, exponent=2)</code>: - What is the final return value?</p> <p>Q64. With exponent=2, what is the output for input=25?</p> <p>Q65. With exponent=3, what is the output for input=50?</p>"},{"location":"04-drive-control/04-review-qa/#section-5-competition-application-10-questions","title":"Section 5: Competition Application (10 Questions)","text":""},{"location":"04-drive-control/04-review-qa/#decision-making-questions","title":"Decision-Making Questions","text":"<p>Q66. You're defending your zone. Tank or arcade? Why?</p> <p>Q67. You're a new driver learning to score. Tank or arcade? Why?</p> <p>Q68. The clock shows 0:10 remaining. What should you prioritize?</p> <p>Q69. Your joystick drifts at value 8. What deadband threshold should you use?</p> <p>Q70. Your robot is too sensitive at low speeds. What should you adjust?</p>"},{"location":"04-drive-control/04-review-qa/#quick-reference-tables","title":"Quick Reference Tables","text":""},{"location":"04-drive-control/04-review-qa/#drive-mode-selection","title":"Drive Mode Selection","text":"Situation Recommended Mode Reason Defense Tank Precise pivot turns Scoring Either Driver preference New driver Arcade Easier to learn Skills run Tank Maximum control Button-heavy tasks Arcade Free hand available"},{"location":"04-drive-control/04-review-qa/#axis-reference","title":"Axis Reference","text":"Axis Stick Direction Common Use axis1 Right Left/Right Not used in basic drive axis2 Right Up/Down Tank: right motors axis3 Left Up/Down Both modes: forward/back axis4 Left Left/Right Arcade: turning"},{"location":"04-drive-control/04-review-qa/#curve-input-reference","title":"Curve Input Reference","text":"Input Exponent 1.0 Exponent 2.0 Exponent 3.0 25% 25% 6.25% 1.56% 50% 50% 25% 12.5% 75% 75% 56.25% 42.19% 100% 100% 100% 100%"},{"location":"04-drive-control/04-review-qa/#answer-key","title":"Answer Key","text":""},{"location":"04-drive-control/04-review-qa/#section-1-controller-basics","title":"Section 1: Controller Basics","text":"<p>A1. Numbers from -100 to +100. Full up = +100, full down = -100, center = 0.</p> <p>A2. axis3</p> <p>A3. axis2</p> <p>A4. FORWARD is a direction reference, NOT a command. When speed is positive, motor spins forward. When speed is negative, motor spins backward. It means \"follow the sign of the number.\"</p> <p>A5. MSEC = milliseconds. 1000 milliseconds = 1 second.</p> <p>A6. This is called \"joystick drift.\" It happens because: - Springs inside wear out over time - Manufacturing tolerance variations - Temperature affects sensors This is why we use deadband to ignore small values.</p> <p>A7. +100</p> <p>A8. -100</p> <p>A9. PERCENT means \"out of 100\" - it's the unit for motor speed. 100 PERCENT = maximum speed, 50 PERCENT = half speed.</p> <p>A10. 50 times per second. (1000 ms \u00f7 20 ms = 50 Hz)</p> <p>A11. The motor spins BACKWARD at 50% speed. FORWARD with a negative number reverses direction.</p> <p>A12. It prints: 75</p> <p>A13. LEFT. Negative X-axis values mean the stick is pushed left.</p> <p>A14. Converting a value to the 0-1 range by dividing by the maximum. Example: 50/100 = 0.5 normalized.</p> <p>A15. 75. Absolute value removes the negative sign.</p>"},{"location":"04-drive-control/04-review-qa/#section-2-tank-drive","title":"Section 2: Tank Drive","text":"<p>A16. The RIGHT joystick (axis2)</p> <p>A17. The LEFT joystick (axis3)</p> <p>A18. Push left stick DOWN and right stick UP. - Left motors: backward (-100) - Right motors: forward (+100) - Robot pivots counter-clockwise (left)</p> <p>A19. Push left stick UP and right stick DOWN. - Left motors: forward (+100) - Right motors: backward (-100) - Robot pivots clockwise (right)</p> <p>A20. The robot drives FORWARD in a straight line. Both sides receive equal positive speed.</p> <p>A21. The robot drives BACKWARD in a straight line. Both sides receive equal negative speed.</p> <p>A22. Deadband is a zone around zero where small joystick values are ignored (treated as 0). Why needed: - Joysticks are never perfectly centered - Without deadband, motors creep slowly when untouched - Typical threshold: 5 (values -5 to +5 become 0)</p> <p>A23. Any two of: - Precise turning (independent control of each side) - Simple to understand (one stick = one side) - Easy to code (just read two axes) - Good for pivot turns</p> <p>A24. Any two of: - Requires both hands (can't drive one-handed) - Harder to drive smooth curves - Can be jerky (small stick differences cause wobble)</p> <p>A25. Two reasons: 1. Prevents CPU overload (brain can do other tasks) 2. 20ms = 50 updates/second, which is smooth enough Without wait, loop runs thousands of times per second, wasting power.</p> <p>A26. Returns 0. Trace: Is |4| &lt; 5? Is 4 &lt; 5? YES. Return 0.</p> <p>A27. Returns -50. Trace: Is |-50| &lt; 5? Is 50 &lt; 5? NO. Return original: -50.</p> <p>A28. Returns 5. Trace: Is |5| &lt; 5? Is 5 &lt; 5? NO (5 equals 5, not less than). Return original: 5.</p> <p>A29. Robot spins RIGHT in place. - Left motors: forward at 100% - Right motors: backward at 100%</p> <p>A30. Arc turn to the RIGHT. - Left side moves faster (80%) - Right side moves slower (40%) - Robot curves right while moving forward</p>"},{"location":"04-drive-control/04-review-qa/#section-3-arcade-drive","title":"Section 3: Arcade Drive","text":"<p>A31. The LEFT joystick only (axis3 for Y, axis4 for X)</p> <p>A32. Forward/backward movement</p> <p>A33. Turning left/right</p> <p>A34. Left Motor Speed = Forward + Turn <pre><code>left_speed = forward + turn\n</code></pre></p> <p>A35. Right Motor Speed = Forward - Turn <pre><code>right_speed = forward - turn\n</code></pre></p> <p>A36. To make the robot turn in the correct direction! When turning right (turn = +50): - Left motor = forward + 50 (goes faster) - Right motor = forward - 50 (goes slower) - Left faster than right = robot curves RIGHT</p> <p>A37. Clamping limits values to a valid range (-100 to +100). Why needed: - When forward AND turn are both high, they can add up past 100 - Example: 80 + 50 = 130 (invalid!) - Motors can only accept -100 to +100</p> <p>A38. Push joystick straight UP (Y-axis only, no X). When turn = 0: Left = forward + 0, Right = forward - 0, both equal.</p> <p>A39. Push joystick RIGHT only (X-axis, no Y). turn = 100, forward = 0: - Left = 0 + 100 = 100 - Right = 0 - 100 = -100 - Left forward, right backward = spin right</p> <p>A40. Any two of: - Smoother curves (easier to control arcs) - One stick = easier to learn - One-handed operation (free hand for buttons) - More intuitive for video game players</p> <p>A41. Left = 80 + 0 = 80, Right = 80 - 0 = 80. Robot goes straight forward.</p> <p>A42. Left = 0 + 50 = 50, Right = 0 - 50 = -50. Robot spins right in place.</p> <p>A43. Left = 60 + 30 = 90, Right = 60 - 30 = 30. Robot curves right.</p> <p>A44. Left = 80 + 50 = 130, Right = 80 - 50 = 30. (Before clamping)</p> <p>A45. Left = 100 (clamped from 130), Right = 30. Robot curves right at different speeds.</p> <p>A46. Returns 100. Trace: min(100, 130) = 100, then max(-100, 100) = 100.</p> <p>A47. Returns -100. Trace: min(100, -150) = -150, then max(-100, -150) = -100.</p> <p>A48. Returns 75. Trace: min(100, 75) = 75, then max(-100, 75) = 75. No clamping needed.</p> <p>A49. Robot curves RIGHT. Left side (95) goes faster than right side (45).</p> <p>A50. Left = 200, Right = 0. The value 200 is invalid for motors (max is 100). This would cause unpredictable behavior.</p>"},{"location":"04-drive-control/04-review-qa/#section-4-driver-practice-tuning","title":"Section 4: Driver Practice &amp; Tuning","text":"<p>A51. To give more precise control at low speeds. Small joystick movements produce even smaller motor outputs.</p> <p>A52. Converting the absolute value to a 0-1 range by dividing by 100. normalized = abs(value) / 100.0</p> <p>A53. Because exponents can mess up negative numbers! (-50)^2 = 2500 (positive - wrong!) We take abs() first, curve it, then restore the sign.</p> <p>A54. exponent = 1.0. With x^1 = x, output equals input. No curve.</p> <p>A55. exponent = 3 gives MORE precision. With exponent=2: 25% \u2192 6.25% With exponent=3: 25% \u2192 1.56% Higher exponent = more aggressive curve.</p> <p>A56. 1. The Straight Line 2. The Square 3. The Figure-8 4. The Slalom</p> <p>A57. 1. Controller battery level 2. Test all buttons work 3. Warm up your hands 4. Watch opponents' robots</p> <p>A58. 30 points! (This is a huge bonus - always try to double-park!)</p> <p>A59. 8 points</p> <p>A60. 2 feet (60 cm) between cones</p> <p>A61. Trace of <code>curve_input(50, exponent=2)</code>: - Step 1: sign = 1 (50 is positive) - Step 2: normalized = 50/100 = 0.5 - Step 3: curved = (0.5)^2 \u00d7 100 = 0.25 \u00d7 100 = 25 - Step 4: return 1 \u00d7 25 = 25</p> <p>A62. Trace of <code>curve_input(-40, exponent=2)</code>: - Step 1: sign = -1 (-40 is negative) - Step 2: normalized = 40/100 = 0.4 - Step 3: curved = (0.4)^2 \u00d7 100 = 0.16 \u00d7 100 = 16 - Step 4: return -1 \u00d7 16 = -16</p> <p>A63. Returns 100. 100/100 = 1.0, (1.0)^2 = 1.0, 1.0 \u00d7 100 = 100.</p> <p>A64. 6.25% 25/100 = 0.25, (0.25)^2 = 0.0625, \u00d7 100 = 6.25</p> <p>A65. 12.5% 50/100 = 0.5, (0.5)^3 = 0.125, \u00d7 100 = 12.5</p>"},{"location":"04-drive-control/04-review-qa/#section-5-competition-application","title":"Section 5: Competition Application","text":"<p>A66. TANK drive is better for defense. Reason: Pivot turns are faster and more controlled. You can spin rapidly in place to block opponents with independent stick control.</p> <p>A67. ARCADE drive is better for beginners. Reasons: - Smoother curves (easier to approach goals) - One stick = easier to learn - Free hand for buttons if needed</p> <p>A68. PARKING! - Stop scoring blocks - Drive directly to park zone - Coordinate with partner for double-park (30 pts!) - Stop moving before time ends</p> <p>A69. Use threshold=10 or higher. The deadband must be larger than the drift value. 8 &lt; 10, so values of 8 will become 0.</p> <p>A70. Increase the curve exponent (e.g., from 2.0 to 2.5 or 3.0). Higher exponent = more aggressive curve = smaller outputs for small inputs.</p> <p>\u2190 Previous: Driver Practice | Next: Autonomous \u2192</p>"},{"location":"05-autonomous/01-basic-movements/","title":"Tutorial 5.1: Basic Autonomous Movements","text":"<p>Time: ~15 minutes Prerequisites: Tutorial 4: Drive Control</p>"},{"location":"05-autonomous/01-basic-movements/#what-is-autonomous","title":"What is Autonomous?","text":"<p>During the first 15 seconds of a VEX match, no human control is allowed. Your robot must execute pre-programmed movements on its own!</p> <pre><code>flowchart LR\n    subgraph Autonomous [\"Autonomous (0-15s)\"]\n        A1[Programmed code runs]\n        A2[No human control]\n    end\n    subgraph Driver [\"Driver Control (15s-2min)\"]\n        D1[Human driver takes over]\n        D2[Full controller access]\n    end\n    Autonomous --&gt; Driver</code></pre>"},{"location":"05-autonomous/01-basic-movements/#the-drivetrain-commands","title":"The DriveTrain Commands","text":""},{"location":"05-autonomous/01-basic-movements/#drive_for-move-forwardbackward","title":"drive_for() - Move Forward/Backward","text":"<pre><code># Drive forward 500mm\ndrivetrain.drive_for(FORWARD, 500, MM)\n\n# Drive backward 300mm\ndrivetrain.drive_for(REVERSE, 300, MM)\n\n# Drive forward 12 inches\ndrivetrain.drive_for(FORWARD, 12, INCHES)\n</code></pre> <p>Parameters:</p> Parameter Options What It Does Direction <code>FORWARD</code>, <code>REVERSE</code> Which way to move Distance Number How far to travel Units <code>MM</code>, <code>INCHES</code> What unit for distance"},{"location":"05-autonomous/01-basic-movements/#turn_for-rotate-in-place","title":"turn_for() - Rotate in Place","text":"<pre><code># Turn right 90 degrees\ndrivetrain.turn_for(RIGHT, 90, DEGREES)\n\n# Turn left 45 degrees\ndrivetrain.turn_for(LEFT, 45, DEGREES)\n\n# Full 180\u00b0 turn\ndrivetrain.turn_for(RIGHT, 180, DEGREES)\n</code></pre> <pre><code>    TURNING VISUALIZED:\n\n    Before:                After turn_for(RIGHT, 90):\n\n       \u2191                          \u2192\n    +-----+                    +-----+\n    |     |                    |     |\n    +-----+                    +-----+\n</code></pre>"},{"location":"05-autonomous/01-basic-movements/#code-walkthrough-autonomouspy","title":"Code Walkthrough: autonomous.py","text":"<pre><code>def setup_autonomous():\n    \"\"\"Configure drivetrain settings for autonomous mode.\"\"\"\n    drivetrain.set_drive_velocity(50, PERCENT)  # Movement speed\n    drivetrain.set_turn_velocity(30, PERCENT)   # Turn speed\n    drivetrain.set_stopping(BRAKE)               # How to stop\n    drivetrain.set_timeout(3, SECONDS)           # Max time per move\n\ndef autonomous_routine():\n    \"\"\"Main 15-second autonomous routine.\"\"\"\n    brain.screen.print(\"Autonomous Started\")\n\n    setup_autonomous()\n\n    # Example moves (replace with your strategy):\n    drivetrain.drive_for(FORWARD, 500, MM)\n    wait(200, MSEC)\n\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    wait(200, MSEC)\n\n    drivetrain.drive_for(FORWARD, 300, MM)\n    wait(200, MSEC)\n\n    brain.screen.print(\"Autonomous Complete\")\n</code></pre>"},{"location":"05-autonomous/01-basic-movements/#understanding-set_timeout","title":"Understanding set_timeout()","text":"<p>What if your robot gets stuck? <code>set_timeout()</code> prevents infinite waiting:</p> <pre><code>drivetrain.set_timeout(3, SECONDS)  # Max 3 seconds per move\n\n# If drive_for takes longer than 3 seconds,\n# the robot gives up and moves to the next command\ndrivetrain.drive_for(FORWARD, 1000, MM)  # Will stop after 3 sec if stuck\n</code></pre> <pre><code>flowchart TD\n    subgraph without[\"Without Timeout\"]\n        A1[\"drive_for(1000mm)\"] --&gt; B1[\"Robot stuck!\"]\n        B1 --&gt; C1[\"Waits forever...\"]\n        C1 --&gt; D1[\"NEVER CONTINUES\"]\n    end\n\n    subgraph with[\"With Timeout (3 seconds)\"]\n        A2[\"drive_for(1000mm)\"] --&gt; B2[\"Robot stuck!\"]\n        B2 --&gt; C2{\"3 seconds pass\"}\n        C2 --&gt; D2[\"Continues to next command!\"]\n    end</code></pre>"},{"location":"05-autonomous/01-basic-movements/#stopping-modes","title":"Stopping Modes","text":"<pre><code>drivetrain.set_stopping(COAST)  # Free-spin to stop\ndrivetrain.set_stopping(BRAKE)  # Active braking (recommended)\ndrivetrain.set_stopping(HOLD)   # Hold position firmly\n</code></pre> <pre><code>    COAST                BRAKE                HOLD\n\n    \u27f3 \u2192 \u27f3 \u2192 \u27f3 \u2192 stop     \u27f3 \u2192 \u27f3 \u2192 X           \u27f3 \u2192 X (locked!)\n    Slowly coasts        Quick stop           Resists movement\n    Good for: speed      Good for: accuracy   Good for: holding\n</code></pre>"},{"location":"05-autonomous/01-basic-movements/#driving-a-square-pattern","title":"Driving a Square Pattern","text":"<p>Here's how to drive a square:</p> <pre><code>def drive_square():\n    setup_autonomous()\n\n    for i in range(4):  # Repeat 4 times\n        drivetrain.drive_for(FORWARD, 500, MM)\n        wait(200, MSEC)\n        drivetrain.turn_for(RIGHT, 90, DEGREES)\n        wait(200, MSEC)\n</code></pre> <pre><code>    Square Pattern:\n\n    START/END\n        \u25cf\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u25cf\n        \u2502         \u2502\n        \u2502         \u2502   Each side: 500mm\n        \u2502         \u2502   Each turn: 90\u00b0\n        \u25cf\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u25cf\n</code></pre>"},{"location":"05-autonomous/01-basic-movements/#why-wait-between-moves","title":"Why wait() Between Moves?","text":"<p>Without <code>wait()</code>, the robot might not fully stop before starting the next move:</p> <pre><code># WITHOUT wait - robot might drift\ndrivetrain.drive_for(FORWARD, 500, MM)\ndrivetrain.turn_for(RIGHT, 90, DEGREES)  # Might start before fully stopped!\n\n# WITH wait - robot stabilizes\ndrivetrain.drive_for(FORWARD, 500, MM)\nwait(200, MSEC)  # 0.2 seconds to settle\ndrivetrain.turn_for(RIGHT, 90, DEGREES)\n</code></pre>"},{"location":"05-autonomous/01-basic-movements/#velocity-settings","title":"Velocity Settings","text":"<pre><code># Slow but accurate\ndrivetrain.set_drive_velocity(30, PERCENT)\ndrivetrain.set_turn_velocity(20, PERCENT)\n\n# Fast but might overshoot\ndrivetrain.set_drive_velocity(80, PERCENT)\ndrivetrain.set_turn_velocity(50, PERCENT)\n\n# Balanced (recommended starting point)\ndrivetrain.set_drive_velocity(50, PERCENT)\ndrivetrain.set_turn_velocity(30, PERCENT)\n</code></pre> <p>Trade-off: | Speed | Accuracy | Battery | Best For | |-------|----------|---------|----------| | Low | High | Lower use | Precise movements | | High | Lower | Higher use | Distance coverage |</p>"},{"location":"05-autonomous/01-basic-movements/#exercise-drive-a-triangle","title":"Exercise: Drive a Triangle","text":"<p>Goal: Program the robot to drive a triangle pattern.</p> <p>Hint: A triangle has: - 3 sides (each needs <code>drive_for</code>) - 3 corners (each needs <code>turn_for</code>) - Each turn is 120\u00b0 (360\u00b0 \u00f7 3 = 120\u00b0)</p> <pre><code>def drive_triangle():\n    setup_autonomous()\n\n    for i in range(3):\n        drivetrain.drive_for(FORWARD, _____, MM)\n        wait(200, MSEC)\n        drivetrain.turn_for(RIGHT, _____, DEGREES)\n        wait(200, MSEC)\n</code></pre> <p>Fill in the blanks!</p>"},{"location":"05-autonomous/01-basic-movements/#answer","title":"Answer","text":"<pre><code>def drive_triangle():\n    setup_autonomous()\n\n    for i in range(3):\n        drivetrain.drive_for(FORWARD, 400, MM)  # Any distance works\n        wait(200, MSEC)\n        drivetrain.turn_for(RIGHT, 120, DEGREES)  # 360/3 = 120\n        wait(200, MSEC)\n</code></pre> <p>\u2190 Previous: Driver Practice | Next: Timing and Sequences \u2192 | Review Q&amp;A</p>"},{"location":"05-autonomous/02-timing-and-sequences/","title":"Tutorial 5.2: Timing and Sequences","text":"<p>Time: ~15 minutes Prerequisites: Tutorial 5.1: Basic Movements</p>"},{"location":"05-autonomous/02-timing-and-sequences/#the-15-second-challenge","title":"The 15-Second Challenge","text":"<p>You only have 15 seconds for autonomous. Every millisecond counts!</p> <pre><code>timeline\n    title 15-Second Autonomous Breakdown\n    section Movement Phase\n        0-3 sec : Move 1\n        3-6 sec : Move 2\n        6-9 sec : Move 3\n        9-12 sec : Move 4\n        12-15 sec : Done!</code></pre> <p>Each movement takes time - plan carefully!</p>"},{"location":"05-autonomous/02-timing-and-sequences/#calculating-movement-time","title":"Calculating Movement Time","text":""},{"location":"05-autonomous/02-timing-and-sequences/#distance-vs-time","title":"Distance vs Time","text":"<p>Movement time depends on speed and distance:</p> <pre><code>Time = Distance \u00f7 Speed\n\nExample at 50% velocity (about 500 mm/s):\n- 500mm takes ~1 second\n- 1000mm takes ~2 seconds\n- 250mm takes ~0.5 seconds\n</code></pre>"},{"location":"05-autonomous/02-timing-and-sequences/#turn-time","title":"Turn Time","text":"<pre><code>At 30% turn velocity:\n- 90\u00b0 turn takes ~0.8 seconds\n- 180\u00b0 turn takes ~1.6 seconds\n- 45\u00b0 turn takes ~0.4 seconds\n</code></pre>"},{"location":"05-autonomous/02-timing-and-sequences/#wait-function","title":"wait() Function","text":"<pre><code>wait(duration, unit)\n</code></pre> Unit Example Use For <code>MSEC</code> <code>wait(200, MSEC)</code> Short pauses (0.2 seconds) <code>SECONDS</code> <code>wait(1, SECONDS)</code> Longer waits"},{"location":"05-autonomous/02-timing-and-sequences/#when-to-use-wait","title":"When to Use wait()","text":"<pre><code># After movements - let robot stabilize\ndrivetrain.drive_for(FORWARD, 500, MM)\nwait(200, MSEC)  # 0.2 seconds to stop momentum\n\n# After turning - same reason\ndrivetrain.turn_for(RIGHT, 90, DEGREES)\nwait(200, MSEC)\n\n# Waiting for mechanisms\nintake_motor.spin(FORWARD)\nwait(500, MSEC)  # 0.5 seconds to grab block\nintake_motor.stop()\n</code></pre>"},{"location":"05-autonomous/02-timing-and-sequences/#sequencing-multiple-actions","title":"Sequencing Multiple Actions","text":""},{"location":"05-autonomous/02-timing-and-sequences/#sequential-one-after-another","title":"Sequential (One After Another)","text":"<pre><code>def simple_sequence():\n    # Step 1: Drive forward\n    drivetrain.drive_for(FORWARD, 500, MM)\n    wait(200, MSEC)\n\n    # Step 2: Turn\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    wait(200, MSEC)\n\n    # Step 3: Drive again\n    drivetrain.drive_for(FORWARD, 300, MM)\n</code></pre> <pre><code>timeline\n    title Sequential Actions Timeline\n    section Step 1\n        0 - 1.0 sec : Drive forward\n    section Wait\n        1.0 - 1.2 sec : Stabilize\n    section Step 2\n        1.2 - 2.0 sec : Turn right\n    section Wait\n        2.0 - 2.2 sec : Stabilize\n    section Step 3\n        2.2 - 2.8 sec : Drive forward</code></pre>"},{"location":"05-autonomous/02-timing-and-sequences/#overlapping-actions","title":"Overlapping Actions","text":"<p>Some actions CAN happen at the same time:</p> <pre><code>def grab_while_moving():\n    # Start intake (doesn't block)\n    intake_motor.spin(FORWARD, 100, PERCENT)\n\n    # Drive forward (blocks until complete)\n    drivetrain.drive_for(FORWARD, 500, MM)\n\n    # Stop intake after arriving\n    intake_motor.stop()\n</code></pre> <pre><code>sequenceDiagram\n    participant Intake\n    participant Drive\n\n    Note over Intake,Drive: 0 sec - Start\n\n    Intake-&gt;&gt;Intake: spin(FORWARD)\n    Drive-&gt;&gt;Drive: drive_for(FORWARD, 500mm)\n\n    Note over Intake,Drive: Parallel execution!\n\n    Note over Intake,Drive: 1.0 sec - Complete\n    Intake-&gt;&gt;Intake: stop()</code></pre> <p>Both actions happen at the same time!</p>"},{"location":"05-autonomous/02-timing-and-sequences/#key-insight-blocking-vs-non-blocking","title":"Key Insight: Blocking vs Non-Blocking","text":"Method Behavior <code>drive_for()</code> Blocks - waits until done <code>turn_for()</code> Blocks - waits until done <code>motor.spin()</code> Non-blocking - returns immediately <code>motor.spin_for()</code> Blocks - waits until rotation complete"},{"location":"05-autonomous/02-timing-and-sequences/#optimizing-for-speed","title":"Optimizing for Speed","text":""},{"location":"05-autonomous/02-timing-and-sequences/#before-optimization","title":"Before Optimization","text":"<pre><code>def slow_routine():\n    drivetrain.drive_for(FORWARD, 500, MM)\n    wait(500, MSEC)  # Too long!\n\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    wait(500, MSEC)  # Too long!\n\n    drivetrain.drive_for(FORWARD, 300, MM)\n    wait(500, MSEC)  # Too long!\n\n    # Total: ~4.5 seconds (lots of wasted time)\n</code></pre>"},{"location":"05-autonomous/02-timing-and-sequences/#after-optimization","title":"After Optimization","text":"<pre><code>def fast_routine():\n    drivetrain.set_drive_velocity(70, PERCENT)  # Faster!\n    drivetrain.set_turn_velocity(50, PERCENT)   # Faster!\n\n    drivetrain.drive_for(FORWARD, 500, MM)\n    wait(150, MSEC)  # Shorter wait\n\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    wait(150, MSEC)  # Shorter wait\n\n    drivetrain.drive_for(FORWARD, 300, MM)\n    # No wait needed at end\n\n    # Total: ~2.0 seconds\n</code></pre>"},{"location":"05-autonomous/02-timing-and-sequences/#timing-comparison","title":"Timing Comparison","text":"<pre><code>timeline\n    title Before Optimization (~4.5 seconds)\n    section Drive 1\n        0 - 1.0 sec : drive_for 500mm\n    section Wait\n        1.0 - 1.5 sec : wait 500ms (too long!)\n    section Turn\n        1.5 - 2.3 sec : turn 90 degrees\n    section Wait\n        2.3 - 2.8 sec : wait 500ms (too long!)\n    section Drive 2\n        2.8 - 3.4 sec : drive_for 300mm\n    section Wait\n        3.4 - 3.9 sec : wait 500ms (too long!)</code></pre> <pre><code>timeline\n    title After Optimization (~2.0 seconds)\n    section Drive 1\n        0 - 0.7 sec : drive_for 500mm (70% velocity)\n    section Wait\n        0.7 - 0.85 sec : wait 150ms\n    section Turn\n        0.85 - 1.35 sec : turn 90 degrees (50% velocity)\n    section Wait\n        1.35 - 1.5 sec : wait 150ms\n    section Drive 2\n        1.5 - 2.0 sec : drive_for 300mm (no wait at end)</code></pre>"},{"location":"05-autonomous/02-timing-and-sequences/#building-complex-sequences","title":"Building Complex Sequences","text":""},{"location":"05-autonomous/02-timing-and-sequences/#sequence-builder-pattern","title":"Sequence Builder Pattern","text":"<pre><code>def score_first_block():\n    \"\"\"Sequence to score first block\"\"\"\n    # Drive to block\n    drivetrain.drive_for(FORWARD, 400, MM)\n\n    # Activate intake\n    intake_motor.spin(FORWARD, 100, PERCENT)\n    wait(500, MSEC)\n    intake_motor.stop()\n\n    # Turn toward goal\n    drivetrain.turn_for(RIGHT, 45, DEGREES)\n    wait(100, MSEC)\n\n    # Drive to goal\n    drivetrain.drive_for(FORWARD, 300, MM)\n\n    # Release block\n    intake_motor.spin(REVERSE, 100, PERCENT)\n    wait(300, MSEC)\n    intake_motor.stop()\n\n\ndef autonomous_routine():\n    setup_autonomous()\n\n    score_first_block()    # Use the sequence!\n    # ... more sequences ...\n</code></pre>"},{"location":"05-autonomous/02-timing-and-sequences/#reusable-movement-functions","title":"Reusable Movement Functions","text":"<pre><code>def drive_and_wait(direction, distance):\n    \"\"\"Drive with automatic wait\"\"\"\n    drivetrain.drive_for(direction, distance, MM)\n    wait(150, MSEC)\n\ndef turn_and_wait(direction, angle):\n    \"\"\"Turn with automatic wait\"\"\"\n    drivetrain.turn_for(direction, angle, DEGREES)\n    wait(150, MSEC)\n\n# Much cleaner code!\ndef clean_routine():\n    drive_and_wait(FORWARD, 500)\n    turn_and_wait(RIGHT, 90)\n    drive_and_wait(FORWARD, 300)\n</code></pre>"},{"location":"05-autonomous/02-timing-and-sequences/#timing-table-template","title":"Timing Table Template","text":"<p>Use this to plan your autonomous:</p> Step Action Distance/Angle Velocity Est. Time Total 1 Drive forward 500mm 50% 1.0s 1.0s 2 Wait - - 0.2s 1.2s 3 Turn right 90\u00b0 30% 0.8s 2.0s 4 Wait - - 0.2s 2.2s 5 Drive forward 300mm 50% 0.6s 2.8s ... ... ... ... ... ... Total &lt; 15s"},{"location":"05-autonomous/02-timing-and-sequences/#exercise-optimize-this-routine","title":"Exercise: Optimize This Routine","text":"<p>Given this slow routine:</p> <pre><code>def slow_auto():\n    setup_autonomous()\n    drivetrain.set_drive_velocity(30, PERCENT)\n    drivetrain.set_turn_velocity(20, PERCENT)\n\n    drivetrain.drive_for(FORWARD, 600, MM)\n    wait(1, SECONDS)\n\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    wait(1, SECONDS)\n\n    drivetrain.drive_for(FORWARD, 400, MM)\n    wait(1, SECONDS)\n\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    wait(1, SECONDS)\n\n    drivetrain.drive_for(FORWARD, 600, MM)\n</code></pre> <p>Challenge: Modify it to complete in under 6 seconds instead of ~15!</p> <p>Hint: Increase velocities and reduce wait times.</p> <p>\u2190 Previous: Basic Movements | Next: Push Back Autonomous \u2192 | Review Q&amp;A</p>"},{"location":"05-autonomous/03-push-back-autonomous/","title":"Tutorial 5.3: Push Back Autonomous","text":"<p>Time: ~15 minutes Prerequisites: Tutorial 5.2: Timing and Sequences</p>"},{"location":"05-autonomous/03-push-back-autonomous/#autonomous-win-point-requirements","title":"Autonomous Win Point Requirements","text":"<p>To earn the 10-point Autonomous Win Point, your alliance must achieve ALL of these:</p> <pre><code>    AUTONOMOUS WIN POINT CHECKLIST:\n\n    [ ] 7+ blocks of your color scored\n    [ ] Blocks in at least 3 different goals\n    [ ] 3+ blocks removed from loaders\n    [ ] Neither robot touching park zone barrier\n\n    Miss ANY ONE = No bonus!\n</code></pre>"},{"location":"05-autonomous/03-push-back-autonomous/#push-back-field-layout","title":"Push Back Field Layout","text":"<pre><code>    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    \u2551                      PUSH BACK FIELD                    \u2551\n    \u2551                        12' x 12'                        \u2551\n    \u2551                                                         \u2551\n    \u2551   [LONG GOAL]       [CENTER GOAL]      [LONG GOAL]     \u2551\n    \u2551   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2551\n    \u2551   \u2502 10pts   \u2502      \u2502  6-8 pts  \u2502       \u2502 10pts   \u2502     \u2551\n    \u2551   \u2502 /zone   \u2502      \u2502           \u2502       \u2502 /zone   \u2502     \u2551\n    \u2551   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2551\n    \u2551                                                         \u2551\n    \u2551     \u2593\u2593 \u2593\u2593 \u2593\u2593    \u2190 88 blocks scattered \u2192   \u2593\u2593 \u2593\u2593 \u2593\u2593     \u2551\n    \u2551                                                         \u2551\n    \u2551  [LOADER]                                  [LOADER]     \u2551\n    \u2551     RED                                      BLUE       \u2551\n    \u2551                                                         \u2551\n    \u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2551\n    \u2551  \u2502 PARK   \u2502  \u2190 8 or 30 pts \u2192             \u2502 PARK   \u2502     \u2551\n    \u2551  \u2502  RED   \u2502                              \u2502  BLUE  \u2502     \u2551\n    \u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2551\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n</code></pre>"},{"location":"05-autonomous/03-push-back-autonomous/#planning-your-starting-position","title":"Planning Your Starting Position","text":""},{"location":"05-autonomous/03-push-back-autonomous/#left-side-start","title":"Left Side Start","text":"<pre><code>def autonomous_left():\n    \"\"\"Starting from left side of field.\"\"\"\n    setup_autonomous()\n\n    # Drive toward center\n    drivetrain.drive_for(FORWARD, 800, MM)\n    wait(200, MSEC)\n\n    # Turn toward first goal\n    drivetrain.turn_for(RIGHT, 45, DEGREES)\n    wait(100, MSEC)\n\n    # Push blocks into goal\n    drivetrain.drive_for(FORWARD, 600, MM)\n    wait(200, MSEC)\n\n    # Back up\n    drivetrain.drive_for(REVERSE, 200, MM)\n</code></pre>"},{"location":"05-autonomous/03-push-back-autonomous/#right-side-start","title":"Right Side Start","text":"<pre><code>def autonomous_right():\n    \"\"\"Starting from right side of field.\"\"\"\n    setup_autonomous()\n\n    # Mirror of left side\n    drivetrain.drive_for(FORWARD, 800, MM)\n    wait(200, MSEC)\n\n    drivetrain.turn_for(LEFT, 45, DEGREES)  # Note: LEFT instead of RIGHT\n    wait(100, MSEC)\n\n    drivetrain.drive_for(FORWARD, 600, MM)\n    wait(200, MSEC)\n\n    drivetrain.drive_for(REVERSE, 200, MM)\n</code></pre>"},{"location":"05-autonomous/03-push-back-autonomous/#strategy-block-scoring","title":"Strategy: Block Scoring","text":""},{"location":"05-autonomous/03-push-back-autonomous/#push-multiple-blocks","title":"Push Multiple Blocks","text":"<pre><code>def push_blocks_to_goal():\n    \"\"\"Push a group of blocks into goal.\"\"\"\n    # Drive forward slowly to collect blocks\n    drivetrain.set_drive_velocity(40, PERCENT)  # Slow for control\n\n    drivetrain.drive_for(FORWARD, 1000, MM)\n    wait(200, MSEC)\n\n    # Blocks should be pushed into goal\n    drivetrain.drive_for(REVERSE, 300, MM)  # Back away\n</code></pre>"},{"location":"05-autonomous/03-push-back-autonomous/#with-intake-mechanism","title":"With Intake Mechanism","text":"<pre><code>def grab_and_score():\n    \"\"\"Pick up block and place in goal.\"\"\"\n    # Start intake\n    intake_motor.spin(FORWARD, 100, PERCENT)\n\n    # Drive to block\n    drivetrain.drive_for(FORWARD, 400, MM)\n    wait(300, MSEC)\n\n    intake_motor.stop()  # Block is grabbed\n\n    # Turn to goal\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    wait(100, MSEC)\n\n    # Drive to goal\n    drivetrain.drive_for(FORWARD, 500, MM)\n    wait(100, MSEC)\n\n    # Release block\n    intake_motor.spin(REVERSE, 100, PERCENT)\n    wait(300, MSEC)\n    intake_motor.stop()\n</code></pre>"},{"location":"05-autonomous/03-push-back-autonomous/#strategy-clearing-loaders","title":"Strategy: Clearing Loaders","text":"<p>The loaders have pre-stacked blocks. Removing them earns points:</p> <pre><code>def clear_loader():\n    \"\"\"Remove blocks from loader zone.\"\"\"\n    # Drive toward loader\n    drivetrain.drive_for(FORWARD, 600, MM)\n    wait(100, MSEC)\n\n    # Push blocks out of loader area\n    drivetrain.turn_for(LEFT, 30, DEGREES)\n    drivetrain.drive_for(FORWARD, 200, MM)\n\n    # Back up\n    drivetrain.drive_for(REVERSE, 300, MM)\n</code></pre>"},{"location":"05-autonomous/03-push-back-autonomous/#15-second-routine-template","title":"15-Second Routine Template","text":"<pre><code>def autonomous_routine():\n    \"\"\"\n    Main 15-second autonomous routine.\n    Designed for Push Back 2025-2026.\n    \"\"\"\n    brain.screen.print(\"Auto Started\")\n    setup_autonomous()\n\n    # === PHASE 1: SCORE FIRST BLOCK (0-5 sec) ===\n    drivetrain.drive_for(FORWARD, 500, MM)\n    wait(150, MSEC)\n    drivetrain.turn_for(RIGHT, 45, DEGREES)\n    wait(100, MSEC)\n    drivetrain.drive_for(FORWARD, 400, MM)  # Push into goal\n    wait(150, MSEC)\n\n    # === PHASE 2: SECOND GOAL (5-10 sec) ===\n    drivetrain.drive_for(REVERSE, 300, MM)\n    wait(100, MSEC)\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    wait(100, MSEC)\n    drivetrain.drive_for(FORWARD, 600, MM)  # Another goal\n    wait(150, MSEC)\n\n    # === PHASE 3: CLEAR LOADER (10-15 sec) ===\n    drivetrain.drive_for(REVERSE, 400, MM)\n    wait(100, MSEC)\n    drivetrain.turn_for(RIGHT, 45, DEGREES)\n    wait(100, MSEC)\n    drivetrain.drive_for(FORWARD, 300, MM)  # Clear loader\n\n    brain.screen.print(\"Auto Complete\")\n</code></pre>"},{"location":"05-autonomous/03-push-back-autonomous/#testing-your-autonomous","title":"Testing Your Autonomous","text":""},{"location":"05-autonomous/03-push-back-autonomous/#step-1-draw-your-path","title":"Step 1: Draw Your Path","text":"<pre><code>    Before coding, sketch your robot's path:\n\n    START\n      \u2193\n      \u25cf\u2500\u2500\u2192\u2500\u2500\u25cf\n             \u2193\n             \u25cf\u2500\u2500\u2192\u2500\u2500\u25cf (goal 1)\n             \u2191\n             \u2502 (backup)\n             \u25cf\n             \u2193\n             \u25cf\u2500\u2500\u2192\u2500\u2500\u25cf (goal 2)\n</code></pre>"},{"location":"05-autonomous/03-push-back-autonomous/#step-2-measure-distances","title":"Step 2: Measure Distances","text":"<ul> <li>Use a tape measure on the field</li> <li>Note distances in millimeters</li> <li>Measure angles with a protractor (or estimate)</li> </ul>"},{"location":"05-autonomous/03-push-back-autonomous/#step-3-code-and-test","title":"Step 3: Code and Test","text":"<pre><code># Start simple - just the first movement\ndef test_auto():\n    setup_autonomous()\n    drivetrain.drive_for(FORWARD, 500, MM)\n\n# Test, adjust, add more\n</code></pre>"},{"location":"05-autonomous/03-push-back-autonomous/#step-4-iterate","title":"Step 4: Iterate","text":"<ul> <li>Run the routine</li> <li>Watch where the robot ends up</li> <li>Adjust distances and angles</li> <li>Repeat!</li> </ul>"},{"location":"05-autonomous/03-push-back-autonomous/#summary-push-back-autonomous-tips","title":"Summary: Push Back Autonomous Tips","text":"Goal Strategy Score 7+ blocks Push groups, not individuals 3 different goals Plan path to hit multiple goals Clear loaders Don't forget! Easy points Avoid park barrier Check your final position"},{"location":"05-autonomous/03-push-back-autonomous/#exercise-design-your-autonomous","title":"Exercise: Design Your Autonomous","text":"<p>Goal: Create an autonomous routine for YOUR starting position.</p> <p>Step 1: Decide starting position (left or right)</p> <p>Step 2: Identify your targets: - Which goals can you reach? - Where are the blocks? - Where is the loader?</p> <p>Step 3: Sketch the path on paper</p> <p>Step 4: Write the code: <pre><code>def my_autonomous():\n    setup_autonomous()\n\n    # YOUR MOVEMENTS HERE:\n    # drivetrain.drive_for(...)\n    # drivetrain.turn_for(...)\n</code></pre></p> <p>Step 5: Test and iterate!</p> <p>\u2190 Previous: Timing and Sequences | Next: Competition Strategy \u2192 | Review Q&amp;A</p>"},{"location":"05-autonomous/04-review-qa/","title":"Module 5: Autonomous Programming - Review Q&amp;A","text":"<p>Total Questions: 60 Estimated Time: 45-60 minutes Difficulty: Mixed (Starter to Champion)</p>"},{"location":"05-autonomous/04-review-qa/#how-to-use-this-document","title":"How to Use This Document","text":"<p>This Q&amp;A document covers all concepts from Module 5: Autonomous Programming. Use it for: - Self-study review before competitions - Classroom quizzes (all answers at end) - Pre-competition preparation</p>"},{"location":"05-autonomous/04-review-qa/#difficulty-levels","title":"Difficulty Levels","text":"Level Label Description 1 [STARTER] Basic recall - you remember this! 2 [LEARNER] Understanding concepts - explain it! 3 [BUILDER] Apply knowledge - use it! 4 [THINKER] Analyze relationships - connect ideas! 5 [CHAMPION] Competition scenarios - win matches!"},{"location":"05-autonomous/04-review-qa/#question-types","title":"Question Types","text":"Type Symbol What To Do Multiple Choice (A)(B)(C)(D) Pick the best answer True/False T/F Decide if statement is correct Fill-in-Blank _____ Complete the code or sentence Short Answer SA Write 1-3 sentences Code Analysis CODE Read code and answer Diagram DIAGRAM Interpret visual information"},{"location":"05-autonomous/04-review-qa/#part-1-basic-autonomous-movements","title":"Part 1: Basic Autonomous Movements","text":"<p>Questions 1-20</p>"},{"location":"05-autonomous/04-review-qa/#question-1-starter-multiple-choice","title":"Question 1 [STARTER] - Multiple Choice","text":"<p>How long is the autonomous period in a VEX competition match?</p> <p>(A) 30 seconds (B) 15 seconds (C) 60 seconds (D) 45 seconds</p>"},{"location":"05-autonomous/04-review-qa/#question-2-starter-truefalse","title":"Question 2 [STARTER] - True/False","text":"<p>T/F: During the autonomous period, the driver can control the robot using the controller.</p>"},{"location":"05-autonomous/04-review-qa/#question-3-learner-multiple-choice","title":"Question 3 [LEARNER] - Multiple Choice","text":"<p>What does <code>drive_for(FORWARD, 500, MM)</code> do?</p> <p>(A) Spins the motors forward at 500% speed (B) Drives the robot forward 500 millimeters (C) Sets the drive velocity to 500 (D) Drives forward for 500 milliseconds</p>"},{"location":"05-autonomous/04-review-qa/#question-4-starter-fill-in-blank","title":"Question 4 [STARTER] - Fill-in-Blank","text":"<p>Complete the code to turn the robot left by 90 degrees:</p> <pre><code>drivetrain.turn_for(_____, 90, DEGREES)\n</code></pre>"},{"location":"05-autonomous/04-review-qa/#question-5-learner-multiple-choice","title":"Question 5 [LEARNER] - Multiple Choice","text":"<p>Which command makes the robot rotate in place?</p> <p>(A) <code>drive_for()</code> (B) <code>spin()</code> (C) <code>turn_for()</code> (D) <code>rotate_for()</code></p>"},{"location":"05-autonomous/04-review-qa/#question-6-builder-code-analysis","title":"Question 6 [BUILDER] - Code Analysis","text":"<p>What path does this code create?</p> <pre><code>drivetrain.drive_for(FORWARD, 500, MM)\ndrivetrain.turn_for(RIGHT, 90, DEGREES)\ndrivetrain.drive_for(FORWARD, 500, MM)\ndrivetrain.turn_for(RIGHT, 90, DEGREES)\n</code></pre> <p>(A) A straight line (B) An L-shape (C) Half of a square (D) A triangle</p>"},{"location":"05-autonomous/04-review-qa/#question-7-starter-multiple-choice","title":"Question 7 [STARTER] - Multiple Choice","text":"<p>What units can be used with <code>drive_for()</code> for distance?</p> <p>(A) MM only (B) INCHES only (C) MM or INCHES (D) PERCENT</p>"},{"location":"05-autonomous/04-review-qa/#question-8-learner-short-answer","title":"Question 8 [LEARNER] - Short Answer","text":"<p>Why do we call <code>setup_autonomous()</code> at the beginning of an autonomous routine?</p>"},{"location":"05-autonomous/04-review-qa/#question-9-builder-fill-in-blank","title":"Question 9 [BUILDER] - Fill-in-Blank","text":"<p>Complete the setup code to make the robot stop immediately when a movement ends:</p> <pre><code>def setup_autonomous():\n    drivetrain.set_drive_velocity(50, PERCENT)\n    drivetrain.set_turn_velocity(30, PERCENT)\n    drivetrain.set_stopping(_____)\n</code></pre>"},{"location":"05-autonomous/04-review-qa/#question-10-learner-multiple-choice","title":"Question 10 [LEARNER] - Multiple Choice","text":"<p>What does <code>set_timeout(3, SECONDS)</code> prevent?</p> <p>(A) The robot from going too fast (B) The robot from waiting forever if stuck (C) The robot from overheating (D) The robot from turning too sharply</p>"},{"location":"05-autonomous/04-review-qa/#question-11-starter-diagram","title":"Question 11 [STARTER] - Diagram","text":"<pre><code>    MATCH TIMELINE:\n\n    0:00                   0:15                   2:00\n    |\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501|\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501|\n    \u2190       A            \u2192 \u2190         B           \u2192\n</code></pre> <p>What do A and B represent in this match timeline?</p>"},{"location":"05-autonomous/04-review-qa/#question-12-learner-truefalse","title":"Question 12 [LEARNER] - True/False","text":"<p>T/F: <code>set_stopping(COAST)</code> makes the robot stop immediately and hold its position firmly.</p>"},{"location":"05-autonomous/04-review-qa/#question-13-builder-multiple-choice","title":"Question 13 [BUILDER] - Multiple Choice","text":"<p>You want your robot to stop quickly but not actively hold position. Which stopping mode should you use?</p> <p>(A) COAST (B) BRAKE (C) HOLD (D) STOP</p>"},{"location":"05-autonomous/04-review-qa/#question-14-thinker-short-answer","title":"Question 14 [THINKER] - Short Answer","text":"<p>Explain the difference between BRAKE and HOLD stopping modes. When would you choose each one?</p>"},{"location":"05-autonomous/04-review-qa/#question-15-builder-code-analysis","title":"Question 15 [BUILDER] - Code Analysis","text":"<p>What shape does this code draw?</p> <pre><code>for i in range(4):\n    drivetrain.drive_for(FORWARD, 500, MM)\n    wait(200, MSEC)\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    wait(200, MSEC)\n</code></pre> <p>(A) Triangle (B) Square (C) Pentagon (D) Circle</p>"},{"location":"05-autonomous/04-review-qa/#question-16-thinker-fill-in-blank","title":"Question 16 [THINKER] - Fill-in-Blank","text":"<p>To drive a triangle pattern, each turn must be _ degrees because 360 \u00f7 3 = ___.</p>"},{"location":"05-autonomous/04-review-qa/#question-17-learner-short-answer","title":"Question 17 [LEARNER] - Short Answer","text":"<p>Why do we add <code>wait(200, MSEC)</code> between movements in autonomous code?</p>"},{"location":"05-autonomous/04-review-qa/#question-18-builder-multiple-choice","title":"Question 18 [BUILDER] - Multiple Choice","text":"<p>What is the trade-off of using a higher drive velocity (like 80%)?</p> <p>(A) More accurate but slower (B) Faster but may overshoot (C) Uses less battery (D) Better for tight turns</p>"},{"location":"05-autonomous/04-review-qa/#question-19-champion-code-analysis","title":"Question 19 [CHAMPION] - Code Analysis","text":"<p>This code doesn't work as expected. What's wrong?</p> <pre><code>def autonomous_routine():\n    drivetrain.drive_for(FORWARD, 1000, MM)\n    drivetrain.turn_for(RIGHT, 90, DEGREES)  # Robot drifts during turn!\n</code></pre> <p>(A) Missing <code>setup_autonomous()</code> call (B) Missing <code>wait()</code> between movements (C) Wrong turn direction (D) Distance is too long</p>"},{"location":"05-autonomous/04-review-qa/#question-20-starter-multiple-choice","title":"Question 20 [STARTER] - Multiple Choice","text":"<p>In <code>drive_for(REVERSE, 300, MM)</code>, what does REVERSE mean?</p> <p>(A) Turn around 180 degrees (B) Drive backward (C) Spin in reverse circles (D) Reset position</p>"},{"location":"05-autonomous/04-review-qa/#part-2-timing-and-sequences","title":"Part 2: Timing and Sequences","text":"<p>Questions 21-40</p>"},{"location":"05-autonomous/04-review-qa/#question-21-starter-truefalse","title":"Question 21 [STARTER] - True/False","text":"<p>T/F: You have unlimited time during the autonomous period to complete your routine.</p>"},{"location":"05-autonomous/04-review-qa/#question-22-learner-fill-in-blank","title":"Question 22 [LEARNER] - Fill-in-Blank","text":"<p>If your robot drives at 50% velocity (about 500 mm/s), driving 1000mm takes approximately _____ seconds.</p>"},{"location":"05-autonomous/04-review-qa/#question-23-builder-multiple-choice","title":"Question 23 [BUILDER] - Multiple Choice","text":"<p>Which <code>wait()</code> call is a 0.5 second pause?</p> <p>(A) <code>wait(5, SECONDS)</code> (B) <code>wait(500, SECONDS)</code> (C) <code>wait(500, MSEC)</code> (D) <code>wait(50, MSEC)</code></p>"},{"location":"05-autonomous/04-review-qa/#question-24-learner-short-answer","title":"Question 24 [LEARNER] - Short Answer","text":"<p>What is the difference between <code>MSEC</code> and <code>SECONDS</code> in the wait() function?</p>"},{"location":"05-autonomous/04-review-qa/#question-25-thinker-multiple-choice","title":"Question 25 [THINKER] - Multiple Choice","text":"<p>Which method is BLOCKING (waits until complete before continuing)?</p> <p>(A) <code>motor.spin(FORWARD)</code> (B) <code>drivetrain.drive_for(FORWARD, 500, MM)</code> (C) Both are blocking (D) Neither is blocking</p>"},{"location":"05-autonomous/04-review-qa/#question-26-builder-code-analysis","title":"Question 26 [BUILDER] - Code Analysis","text":"<p>What happens in this code?</p> <pre><code>intake_motor.spin(FORWARD, 100, PERCENT)\ndrivetrain.drive_for(FORWARD, 500, MM)\nintake_motor.stop()\n</code></pre> <p>(A) Intake spins, then robot drives, then intake stops (B) Robot drives while intake is spinning, then intake stops (C) Intake and drive start together, intake stops first (D) Code errors - can't do two things</p>"},{"location":"05-autonomous/04-review-qa/#question-27-champion-diagram","title":"Question 27 [CHAMPION] - Diagram","text":"<pre><code>    Timeline:\n    Intake:  [\u2501\u2501\u2501\u2501\u2501\u2501\u2501 SPINNING \u2501\u2501\u2501\u2501\u2501\u2501\u2501][stop]\n    Drive:   [\u2501\u2501\u2501\u2501\u2501\u2501\u2501 FORWARD \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501]\n             0                        1.0 sec\n</code></pre> <p>What does this timeline diagram demonstrate?</p> <p>(A) Sequential actions - one after another (B) Overlapping actions - running simultaneously (C) A broken sequence (D) Two separate routines</p>"},{"location":"05-autonomous/04-review-qa/#question-28-learner-truefalse","title":"Question 28 [LEARNER] - True/False","text":"<p>T/F: <code>motor.spin_for()</code> is a blocking command that waits until the rotation is complete.</p>"},{"location":"05-autonomous/04-review-qa/#question-29-builder-fill-in-blank","title":"Question 29 [BUILDER] - Fill-in-Blank","text":"<p>Complete this optimized code to use shorter waits:</p> <pre><code>def fast_routine():\n    drivetrain.set_drive_velocity(70, PERCENT)\n\n    drivetrain.drive_for(FORWARD, 500, MM)\n    wait(_____, MSEC)  # Use 150ms instead of 500ms\n\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n</code></pre>"},{"location":"05-autonomous/04-review-qa/#question-30-thinker-multiple-choice","title":"Question 30 [THINKER] - Multiple Choice","text":"<p>Why is the slow_routine() below inefficient?</p> <pre><code>def slow_routine():\n    drivetrain.drive_for(FORWARD, 500, MM)\n    wait(500, MSEC)\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    wait(500, MSEC)\n</code></pre> <p>(A) Velocity is too low (B) Wait times are too long (C) Not enough movements (D) Wrong direction</p>"},{"location":"05-autonomous/04-review-qa/#question-31-builder-short-answer","title":"Question 31 [BUILDER] - Short Answer","text":"<p>What are two ways to optimize an autonomous routine to complete faster?</p>"},{"location":"05-autonomous/04-review-qa/#question-32-champion-code-analysis","title":"Question 32 [CHAMPION] - Code Analysis","text":"<p>Estimate the total time for this routine:</p> <pre><code># At 50% velocity (~500 mm/s, ~0.8s per 90\u00b0 turn)\ndrivetrain.drive_for(FORWARD, 500, MM)   # ~1.0s\nwait(200, MSEC)                           # 0.2s\ndrivetrain.turn_for(RIGHT, 90, DEGREES)   # ~0.8s\nwait(200, MSEC)                           # 0.2s\ndrivetrain.drive_for(FORWARD, 300, MM)   # ~0.6s\n</code></pre> <p>(A) About 1.5 seconds (B) About 2.8 seconds (C) About 5 seconds (D) About 10 seconds</p>"},{"location":"05-autonomous/04-review-qa/#question-33-learner-multiple-choice","title":"Question 33 [LEARNER] - Multiple Choice","text":"<p>What does a \"sequence\" in autonomous programming mean?</p> <p>(A) A random set of movements (B) Multiple actions executed in a specific order (C) A single movement repeated (D) Moving in a circle</p>"},{"location":"05-autonomous/04-review-qa/#question-34-builder-fill-in-blank","title":"Question 34 [BUILDER] - Fill-in-Blank","text":"<p>Create a reusable function that drives and waits automatically:</p> <pre><code>def drive_and_wait(direction, distance):\n    drivetrain.drive_for(direction, distance, _____)\n    wait(150, _____)\n</code></pre>"},{"location":"05-autonomous/04-review-qa/#question-35-thinker-short-answer","title":"Question 35 [THINKER] - Short Answer","text":"<p>Why is it useful to create helper functions like <code>drive_and_wait()</code> and <code>turn_and_wait()</code>?</p>"},{"location":"05-autonomous/04-review-qa/#question-36-starter-truefalse","title":"Question 36 [STARTER] - True/False","text":"<p>T/F: At the end of an autonomous routine, you still need a wait() call after the last movement.</p>"},{"location":"05-autonomous/04-review-qa/#question-37-builder-multiple-choice","title":"Question 37 [BUILDER] - Multiple Choice","text":"<p>In this timing table, what's the total time?</p> Step Action Time Total 1 Drive forward 1.0s 1.0s 2 Wait 0.2s 1.2s 3 Turn right 0.8s 2.0s 4 Wait 0.2s ? <p>(A) 2.0 seconds (B) 2.2 seconds (C) 3.0 seconds (D) 2.4 seconds</p>"},{"location":"05-autonomous/04-review-qa/#question-38-champion-code-analysis","title":"Question 38 [CHAMPION] - Code Analysis","text":"<p>This routine is too slow (~15 seconds). How would you fix it?</p> <pre><code>def slow_auto():\n    drivetrain.set_drive_velocity(30, PERCENT)\n    drivetrain.set_turn_velocity(20, PERCENT)\n\n    drivetrain.drive_for(FORWARD, 600, MM)\n    wait(1, SECONDS)\n\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    wait(1, SECONDS)\n</code></pre> <p>Write down 2 specific changes you would make.</p>"},{"location":"05-autonomous/04-review-qa/#question-39-learner-multiple-choice","title":"Question 39 [LEARNER] - Multiple Choice","text":"<p>What's the purpose of breaking autonomous code into phases like \"PHASE 1: SCORE FIRST BLOCK\"?</p> <p>(A) Makes code look longer (B) Organizes code and makes it easier to debug (C) Required by VEX competition rules (D) Makes robot move faster</p>"},{"location":"05-autonomous/04-review-qa/#question-40-thinker-short-answer","title":"Question 40 [THINKER] - Short Answer","text":"<p>Explain the difference between <code>motor.spin()</code> and <code>motor.spin_for()</code> in terms of blocking behavior.</p>"},{"location":"05-autonomous/04-review-qa/#part-3-push-back-autonomous-strategy","title":"Part 3: Push Back Autonomous Strategy","text":"<p>Questions 41-60</p>"},{"location":"05-autonomous/04-review-qa/#question-41-starter-multiple-choice","title":"Question 41 [STARTER] - Multiple Choice","text":"<p>How many blocks of your alliance color must be scored to help earn the Autonomous Win Point?</p> <p>(A) 3 or more (B) 5 or more (C) 7 or more (D) 10 or more</p>"},{"location":"05-autonomous/04-review-qa/#question-42-learner-fill-in-blank","title":"Question 42 [LEARNER] - Fill-in-Blank","text":"<p>To earn the Autonomous Win Point, blocks must be scored in at least _____ different goals.</p>"},{"location":"05-autonomous/04-review-qa/#question-43-starter-truefalse","title":"Question 43 [STARTER] - True/False","text":"<p>T/F: To earn the Autonomous Win Point, your robot CAN be touching the park zone barrier at the end of autonomous.</p>"},{"location":"05-autonomous/04-review-qa/#question-44-builder-short-answer","title":"Question 44 [BUILDER] - Short Answer","text":"<p>Name all 4 requirements to earn the Autonomous Win Point in Push Back.</p>"},{"location":"05-autonomous/04-review-qa/#question-45-learner-multiple-choice","title":"Question 45 [LEARNER] - Multiple Choice","text":"<p>What is the size of the Push Back competition field?</p> <p>(A) 8' x 8' (B) 10' x 10' (C) 12' x 12' (D) 6' x 6'</p>"},{"location":"05-autonomous/04-review-qa/#question-46-builder-diagram","title":"Question 46 [BUILDER] - Diagram","text":"<pre><code>    PUSH BACK FIELD (simplified):\n\n    [LONG GOAL]    [CENTER GOAL]    [LONG GOAL]\n\n                 \u2593\u2593 \u2593\u2593 \u2593\u2593 (blocks)\n\n    [LOADER]                        [LOADER]\n      RED                            BLUE\n\n    [PARK RED]                      [PARK BLUE]\n</code></pre> <p>If you're the RED alliance starting on the left, which loader would be closest to you?</p> <p>(A) RED loader (B) BLUE loader (C) Neither - loaders are in the center (D) Both are equidistant</p>"},{"location":"05-autonomous/04-review-qa/#question-47-thinker-multiple-choice","title":"Question 47 [THINKER] - Multiple Choice","text":"<p>Why might you want different autonomous routines for left and right starting positions?</p> <p>(A) The rules are different for each side (B) The field layout is mirrored, so paths need to mirror too (C) One side is easier than the other (D) The robot drives differently on each side</p>"},{"location":"05-autonomous/04-review-qa/#question-48-builder-code-analysis","title":"Question 48 [BUILDER] - Code Analysis","text":"<p>What's different between <code>autonomous_left()</code> and <code>autonomous_right()</code>?</p> <pre><code>def autonomous_left():\n    drivetrain.turn_for(RIGHT, 45, DEGREES)  # Turn RIGHT\n\ndef autonomous_right():\n    drivetrain.turn_for(LEFT, 45, DEGREES)   # Turn LEFT\n</code></pre> <p>(A) They drive different distances (B) Turn directions are mirrored (C) Different velocities (D) Different timeout values</p>"},{"location":"05-autonomous/04-review-qa/#question-49-builder-fill-in-blank","title":"Question 49 [BUILDER] - Fill-in-Blank","text":"<p>Complete this code to push blocks slowly for better control:</p> <pre><code>def push_blocks_to_goal():\n    drivetrain.set_drive_velocity(_____, PERCENT)  # Slow for control\n    drivetrain.drive_for(FORWARD, 1000, MM)\n</code></pre>"},{"location":"05-autonomous/04-review-qa/#question-50-champion-short-answer","title":"Question 50 [CHAMPION] - Short Answer","text":"<p>In the Push Back game, why might you push groups of blocks rather than individual blocks?</p>"},{"location":"05-autonomous/04-review-qa/#question-51-thinker-code-analysis","title":"Question 51 [THINKER] - Code Analysis","text":"<p>What does this code accomplish?</p> <pre><code>intake_motor.spin(FORWARD, 100, PERCENT)\ndrivetrain.drive_for(FORWARD, 400, MM)\nwait(300, MSEC)\nintake_motor.stop()\n</code></pre> <p>(A) Drives forward then activates intake (B) Drives forward while intake grabs a block (C) Spins intake then waits (D) Does nothing - code is broken</p>"},{"location":"05-autonomous/04-review-qa/#question-52-builder-multiple-choice","title":"Question 52 [BUILDER] - Multiple Choice","text":"<p>To release a grabbed block, what should the intake motor do?</p> <p>(A) <code>intake_motor.spin(FORWARD)</code> (B) <code>intake_motor.spin(REVERSE)</code> (C) <code>intake_motor.stop()</code> (D) <code>intake_motor.coast()</code></p>"},{"location":"05-autonomous/04-review-qa/#question-53-champion-fill-in-blank","title":"Question 53 [CHAMPION] - Fill-in-Blank","text":"<p>Complete this 15-second routine template with proper phases:</p> <pre><code>def autonomous_routine():\n    setup_autonomous()\n\n    # === PHASE 1: _____ (0-5 sec) ===\n    drivetrain.drive_for(FORWARD, 500, MM)\n\n    # === PHASE 2: _____ (5-10 sec) ===\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n\n    # === PHASE 3: _____ (10-15 sec) ===\n    drivetrain.drive_for(FORWARD, 300, MM)\n</code></pre>"},{"location":"05-autonomous/04-review-qa/#question-54-learner-multiple-choice","title":"Question 54 [LEARNER] - Multiple Choice","text":"<p>What is a \"loader\" zone in Push Back?</p> <p>(A) Where you park your robot (B) Area with pre-stacked blocks to remove (C) The scoring goal (D) The starting position</p>"},{"location":"05-autonomous/04-review-qa/#question-55-starter-truefalse","title":"Question 55 [STARTER] - True/False","text":"<p>T/F: In Push Back, removing blocks from loaders counts toward the Autonomous Win Point requirements.</p>"},{"location":"05-autonomous/04-review-qa/#question-56-thinker-short-answer","title":"Question 56 [THINKER] - Short Answer","text":"<p>Before coding your autonomous, why should you sketch your robot's path on paper first?</p>"},{"location":"05-autonomous/04-review-qa/#question-57-builder-multiple-choice","title":"Question 57 [BUILDER] - Multiple Choice","text":"<p>What's the first step in the autonomous testing process?</p> <p>(A) Run the full routine (B) Measure all distances (C) Draw your path on paper (D) Add wait() statements</p>"},{"location":"05-autonomous/04-review-qa/#question-58-champion-code-analysis","title":"Question 58 [CHAMPION] - Code Analysis","text":"<p>This autonomous routine has a problem. What's wrong?</p> <pre><code>def autonomous_routine():\n    drivetrain.drive_for(FORWARD, 2000, MM)  # 2 meters forward!\n    drivetrain.turn_for(RIGHT, 180, DEGREES)\n    drivetrain.drive_for(FORWARD, 1500, MM)\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n</code></pre> <p>(A) No setup_autonomous() call (B) Likely takes more than 15 seconds (C) Turn angles don't add up (D) Both A and B</p>"},{"location":"05-autonomous/04-review-qa/#question-59-builder-fill-in-blank","title":"Question 59 [BUILDER] - Fill-in-Blank","text":"<p>To test your autonomous incrementally, start with:</p> <pre><code>def test_auto():\n    setup_autonomous()\n    drivetrain.drive_for(FORWARD, _____, MM)\n    # Test this first, then add more\n</code></pre>"},{"location":"05-autonomous/04-review-qa/#question-60-champion-short-answer","title":"Question 60 [CHAMPION] - Short Answer","text":"<p>Describe the 4-step iterative testing process for developing autonomous routines.</p>"},{"location":"05-autonomous/04-review-qa/#answer-key","title":"Answer Key","text":"<p>All answers with explanations, common mistakes, and tutorial references.</p>"},{"location":"05-autonomous/04-review-qa/#part-1-basic-autonomous-movements-questions-1-20","title":"Part 1: Basic Autonomous Movements (Questions 1-20)","text":""},{"location":"05-autonomous/04-review-qa/#answer-1","title":"Answer 1","text":"<p>Correct: (B) 15 seconds</p> <p>The autonomous period is exactly 15 seconds at the start of every VEX match. During this time, your robot must operate entirely on pre-programmed code.</p> <p>Common Mistake: Confusing with skills autonomous (60 seconds) or thinking all of driver control is autonomous.</p> <p>Reference: Tutorial 5.1, \"What is Autonomous?\" section</p>"},{"location":"05-autonomous/04-review-qa/#answer-2","title":"Answer 2","text":"<p>Correct: False</p> <p>During autonomous, NO human control is allowed. The driver cannot touch the controller or influence the robot in any way. That's why it's called \"autonomous\" - the robot must act on its own.</p> <p>Common Mistake: Thinking the driver can make small adjustments.</p> <p>Reference: Tutorial 5.1, match timeline diagram</p>"},{"location":"05-autonomous/04-review-qa/#answer-3","title":"Answer 3","text":"<p>Correct: (B) Drives the robot forward 500 millimeters</p> <p><code>drive_for(direction, distance, units)</code> moves the robot a specific distance. The 500 represents millimeters (about half a meter).</p> <p>Common Mistake: Confusing distance with velocity or time.</p> <p>Reference: Tutorial 5.1, \"drive_for() - Move Forward/Backward\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-4","title":"Answer 4","text":"<p>Correct: <code>LEFT</code></p> <pre><code>drivetrain.turn_for(LEFT, 90, DEGREES)\n</code></pre> <p>The first parameter is the turn direction (LEFT or RIGHT).</p> <p>Reference: Tutorial 5.1, \"turn_for() - Rotate in Place\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-5","title":"Answer 5","text":"<p>Correct: (C) <code>turn_for()</code></p> <p><code>turn_for()</code> rotates the robot in place by spinning the left and right wheels in opposite directions. <code>drive_for()</code> moves the whole robot forward/backward.</p> <p>Common Mistake: Using <code>spin()</code> which is for individual motors, not the drivetrain.</p> <p>Reference: Tutorial 5.1, \"turn_for() - Rotate in Place\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-6","title":"Answer 6","text":"<p>Correct: (C) Half of a square</p> <p>The code drives forward, turns 90\u00b0, drives forward again, and turns 90\u00b0. This creates an L-shape or half of a square (2 sides and 2 corners).</p> <p>Common Mistake: Thinking any turn creates a complete shape.</p> <p>Reference: Tutorial 5.1, \"Driving a Square Pattern\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-7","title":"Answer 7","text":"<p>Correct: (C) MM or INCHES</p> <p>Both millimeters (MM) and INCHES are valid distance units for <code>drive_for()</code>. Example: <code>drive_for(FORWARD, 12, INCHES)</code> is equivalent to about <code>drive_for(FORWARD, 305, MM)</code>.</p> <p>Reference: Tutorial 5.1, Parameters table for drive_for()</p>"},{"location":"05-autonomous/04-review-qa/#answer-8","title":"Answer 8","text":"<p>Correct Answer:</p> <p><code>setup_autonomous()</code> configures the drivetrain with proper velocity, turn speed, stopping mode, and timeout settings before executing movements. Without it, the robot might use default settings that aren't optimized for your routine.</p> <p>Key Points: - Sets drive velocity (50%) - Sets turn velocity (30%) - Sets stopping mode (BRAKE) - Sets timeout (3 seconds)</p> <p>Reference: Tutorial 5.1, \"Code Walkthrough: autonomous.py\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-9","title":"Answer 9","text":"<p>Correct: <code>BRAKE</code></p> <pre><code>drivetrain.set_stopping(BRAKE)\n</code></pre> <p>BRAKE stops the robot quickly with active braking. COAST would let it drift, and HOLD would actively resist movement.</p> <p>Reference: Tutorial 5.1, \"Stopping Modes\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-10","title":"Answer 10","text":"<p>Correct: (B) The robot from waiting forever if stuck</p> <p><code>set_timeout()</code> creates a maximum time limit for each movement. If the robot gets stuck (blocked by an obstacle), it will give up after the timeout and continue to the next command instead of waiting forever.</p> <p>Common Mistake: Thinking timeout relates to speed or temperature.</p> <p>Reference: Tutorial 5.1, \"Understanding set_timeout()\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-11","title":"Answer 11","text":"<p>Correct Answer: - A = Autonomous (15 seconds) - Robot runs programmed code - B = Driver Control (1:45) - Human driver takes over</p> <p>Reference: Tutorial 5.1, \"What is Autonomous?\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-12","title":"Answer 12","text":"<p>Correct: False</p> <p>COAST does the opposite - it lets the robot slowly coast to a stop like a car in neutral. HOLD is what makes the robot hold its position firmly.</p> <p>Common Mistake: Confusing COAST, BRAKE, and HOLD.</p> <p>Reference: Tutorial 5.1, \"Stopping Modes\" comparison</p>"},{"location":"05-autonomous/04-review-qa/#answer-13","title":"Answer 13","text":"<p>Correct: (B) BRAKE</p> <ul> <li>COAST: Slow drift to stop (free-spin)</li> <li>BRAKE: Quick stop with active braking</li> <li>HOLD: Actively resists any movement</li> </ul> <p>BRAKE is the recommended default for most autonomous routines.</p> <p>Reference: Tutorial 5.1, stopping modes diagram</p>"},{"location":"05-autonomous/04-review-qa/#answer-14","title":"Answer 14","text":"<p>Correct Answer:</p> <p>BRAKE: Quickly stops the robot and releases the motors. Good for general movements where you want accurate stopping but don't need to hold position.</p> <p>HOLD: Stops AND actively resists any movement after stopping. Motors stay engaged to maintain position. Good when you need the robot to stay exactly where it stopped (like before scoring).</p> <p>Example: Use BRAKE when driving between positions. Use HOLD when positioning precisely before an intake grabs a block.</p> <p>Reference: Tutorial 5.1, \"Stopping Modes\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-15","title":"Answer 15","text":"<p>Correct: (B) Square</p> <p>The <code>for i in range(4)</code> loop repeats 4 times. Each iteration: 1. Drives forward 500mm (one side) 2. Turns right 90\u00b0 (one corner)</p> <p>4 sides \u00d7 90\u00b0 turns = 360\u00b0 total = closed square.</p> <p>Reference: Tutorial 5.1, \"Driving a Square Pattern\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-16","title":"Answer 16","text":"<p>Correct: 120 degrees, 120</p> <p>A triangle has 3 corners. To make a closed shape, total turning must be 360\u00b0. 360\u00b0 \u00f7 3 corners = 120\u00b0 per turn.</p> <p>Reference: Tutorial 5.1, Exercise: Drive a Triangle</p>"},{"location":"05-autonomous/04-review-qa/#answer-17","title":"Answer 17","text":"<p>Correct Answer:</p> <p>The <code>wait(200, MSEC)</code> gives the robot time to physically stop and stabilize before starting the next movement. Without it: - The robot might still be moving when the next command starts - Momentum could cause the robot to drift or overshoot - Turns might be inaccurate if started before the robot fully stops</p> <p>Reference: Tutorial 5.1, \"Why wait() Between Moves?\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-18","title":"Answer 18","text":"<p>Correct: (B) Faster but may overshoot</p> <p>Higher velocity means: - \u2713 Faster movements (covers more distance in 15 seconds) - \u2717 Less accurate (harder to stop precisely) - \u2717 Higher battery usage</p> <p>The recommended starting point is 50% velocity for balance.</p> <p>Reference: Tutorial 5.1, \"Velocity Settings\" trade-off table</p>"},{"location":"05-autonomous/04-review-qa/#answer-19","title":"Answer 19","text":"<p>Correct: (B) Missing <code>wait()</code> between movements</p> <p>Without a <code>wait()</code> after <code>drive_for()</code>, the robot might not fully stop before <code>turn_for()</code> begins. This causes drift during the turn.</p> <p>Fixed code: <pre><code>drivetrain.drive_for(FORWARD, 1000, MM)\nwait(200, MSEC)  # Add this!\ndrivetrain.turn_for(RIGHT, 90, DEGREES)\n</code></pre></p> <p>Common Mistake: Blaming direction or distance when timing is the issue.</p> <p>Reference: Tutorial 5.1, \"Why wait() Between Moves?\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-20","title":"Answer 20","text":"<p>Correct: (B) Drive backward</p> <p>REVERSE makes the robot drive in the opposite direction from FORWARD. It doesn't turn around - the front still faces forward, but the robot moves backward.</p> <p>Reference: Tutorial 5.1, \"drive_for() - Move Forward/Backward\"</p>"},{"location":"05-autonomous/04-review-qa/#part-2-timing-and-sequences-questions-21-40","title":"Part 2: Timing and Sequences (Questions 21-40)","text":""},{"location":"05-autonomous/04-review-qa/#answer-21","title":"Answer 21","text":"<p>Correct: False</p> <p>You have exactly 15 seconds. Every movement takes time, so you must plan carefully. An overly long routine will get cut off at 15 seconds.</p> <p>Reference: Tutorial 5.2, \"The 15-Second Challenge\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-22","title":"Answer 22","text":"<p>Correct: 2 (or approximately 2)</p> <p>Time = Distance \u00f7 Speed Time = 1000mm \u00f7 500 mm/s = 2 seconds</p> <p>Reference: Tutorial 5.2, \"Calculating Movement Time\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-23","title":"Answer 23","text":"<p>Correct: (C) <code>wait(500, MSEC)</code></p> <p>500 milliseconds = 0.5 seconds. MSEC = milliseconds (1000 MSEC = 1 second).</p> <p>Common Mistake: Confusing MSEC and SECONDS units.</p> <p>Reference: Tutorial 5.2, \"wait() Function\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-24","title":"Answer 24","text":"<p>Correct Answer:</p> <ul> <li>MSEC (milliseconds): 1/1000 of a second. Good for short pauses like 200ms = 0.2 seconds.</li> <li>SECONDS: Whole seconds. Good for longer waits.</li> </ul> <p>Example: <code>wait(200, MSEC)</code> = <code>wait(0.2, SECONDS)</code> (but decimals may not work in VEX Python)</p> <p>Reference: Tutorial 5.2, wait() function table</p>"},{"location":"05-autonomous/04-review-qa/#answer-25","title":"Answer 25","text":"<p>Correct: (B) <code>drivetrain.drive_for(FORWARD, 500, MM)</code></p> <ul> <li><code>drive_for()</code> is blocking - code waits until movement completes</li> <li><code>motor.spin()</code> is non-blocking - returns immediately, motor keeps spinning</li> </ul> <p>This is crucial for understanding how to overlap actions!</p> <p>Reference: Tutorial 5.2, \"Blocking vs Non-Blocking\" table</p>"},{"location":"05-autonomous/04-review-qa/#answer-26","title":"Answer 26","text":"<p>Correct: (B) Robot drives while intake is spinning, then intake stops</p> <p>Because <code>spin()</code> is non-blocking, the intake starts immediately, then <code>drive_for()</code> (blocking) starts. The robot drives forward WHILE the intake spins. After driving completes, the intake stops.</p> <p>Reference: Tutorial 5.2, \"Overlapping Actions\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-27","title":"Answer 27","text":"<p>Correct: (B) Overlapping actions - running simultaneously</p> <p>The diagram shows both intake and drive happening during the same 0-1.0 second window. This is how <code>spin()</code> (non-blocking) combined with <code>drive_for()</code> (blocking) creates parallel actions.</p> <p>Reference: Tutorial 5.2, \"Overlapping Actions\" timeline</p>"},{"location":"05-autonomous/04-review-qa/#answer-28","title":"Answer 28","text":"<p>Correct: True</p> <p><code>spin_for()</code> rotates a motor a specific amount and WAITS until complete (blocking). <code>spin()</code> starts the motor and returns immediately (non-blocking).</p> <p>Reference: Tutorial 5.2, \"Blocking vs Non-Blocking\" table</p>"},{"location":"05-autonomous/04-review-qa/#answer-29","title":"Answer 29","text":"<p>Correct: <code>150</code></p> <pre><code>wait(150, MSEC)\n</code></pre> <p>Optimized routines use shorter waits (150ms instead of 500ms) to save time while still allowing the robot to stabilize.</p> <p>Reference: Tutorial 5.2, \"After Optimization\" code example</p>"},{"location":"05-autonomous/04-review-qa/#answer-30","title":"Answer 30","text":"<p>Correct: (B) Wait times are too long</p> <p>Each <code>wait(500, MSEC)</code> is half a second. That's 1 second of just waiting per cycle! Reducing to 150ms saves significant time.</p> <p>Common Mistake: Not recognizing that waits accumulate and waste precious autonomous time.</p> <p>Reference: Tutorial 5.2, \"Before Optimization\" vs \"After Optimization\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-31","title":"Answer 31","text":"<p>Correct Answer:</p> <p>Two ways to optimize autonomous routines:</p> <ol> <li>Increase velocity - Higher drive/turn velocity means less time per movement</li> <li> <p><code>set_drive_velocity(70, PERCENT)</code> instead of 30%</p> </li> <li> <p>Reduce wait times - Shorter stabilization pauses</p> </li> <li><code>wait(150, MSEC)</code> instead of <code>wait(500, MSEC)</code></li> </ol> <p>Other valid answers: Overlap non-blocking actions, remove unnecessary movements, optimize path distance.</p> <p>Reference: Tutorial 5.2, \"Optimizing for Speed\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-32","title":"Answer 32","text":"<p>Correct: (B) About 2.8 seconds</p> Action Time Drive 500mm ~1.0s Wait 0.2s Turn 90\u00b0 ~0.8s Wait 0.2s Drive 300mm ~0.6s Total ~2.8s <p>Reference: Tutorial 5.2, timeline example</p>"},{"location":"05-autonomous/04-review-qa/#answer-33","title":"Answer 33","text":"<p>Correct: (B) Multiple actions executed in a specific order</p> <p>A sequence is a series of commands that run one after another in a defined order. Each step must complete (or be non-blocking) before the next begins.</p> <p>Reference: Tutorial 5.2, \"Sequencing Multiple Actions\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-34","title":"Answer 34","text":"<p>Correct: <code>MM</code> and <code>MSEC</code></p> <pre><code>def drive_and_wait(direction, distance):\n    drivetrain.drive_for(direction, distance, MM)\n    wait(150, MSEC)\n</code></pre> <p>Reference: Tutorial 5.2, \"Reusable Movement Functions\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-35","title":"Answer 35","text":"<p>Correct Answer:</p> <p>Helper functions like <code>drive_and_wait()</code> are useful because:</p> <ol> <li>Reduce code duplication - Write wait logic once, use everywhere</li> <li>Make code cleaner - Main routine is easier to read</li> <li>Easier to modify - Change wait time in one place affects all movements</li> <li>Prevent errors - Can't forget the wait() call</li> </ol> <p>Reference: Tutorial 5.2, \"Reusable Movement Functions\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-36","title":"Answer 36","text":"<p>Correct: False</p> <p>At the end of an autonomous routine, no wait() is needed because there's no next movement. The extra wait would just waste time.</p> <pre><code>drivetrain.drive_for(FORWARD, 300, MM)\n# No wait needed at end\n</code></pre> <p>Reference: Tutorial 5.2, \"After Optimization\" comment</p>"},{"location":"05-autonomous/04-review-qa/#answer-37","title":"Answer 37","text":"<p>Correct: (B) 2.2 seconds</p> <p>1.0s (drive) + 0.2s (wait) + 0.8s (turn) + 0.2s (wait) = 2.2 seconds</p> <p>Reference: Tutorial 5.2, \"Timing Table Template\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-38","title":"Answer 38","text":"<p>Correct Answer:</p> <p>Two specific changes to speed up the routine:</p> <ol> <li> <p>Increase velocities: <pre><code>drivetrain.set_drive_velocity(60, PERCENT)  # Was 30%\ndrivetrain.set_turn_velocity(40, PERCENT)   # Was 20%\n</code></pre></p> </li> <li> <p>Reduce wait times: <pre><code>wait(150, MSEC)  # Was 1 second\n</code></pre></p> </li> </ol> <p>Reference: Tutorial 5.2, \"Exercise: Optimize This Routine\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-39","title":"Answer 39","text":"<p>Correct: (B) Organizes code and makes it easier to debug</p> <p>Phases help you: - Know where you are in the routine timeline - Debug specific sections (if Phase 2 fails, you know where to look) - Plan time allocation (each phase gets ~5 seconds)</p> <p>Reference: Tutorial 5.3, \"15-Second Routine Template\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-40","title":"Answer 40","text":"<p>Correct Answer:</p> <ul> <li> <p><code>motor.spin()</code>: Non-blocking. Starts the motor spinning and immediately continues to the next line of code. The motor keeps spinning until you call <code>stop()</code>.</p> </li> <li> <p><code>motor.spin_for()</code>: Blocking. Rotates the motor a specific amount and WAITS until that rotation is complete before continuing.</p> </li> </ul> <p>Example use case: - Use <code>spin()</code> for continuous actions during driving (intake running while moving) - Use <code>spin_for()</code> when you need precise motor positioning before continuing</p> <p>Reference: Tutorial 5.2, \"Blocking vs Non-Blocking\"</p>"},{"location":"05-autonomous/04-review-qa/#part-3-push-back-autonomous-strategy-questions-41-60","title":"Part 3: Push Back Autonomous Strategy (Questions 41-60)","text":""},{"location":"05-autonomous/04-review-qa/#answer-41","title":"Answer 41","text":"<p>Correct: (C) 7 or more</p> <p>The Autonomous Win Point requires scoring 7+ blocks of your alliance color in goals.</p> <p>Reference: Tutorial 5.3, \"Autonomous Win Point Requirements\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-42","title":"Answer 42","text":"<p>Correct: 3</p> <p>Blocks must be scored in at least 3 different goals to count toward the Autonomous Win Point.</p> <p>Reference: Tutorial 5.3, \"Autonomous Win Point Checklist\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-43","title":"Answer 43","text":"<p>Correct: False</p> <p>To earn the Autonomous Win Point, NEITHER robot can be touching the park zone barrier at the end of autonomous. If either robot touches it, your alliance loses the bonus.</p> <p>Common Mistake: Thinking being in park zone is okay.</p> <p>Reference: Tutorial 5.3, \"Autonomous Win Point Checklist\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-44","title":"Answer 44","text":"<p>Correct Answer:</p> <p>All 4 requirements for the Autonomous Win Point:</p> <ol> <li>7+ blocks of your color scored</li> <li>Blocks in at least 3 different goals</li> <li>3+ blocks removed from loaders</li> <li>Neither robot touching the park zone barrier</li> </ol> <p>Miss ANY ONE = No bonus!</p> <p>Reference: Tutorial 5.3, \"Autonomous Win Point Requirements\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-45","title":"Answer 45","text":"<p>Correct: (C) 12' x 12'</p> <p>The Push Back field is 12 feet by 12 feet (144 square feet total, or about 3.66m x 3.66m).</p> <p>Reference: Tutorial 5.3, \"Push Back Field Layout\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-46","title":"Answer 46","text":"<p>Correct: (A) RED loader</p> <p>Looking at the field diagram, the RED loader is on the left side of the field and the BLUE loader is on the right. If you're the RED alliance starting on the left, the RED loader would be closest.</p> <p>Reference: Tutorial 5.3, field layout diagram</p>"},{"location":"05-autonomous/04-review-qa/#answer-47","title":"Answer 47","text":"<p>Correct: (B) The field layout is mirrored, so paths need to mirror too</p> <p>When starting from the left vs right, the goals and loaders are in different relative positions. To reach the same objectives, you need to mirror your turn directions (LEFT becomes RIGHT and vice versa).</p> <p>Reference: Tutorial 5.3, \"Planning Your Starting Position\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-48","title":"Answer 48","text":"<p>Correct: (B) Turn directions are mirrored</p> <p>The <code>autonomous_left()</code> turns RIGHT while <code>autonomous_right()</code> turns LEFT. This mirrors the path to account for the mirrored field layout when starting from opposite sides.</p> <p>Reference: Tutorial 5.3, left vs right autonomous code</p>"},{"location":"05-autonomous/04-review-qa/#answer-49","title":"Answer 49","text":"<p>Correct: 40 (or similar low value)</p> <pre><code>drivetrain.set_drive_velocity(40, PERCENT)\n</code></pre> <p>Lower velocity (like 40%) gives better control when pushing blocks. Higher speeds might scatter the blocks.</p> <p>Reference: Tutorial 5.3, \"Push Multiple Blocks\" code</p>"},{"location":"05-autonomous/04-review-qa/#answer-50","title":"Answer 50","text":"<p>Correct Answer:</p> <p>Pushing groups of blocks is more efficient because:</p> <ol> <li>Saves time - One movement can score multiple blocks</li> <li>Scoring requirement - Need 7+ blocks in 15 seconds; individual grabs are too slow</li> <li>Better strategy - Field has 88 blocks scattered; grouping maximizes points</li> </ol> <p>Reference: Tutorial 5.3, \"Strategy: Block Scoring\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-51","title":"Answer 51","text":"<p>Correct: (B) Drives forward while intake grabs a block</p> <p>The sequence: 1. <code>spin()</code> (non-blocking) starts the intake 2. <code>drive_for()</code> (blocking) moves toward the block while intake runs 3. <code>wait()</code> gives extra time to secure the block 4. <code>stop()</code> stops the intake after block is grabbed</p> <p>Reference: Tutorial 5.3, \"With Intake Mechanism\" code</p>"},{"location":"05-autonomous/04-review-qa/#answer-52","title":"Answer 52","text":"<p>Correct: (B) <code>intake_motor.spin(REVERSE)</code></p> <p>To release a grabbed block, spin the intake in REVERSE direction. This ejects the block from the mechanism.</p> <p>Reference: Tutorial 5.3, \"grab_and_score()\" function</p>"},{"location":"05-autonomous/04-review-qa/#answer-53","title":"Answer 53","text":"<p>Correct Answer (examples):</p> <pre><code># === PHASE 1: SCORE FIRST BLOCK (0-5 sec) ===\n# === PHASE 2: SECOND GOAL (5-10 sec) ===\n# === PHASE 3: CLEAR LOADER (10-15 sec) ===\n</code></pre> <p>Or similar phase descriptions like: - PHASE 1: APPROACH / DRIVE TO BLOCK - PHASE 2: TURN AND PUSH / SCORE GOAL - PHASE 3: POSITION / FINAL PUSH</p> <p>Reference: Tutorial 5.3, \"15-Second Routine Template\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-54","title":"Answer 54","text":"<p>Correct: (B) Area with pre-stacked blocks to remove</p> <p>Loaders are zones on the field where blocks are pre-stacked. Removing 3+ blocks from loaders is one of the Autonomous Win Point requirements.</p> <p>Reference: Tutorial 5.3, \"Strategy: Clearing Loaders\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-55","title":"Answer 55","text":"<p>Correct: True</p> <p>Removing 3 or more blocks from loaders is one of the 4 requirements for the Autonomous Win Point.</p> <p>Reference: Tutorial 5.3, \"Autonomous Win Point Requirements\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-56","title":"Answer 56","text":"<p>Correct Answer:</p> <p>Sketching your path first helps because:</p> <ol> <li>Visualize the strategy - See the whole routine before coding</li> <li>Identify obstacles - Notice walls, other blocks, or impossible paths</li> <li>Estimate distances - Measure on paper before measuring on field</li> <li>Plan timing - Count movements to ensure &lt;15 seconds</li> <li>Communicate with team - Show others your plan</li> </ol> <p>Reference: Tutorial 5.3, \"Testing Your Autonomous - Step 1\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-57","title":"Answer 57","text":"<p>Correct: (C) Draw your path on paper</p> <p>The testing process starts with: 1. Draw your path (first!) 2. Measure distances 3. Code and test 4. Iterate</p> <p>Reference: Tutorial 5.3, \"Testing Your Autonomous\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-58","title":"Answer 58","text":"<p>Correct: (D) Both A and B</p> <p>The code has TWO problems: 1. No <code>setup_autonomous()</code> call - Missing velocity and timeout configuration 2. Likely takes more than 15 seconds - 2000mm + 180\u00b0 + 1500mm + 90\u00b0 at default speeds is too long</p> <p>Reference: Tutorial 5.3 and 5.1</p>"},{"location":"05-autonomous/04-review-qa/#answer-59","title":"Answer 59","text":"<p>Correct: 500 (or any reasonable test distance)</p> <pre><code>def test_auto():\n    setup_autonomous()\n    drivetrain.drive_for(FORWARD, 500, MM)\n    # Test this first, then add more\n</code></pre> <p>Start with a single movement, verify it works, then add the next step incrementally.</p> <p>Reference: Tutorial 5.3, \"Step 3: Code and Test\"</p>"},{"location":"05-autonomous/04-review-qa/#answer-60","title":"Answer 60","text":"<p>Correct Answer:</p> <p>The 4-step iterative testing process:</p> <ol> <li>Run the routine - Execute the current code on the field</li> <li>Watch where the robot ends up - Observe actual vs expected position</li> <li>Adjust distances and angles - Tune the numbers based on observations</li> <li>Repeat! - Test again with the adjustments</li> </ol> <p>This cycle continues until the routine is reliable.</p> <p>Reference: Tutorial 5.3, \"Step 4: Iterate\"</p>"},{"location":"05-autonomous/04-review-qa/#quick-reference-cheat-sheet","title":"Quick Reference Cheat Sheet","text":""},{"location":"05-autonomous/04-review-qa/#essential-commands","title":"Essential Commands","text":"<pre><code># Setup\nsetup_autonomous()  # Always call first!\n\n# Driving\ndrivetrain.drive_for(FORWARD, distance, MM)\ndrivetrain.drive_for(REVERSE, distance, MM)\n\n# Turning\ndrivetrain.turn_for(RIGHT, angle, DEGREES)\ndrivetrain.turn_for(LEFT, angle, DEGREES)\n\n# Configuration\ndrivetrain.set_drive_velocity(50, PERCENT)\ndrivetrain.set_turn_velocity(30, PERCENT)\ndrivetrain.set_stopping(BRAKE)  # or COAST, HOLD\ndrivetrain.set_timeout(3, SECONDS)\n\n# Waiting\nwait(200, MSEC)    # 0.2 seconds\nwait(1, SECONDS)   # 1 second\n</code></pre>"},{"location":"05-autonomous/04-review-qa/#blocking-vs-non-blocking","title":"Blocking vs Non-Blocking","text":"Blocking (Waits) Non-Blocking (Returns) <code>drive_for()</code> <code>motor.spin()</code> <code>turn_for()</code> - <code>spin_for()</code> -"},{"location":"05-autonomous/04-review-qa/#time-estimates-at-50-velocity","title":"Time Estimates (at 50% velocity)","text":"Action Approximate Time Drive 500mm ~1.0 second Drive 1000mm ~2.0 seconds Turn 90\u00b0 ~0.8 seconds Turn 180\u00b0 ~1.6 seconds Stabilization wait 0.15-0.2 seconds"},{"location":"05-autonomous/04-review-qa/#push-back-autonomous-win-point","title":"Push Back Autonomous Win Point","text":"<pre><code>[ ] 7+ blocks of your color scored\n[ ] Blocks in at least 3 different goals\n[ ] 3+ blocks removed from loaders\n[ ] Neither robot touching park zone barrier\n</code></pre>"},{"location":"05-autonomous/04-review-qa/#pattern-formulas","title":"Pattern Formulas","text":"Shape Sides Turn Angle Triangle 3 120\u00b0 (360\u00f73) Square 4 90\u00b0 (360\u00f74) Pentagon 5 72\u00b0 (360\u00f75) Hexagon 6 60\u00b0 (360\u00f76)"},{"location":"05-autonomous/04-review-qa/#optimization-checklist","title":"Optimization Checklist","text":"<ul> <li>[ ] Increase velocity (50% \u2192 70%)</li> <li>[ ] Reduce waits (500ms \u2192 150ms)</li> <li>[ ] Overlap non-blocking actions</li> <li>[ ] Remove unnecessary movements</li> <li>[ ] Optimize path (shorter distances)</li> </ul> <p>\u2190 Previous: Push Back Autonomous | Next: Competition Strategy \u2192</p>"},{"location":"06-competition-strategy/01-game-overview/","title":"Tutorial 6.1: Push Back Game Overview","text":"<p>Time: ~10 minutes Prerequisites: Tutorial 5: Autonomous Programming</p>"},{"location":"06-competition-strategy/01-game-overview/#welcome-to-push-back","title":"Welcome to Push Back!","text":"<p>Push Back is the VEX V5 Robotics Competition game for the 2025-2026 season. Here's everything you need to know!</p>"},{"location":"06-competition-strategy/01-game-overview/#the-field","title":"The Field","text":"<pre><code>    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    \u2551                       PUSH BACK FIELD                        \u2551\n    \u2551                         12' x 12'                            \u2551\n    \u2551                        (3.6m x 3.6m)                         \u2551\n    \u2551                                                              \u2551\n    \u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2551\n    \u2551  \u2502              \u2502    \u2502    CENTER    \u2502    \u2502              \u2502   \u2551\n    \u2551  \u2502  LONG GOAL   \u2502    \u2502     GOAL     \u2502    \u2502  LONG GOAL   \u2502   \u2551\n    \u2551  \u2502   (14 max)   \u2502    \u2502   (7 upper)  \u2502    \u2502   (14 max)   \u2502   \u2551\n    \u2551  \u2502              \u2502    \u2502   (7 lower)  \u2502    \u2502              \u2502   \u2551\n    \u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2551\n    \u2551                                                              \u2551\n    \u2551         \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593                \u2551\n    \u2551              88 BLOCKS (44 red, 44 blue)                     \u2551\n    \u2551         \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593                \u2551\n    \u2551                                                              \u2551\n    \u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2551\n    \u2551  \u2502 LOADER \u2502                                  \u2502 LOADER \u2502     \u2551\n    \u2551  \u2502  RED   \u2502                                  \u2502  BLUE  \u2502     \u2551\n    \u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2551\n    \u2551                                                              \u2551\n    \u2551  \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557                          \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557     \u2551\n    \u2551  \u2551  PARK ZONE \u2551                          \u2551  PARK ZONE \u2551     \u2551\n    \u2551  \u2551    RED     \u2551                          \u2551    BLUE    \u2551     \u2551\n    \u2551  \u2551  18\" x 16\" \u2551                          \u2551  18\" x 16\" \u2551     \u2551\n    \u2551  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d                          \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d     \u2551\n    \u2551                                                              \u2551\n    \u2551  [RED ALLIANCE STATION]      [BLUE ALLIANCE STATION]        \u2551\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n</code></pre>"},{"location":"06-competition-strategy/01-game-overview/#match-structure","title":"Match Structure","text":"<pre><code>timeline\n    title Match Timeline (Total: 2 minutes)\n    section Autonomous (15 sec)\n        Pre-programmed : No human control\n        : 10 pt bonus available\n    section Driver Control (1 min 45 sec)\n        Drivers control robots : Full control of robot\n        : Main scoring period</code></pre>"},{"location":"06-competition-strategy/01-game-overview/#scoring-summary","title":"Scoring Summary","text":"Action Points Notes Block Scored 3 Each block in any goal Long Goal Zone 10 Majority control of zone Center Goal (Upper) 8 Majority control Center Goal (Lower) 6 Majority control 1 Robot Parked 8 In your alliance's zone 2 Robots Parked 30 BOTH robots in zone! Autonomous Bonus 10 Win autonomous period"},{"location":"06-competition-strategy/01-game-overview/#autonomous-win-point","title":"Autonomous Win Point","text":"<p>To earn the Autonomous Win Point, your alliance must:</p> <pre><code>    \u2611 Score 7+ blocks of your color\n    \u2611 Score in at least 3 different goals\n    \u2611 Remove 3+ blocks from loaders\n    \u2611 Neither robot touching park barrier at end\n\n    ALL four conditions must be met!\n</code></pre>"},{"location":"06-competition-strategy/01-game-overview/#game-objects","title":"Game Objects","text":""},{"location":"06-competition-strategy/01-game-overview/#blocks","title":"Blocks","text":"<pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502       \u2502  Size: 5\" x 5\" x 5\"\n    \u2502  RED  \u2502  Weight: ~100g\n    \u2502       \u2502  88 total (44 per alliance)\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"06-competition-strategy/01-game-overview/#goals","title":"Goals","text":"<pre><code>    LONG GOAL (x2)        CENTER GOAL (x1)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                \u2502    \u2502     UPPER      \u2502\n    \u2502  Holds up to   \u2502    \u2502   (7 blocks)   \u2502\n    \u2502   14 blocks    \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502                \u2502    \u2502     LOWER      \u2502\n    \u2502                \u2502    \u2502   (7 blocks)   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"06-competition-strategy/01-game-overview/#alliances","title":"Alliances","text":"<pre><code>flowchart TB\n    subgraph RED[\"RED ALLIANCE\"]\n        RA[\"Team A\"] --- RB[\"Team B\"]\n    end\n    subgraph BLUE[\"BLUE ALLIANCE\"]\n        BC[\"Team C\"] --- BD[\"Team D\"]\n    end\n    RED &lt;-- \"vs\" --&gt; BLUE\n    RED -.- R2[\"2 robots work together\"]\n    BLUE -.- B2[\"2 robots work together\"]</code></pre>"},{"location":"06-competition-strategy/01-game-overview/#key-game-mechanics","title":"Key Game Mechanics","text":""},{"location":"06-competition-strategy/01-game-overview/#1-descoring-is-allowed","title":"1. Descoring is ALLOWED!","text":"<p>You can remove opponent blocks from goals:</p> <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 \ud83d\udd35 \ud83d\udd35 \ud83d\udd35       \u2502   \u2192    \u2502 \ud83d\udd35 \ud83d\udd35          \u2502\n    \u2502      \ud83d\udd34 \ud83d\udd34 \ud83d\udd34  \u2502        \u2502                \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Push opponent blocks OUT of the goal!\n</code></pre>"},{"location":"06-competition-strategy/01-game-overview/#2-zone-control","title":"2. Zone Control","text":"<p>Majority of blocks = control the zone:</p> <pre><code>flowchart TD\n    Z1[\"Zone has 5 blocks: 3 Red, 2 Blue\"]\n    Z1 --&gt; R1[\"RED controls (3 vs 2)\"]\n\n    Z2[\"Zone has 4 blocks: 2 Red, 2 Blue\"]\n    Z2 --&gt; N1[\"NO control (tie)\"]</code></pre>"},{"location":"06-competition-strategy/01-game-overview/#3-parking-bonus","title":"3. Parking Bonus","text":"<pre><code>    1 ROBOT PARKED:        2 ROBOTS PARKED:\n    \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557         \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551   [ROBOT]  \u2551         \u2551 [R1] [R2]  \u2551\n    \u2551     8 pts  \u2551         \u2551   30 pts!  \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d         \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\n    30 points is HUGE - don't forget!\n</code></pre>"},{"location":"06-competition-strategy/01-game-overview/#quick-reference-card","title":"Quick Reference Card","text":"<pre><code>    \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551              PUSH BACK QUICK REFERENCE               \u2551\n    \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n    \u2551  SCORING:                                            \u2551\n    \u2551    Block scored        = 3 pts                       \u2551\n    \u2551    Long goal zone      = 10 pts                      \u2551\n    \u2551    Center upper zone   = 8 pts                       \u2551\n    \u2551    Center lower zone   = 6 pts                       \u2551\n    \u2551    1 robot parked      = 8 pts                       \u2551\n    \u2551    2 robots parked     = 30 pts                      \u2551\n    \u2551    Autonomous bonus    = 10 pts                      \u2551\n    \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n    \u2551  KEY RULES:                                          \u2551\n    \u2551    - Descoring allowed                               \u2551\n    \u2551    - Zone = majority of blocks                       \u2551\n    \u2551    - Park in last 10 seconds!                        \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre> <p>\u2190 Previous: Push Back Autonomous | Next: Scoring Strategies \u2192</p>"},{"location":"06-competition-strategy/02-scoring-strategies/","title":"Tutorial 6.2: Scoring Strategies","text":"<p>Time: ~10 minutes Prerequisites: Tutorial 6.1: Game Overview</p>"},{"location":"06-competition-strategy/02-scoring-strategies/#points-per-action-analysis","title":"Points Per Action Analysis","text":"<p>Let's calculate which actions give the most points per second:</p> Action Points Time (est.) Points/Second Score 1 block 3 ~3 sec 1.0 Score 5 blocks (push) 15 ~5 sec 3.0 Win zone (5 blocks) 10 ~5 sec 2.0 Descore 3 blocks +9* ~4 sec 2.25 Park 2 robots 30 ~10 sec 3.0 <p>*Descoring swings points: you remove 3 pts AND deny zone control</p> <p>Key Insight: Parking 2 robots is extremely valuable!</p>"},{"location":"06-competition-strategy/02-scoring-strategies/#strategy-1-volume-scoring","title":"Strategy 1: Volume Scoring","text":"<p>Focus on scoring as many blocks as possible:</p> <pre><code>    VOLUME STRATEGY:\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  Push groups of blocks, not individuals \u2502\n    \u2502                                         \u2502\n    \u2502    \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n    \u2502         \u2193            \u2502              \u2502   \u2502\n    \u2502    [ROBOT] \u2192\u2192\u2192\u2192\u2192\u2192\u2192\u2192  \u2502    GOAL      \u2502   \u2502\n    \u2502         Push 4-5     \u2502              \u2502   \u2502\n    \u2502         at once!     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Pros: - High point potential - Simple robot design (just push) - Works in autonomous and driver</p> <p>Cons: - Blocks scatter easily - Opponent can descore</p>"},{"location":"06-competition-strategy/02-scoring-strategies/#strategy-2-zone-control","title":"Strategy 2: Zone Control","text":"<p>Focus on controlling high-value zones:</p> <pre><code>flowchart TD\n    P[\"ZONE CONTROL PRIORITY\"]\n    P --&gt; L[\"1. Long Goals (10 pts each)\"]\n    L --&gt; LD[\"Control with 3+ blocks = 10 points\"]\n\n    P --&gt; U[\"2. Center Upper (8 pts)\"]\n    U --&gt; UD[\"Harder to access = 8 points\"]\n\n    P --&gt; LO[\"3. Center Lower (6 pts)\"]\n    LO --&gt; LOD[\"Easier to descore = 6 points\"]</code></pre> <p>Strategy: Put 3 blocks in a zone, then defend it!</p>"},{"location":"06-competition-strategy/02-scoring-strategies/#strategy-3-descoring","title":"Strategy 3: Descoring","text":"<p>Remove opponent blocks to swing points:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Before\n    Before : Zone has 3 Blue, 2 Red\n    Before : Blue controls (+10 Blue)\n\n    Before --&gt; After : Descore 2 blue blocks\n\n    After : Zone has 1 Blue, 2 Red\n    After : RED controls (+10 Red)\n    After --&gt; [*]\n\n    note right of After : Point swing: 20 points!</code></pre> <p>Best Descoring Targets: - Goals with slim opponent majority - Opponent blocks near the edge - Undefended zones</p>"},{"location":"06-competition-strategy/02-scoring-strategies/#strategy-4-parking-priority","title":"Strategy 4: Parking Priority","text":"<p>Never forget parking! It's the most efficient scoring late-game.</p> <pre><code>timeline\n    title End-Game Timeline\n    section 1:50\n        Start heading to park\n    section 1:55\n        Both robots in zone\n    section 2:00\n        Match ends</code></pre> <p>Note: 10-15 seconds before end: HEAD TO PARK ZONE!</p> <p>Parking Math: | Situation | Points | Worth It? | |-----------|--------|-----------| | 1 robot parks | 8 | Yes if scoring &lt;3 blocks | | 2 robots park | 30 | Almost always worth it! |</p>"},{"location":"06-competition-strategy/02-scoring-strategies/#combined-strategy-example","title":"Combined Strategy Example","text":""},{"location":"06-competition-strategy/02-scoring-strategies/#match-plan","title":"Match Plan","text":"<pre><code>timeline\n    title Combined Strategy Match Plan\n    section AUTONOMOUS (0-15 sec)\n        Score 3+ blocks in different goals\n        : Clear loader (3+ blocks)\n        : Don't touch park barrier!\n    section DRIVER PHASE 1 (15 sec - 1:00)\n        Push blocks into goals\n        : Focus on zone control\n        : Communicate with partner\n    section DRIVER PHASE 2 (1:00 - 1:50)\n        Defend your zones\n        : Descore opponent if winning zones\n        : Keep scoring if behind\n    section END GAME (1:50 - 2:00)\n        STOP SCORING\n        : Both robots head to park\n        : 30 points for double park!</code></pre>"},{"location":"06-competition-strategy/02-scoring-strategies/#role-specialization","title":"Role Specialization","text":""},{"location":"06-competition-strategy/02-scoring-strategies/#robot-a-scorer","title":"Robot A: Scorer","text":"<pre><code>    Focus:\n    - Fast block collection\n    - High-volume scoring\n    - Works the center field\n\n    Design:\n    - Fast drivetrain\n    - Intake mechanism\n    - Good maneuverability\n</code></pre>"},{"location":"06-competition-strategy/02-scoring-strategies/#robot-b-defendersupport","title":"Robot B: Defender/Support","text":"<pre><code>    Focus:\n    - Zone defense\n    - Descoring\n    - Parking management\n\n    Design:\n    - Strong pushing power\n    - Low center of gravity\n    - Durable construction\n</code></pre>"},{"location":"06-competition-strategy/02-scoring-strategies/#point-calculator","title":"Point Calculator","text":"<p>Use this to estimate match scores:</p> <pre><code>    YOUR ALLIANCE:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Blocks scored:      ___ \u00d7 3 = ___     \u2502\n    \u2502 Long goal zones:    ___ \u00d7 10 = ___    \u2502\n    \u2502 Center upper zone:  ___ \u00d7 8 = ___     \u2502\n    \u2502 Center lower zone:  ___ \u00d7 6 = ___     \u2502\n    \u2502 Robots parked:      1=8, 2=30 = ___   \u2502\n    \u2502 Autonomous bonus:   10 = ___          \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502 TOTAL:                        ___     \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"06-competition-strategy/02-scoring-strategies/#exercise-strategy-analysis","title":"Exercise: Strategy Analysis","text":"<p>Scenario: Your alliance has: - 15 blocks scored (45 pts) - 1 long goal zone (10 pts) - 0 robots parked</p> <p>Time remaining: 20 seconds</p> <p>Question 1: Should you score more blocks or park?</p> <p>Question 2: If your partner is closer to the park zone, what should they do?</p>"},{"location":"06-competition-strategy/02-scoring-strategies/#answers","title":"Answers","text":"<p>Question 1: PARK! Two robots parking = 30 points. You'd need to score 10 more blocks in 20 seconds to equal that. Parking is almost always better in end-game.</p> <p>Question 2: Your partner should head to park zone immediately. You should follow as soon as possible. 30 points for double park!</p> <p>\u2190 Previous: Game Overview | Next: Alliance Coordination \u2192</p>"},{"location":"06-competition-strategy/03-alliance-coordination/","title":"Tutorial 6.3: Alliance Coordination","text":"<p>Time: ~10 minutes Prerequisites: Tutorial 6.2: Scoring Strategies</p>"},{"location":"06-competition-strategy/03-alliance-coordination/#working-as-an-alliance","title":"Working as an Alliance","text":"<p>In VEX competitions, you're paired with another team. Success depends on coordination!</p> <pre><code>flowchart TB\n    subgraph Alliance[\"YOUR ALLIANCE\"]\n        subgraph YT[\"YOUR TEAM\"]\n            YR[\"Robot\"]\n        end\n        subgraph PT[\"PARTNER TEAM\"]\n            PR[\"Robot\"]\n        end\n    end\n    YT --- PT\n    Alliance -.- Note[\"Same goals, same score, same fate!\"]</code></pre>"},{"location":"06-competition-strategy/03-alliance-coordination/#pre-match-communication","title":"Pre-Match Communication","text":""},{"location":"06-competition-strategy/03-alliance-coordination/#what-to-discuss","title":"What to Discuss","text":"<pre><code>    ALLIANCE MEETING CHECKLIST:\n\n    \u25a1 Autonomous routines\n      - What does each robot do?\n      - Do they conflict?\n\n    \u25a1 Role assignments\n      - Who scores? Who defends?\n      - Who parks first?\n\n    \u25a1 Field zones\n      - Who takes left side?\n      - Who takes right side?\n\n    \u25a1 End-game plan\n      - When do we park?\n      - Signal for parking?\n</code></pre>"},{"location":"06-competition-strategy/03-alliance-coordination/#autonomous-coordination","title":"Autonomous Coordination","text":"<pre><code>    GOOD PLAN:                 BAD PLAN:\n\n    Robot A: Left side         Robot A: Center\n    Robot B: Right side        Robot B: Also center\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  A \u2192     \u2190 B   \u2502        \u2502     A \u2194 B       \u2502\n    \u2502 (no conflict)   \u2502        \u2502   (COLLISION!)  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"06-competition-strategy/03-alliance-coordination/#during-the-match","title":"During the Match","text":""},{"location":"06-competition-strategy/03-alliance-coordination/#communication-methods","title":"Communication Methods","text":"Method Pros Cons Verbal Quick, natural Noisy venue Hand signals Visible across field Need practice Pre-planned No thinking needed Less flexible"},{"location":"06-competition-strategy/03-alliance-coordination/#simple-signal-system","title":"Simple Signal System","text":"<pre><code>    SUGGESTED SIGNALS:\n\n    Open hand = \"I'm going to park\"\n    Point at goal = \"Score there\"\n    Fist = \"I'll defend\"\n    Wave = \"Help me!\"\n</code></pre>"},{"location":"06-competition-strategy/03-alliance-coordination/#zone-division","title":"Zone Division","text":"<pre><code>    FIELD ZONES:\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502             \u2502             \u2502\n    \u2502  ROBOT A    \u2502  ROBOT B    \u2502\n    \u2502  ZONE       \u2502  ZONE       \u2502\n    \u2502             \u2502             \u2502\n    \u2502   (Left)    \u2502   (Right)   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Each robot owns their zone:\n    - Score blocks in your zone\n    - Defend goals in your zone\n    - Don't cross unless needed\n</code></pre>"},{"location":"06-competition-strategy/03-alliance-coordination/#role-strategies","title":"Role Strategies","text":"<pre><code>flowchart TD\n    RS[\"Role Strategies\"] --&gt; OO[\"Offense + Offense\"]\n    RS --&gt; OD[\"Offense + Defense\"]\n    RS --&gt; SS[\"Split Strategy\"]\n\n    OO --&gt; OOD[\"Both robots focus on scoring\"]\n    OOD --&gt; OOA[\"Robot A: Left goals, left blocks\"]\n    OOD --&gt; OOB[\"Robot B: Right goals, right blocks\"]\n    OO -.- OOBest[\"Best when: Both robots are fast scorers\"]\n    OO -.- OORisk[\"Risk: No defense, vulnerable to descoring\"]\n\n    OD --&gt; ODD[\"Robot A: Scores blocks&lt;br/&gt;Robot B: Defends goals, descores\"]\n    OD -.- ODBest[\"Best when: One robot is better at pushing\"]\n    OD -.- ODRisk[\"Risk: Lower total score potential\"]\n\n    SS --&gt; SSD[\"Phase 1 (0-1:30): Both score&lt;br/&gt;Phase 2 (1:30-1:50): One defends, one scores&lt;br/&gt;Phase 3 (1:50-2:00): Both park\"]\n    SS -.- SSBest[\"Best when: Flexible, adaptable teams\"]</code></pre>"},{"location":"06-competition-strategy/03-alliance-coordination/#end-game-coordination","title":"End-Game Coordination","text":""},{"location":"06-competition-strategy/03-alliance-coordination/#the-10-second-rule","title":"The 10-Second Rule","text":"<p>CRITICAL: With 10 seconds left... STOP SCORING, START PARKING!</p> <pre><code>timeline\n    title 10-Second Rule Timing\n    section 1:50\n        Head to park zone\n    section 1:55\n        Both robots in position\n    section 2:00\n        Match ends, 30 pts!</code></pre>"},{"location":"06-competition-strategy/03-alliance-coordination/#parking-order","title":"Parking Order","text":"<pre><code>flowchart TD\n    Q[\"WHO PARKS FIRST?\"]\n    Q --&gt; O1[\"Option 1: Closer robot parks first\"]\n    Q --&gt; O2[\"Option 2: Slower robot parks first\"]\n    Q --&gt; O3[\"Option 3: Pre-assigned\"]\n\n    O1 --&gt; O1D[\"A is closer to park zone&lt;br/&gt;A parks first\"]\n    O2 --&gt; O2D[\"Give slower robot more time\"]\n    O3 --&gt; O3D[\"Decide before match\"]</code></pre>"},{"location":"06-competition-strategy/03-alliance-coordination/#scouting-other-teams","title":"Scouting Other Teams","text":""},{"location":"06-competition-strategy/03-alliance-coordination/#what-to-look-for","title":"What to Look For","text":"<pre><code>    SCOUTING CHECKLIST:\n\n    \u25a1 Robot capabilities\n      - Fast or strong?\n      - Good at scoring or descoring?\n      - Reliable autonomous?\n\n    \u25a1 Driver skill\n      - Precise or sloppy?\n      - Fast reactions?\n\n    \u25a1 Common strategies\n      - Do they descore a lot?\n      - Do they forget to park?\n\n    \u25a1 Weaknesses\n      - Tipping issues?\n      - Slow?\n      - Unreliable mechanisms?\n</code></pre>"},{"location":"06-competition-strategy/03-alliance-coordination/#scouting-sheet-template","title":"Scouting Sheet Template","text":"<pre><code>    \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551           SCOUTING SHEET                  \u2551\n    \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n    \u2551 Team Number: ___________                  \u2551\n    \u2551 Robot Name: ____________                  \u2551\n    \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n    \u2551 AUTONOMOUS:                               \u2551\n    \u2551   Score (1-5): ___                        \u2551\n    \u2551   Notes: _________________________        \u2551\n    \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n    \u2551 DRIVER:                                   \u2551\n    \u2551   Speed (1-5): ___                        \u2551\n    \u2551   Control (1-5): ___                      \u2551\n    \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n    \u2551 STRENGTHS: ________________________       \u2551\n    \u2551 WEAKNESSES: _______________________       \u2551\n    \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n    \u2551 GOOD PARTNER?  YES / MAYBE / NO           \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre>"},{"location":"06-competition-strategy/03-alliance-coordination/#communication-during-autonomous","title":"Communication During Autonomous","text":"<p>You CAN'T talk during autonomous (no human control), but you CAN plan ahead:</p> <pre><code>    PRE-MATCH PLAN:\n\n    \"During autonomous, I'll go left\n     and score in the left long goal.\n\n     You go right and clear the loader.\n\n     We'll meet in the middle after\n     autonomous ends.\"\n</code></pre>"},{"location":"06-competition-strategy/03-alliance-coordination/#exercise-alliance-strategy-card","title":"Exercise: Alliance Strategy Card","text":"<p>Create a strategy card for your alliance:</p> <pre><code>    \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551         ALLIANCE STRATEGY CARD            \u2551\n    \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n    \u2551 OUR TEAM: _________  PARTNER: _________   \u2551\n    \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n    \u2551 AUTONOMOUS:                               \u2551\n    \u2551   Our robot: ________________________     \u2551\n    \u2551   Partner:   ________________________     \u2551\n    \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n    \u2551 DRIVER CONTROL:                           \u2551\n    \u2551   Our role:  \u2610 Scorer  \u2610 Defender         \u2551\n    \u2551   Our zone:  \u2610 Left    \u2610 Right            \u2551\n    \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n    \u2551 END GAME:                                 \u2551\n    \u2551   Who parks first? __________             \u2551\n    \u2551   Park signal: ________________           \u2551\n    \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n    \u2551 SPECIAL NOTES:                            \u2551\n    \u2551   _____________________________________   \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre> <p>\u2190 Previous: Scoring Strategies | Next: Review Q&amp;A \u2192</p>"},{"location":"06-competition-strategy/04-review-qa/","title":"Competition Strategy: Q&amp;A Review","text":"<p>Time: ~20 minutes Purpose: Test your understanding of Push Back game rules, scoring strategies, and alliance coordination</p>"},{"location":"06-competition-strategy/04-review-qa/#how-to-use-this-review","title":"How to Use This Review","text":"<ol> <li>Try each section without looking at answers</li> <li>Check your answers at the end</li> <li>Review tutorials for any topics you missed</li> <li>Aim for 80%+ before moving to advanced topics</li> </ol>"},{"location":"06-competition-strategy/04-review-qa/#section-1-true-or-false-15-questions","title":"Section 1: True or False (15 Questions)","text":"<p>Write T (True) or F (False) for each statement.</p> <ol> <li> <p>Push Back is played on a 10' x 10' field.</p> </li> <li> <p>A match consists of 15 seconds of autonomous and 1 minute 45 seconds of driver control.</p> </li> <li> <p>Each block scored in a goal is worth 5 points.</p> </li> <li> <p>There are 88 blocks on the field, with 44 for each alliance.</p> </li> <li> <p>Descoring (removing opponent blocks from goals) is NOT allowed in Push Back.</p> </li> <li> <p>To control a zone, you need a majority of blocks (more than opponent).</p> </li> <li> <p>If both robots park in your alliance's zone, you earn 30 points.</p> </li> <li> <p>The autonomous bonus is worth 10 points.</p> </li> <li> <p>To earn the Autonomous Win Point, you only need to score 5 blocks.</p> </li> <li> <p>The center goal has two sections: upper (8 pts) and lower (6 pts).</p> </li> <li> <p>Each long goal can hold up to 14 blocks.</p> </li> <li> <p>If a zone has a tie (equal blocks from each alliance), both teams get zone points.</p> </li> <li> <p>You should stop scoring and head to park with about 10 seconds remaining.</p> </li> <li> <p>During autonomous, you can use hand signals to communicate with your partner.</p> </li> <li> <p>Scouting other teams before a match can help you plan your strategy.</p> </li> </ol>"},{"location":"06-competition-strategy/04-review-qa/#section-2-multiple-choice-20-questions","title":"Section 2: Multiple Choice (20 Questions)","text":"<p>Circle the best answer for each question.</p> <p>16. What is the total match time in Push Back? - A) 1 minute - B) 1 minute 30 seconds - C) 2 minutes - D) 3 minutes</p> <p>17. How many points is each block worth when scored in a goal? - A) 1 point - B) 2 points - C) 3 points - D) 5 points</p> <p>18. What is the point value for controlling a Long Goal zone? - A) 6 points - B) 8 points - C) 10 points - D) 12 points</p> <p>19. What is the parking bonus when ONLY ONE robot parks? - A) 5 points - B) 8 points - C) 15 points - D) 30 points</p> <p>20. What are the four requirements for the Autonomous Win Point? - A) Score 7+ blocks, 3+ goals, clear 3+ loader blocks, don't touch park barrier - B) Score 10+ blocks, 4+ goals, park both robots - C) Score 5+ blocks, 2+ goals, clear loader - D) Score all blocks, control all zones</p> <p>21. Which strategy focuses on pushing many blocks at once into goals? - A) Zone Control - B) Volume Scoring - C) Descoring - D) Defense</p> <p>22. What does \"descoring\" mean in Push Back? - A) Scoring blocks quickly - B) Removing opponent blocks from goals - C) Parking both robots - D) Winning autonomous</p> <p>23. In the \"10-second rule,\" what should you do with 10 seconds left? - A) Score as many blocks as possible - B) Descore opponent blocks - C) Stop scoring and head to park zone - D) Block the opponent's robot</p> <p>24. What is the point value for controlling the Center Goal Upper section? - A) 6 points - B) 8 points - C) 10 points - D) 12 points</p> <p>25. In an Offense + Defense role strategy, what does the defending robot focus on? - A) Scoring blocks quickly - B) Defending goals and descoring - C) Only parking - D) Staying still</p> <p>26. What communication method works best in a noisy venue? - A) Verbal commands - B) Hand signals - C) Whistle codes - D) Shouting louder</p> <p>27. When should the slower robot typically park in end-game? - A) Never - B) First (to have more time) - C) Last - D) Both robots park at exactly the same time</p> <p>28. How many goals are on the Push Back field? - A) 2 (one long goal and one center goal) - B) 3 (two long goals and one center goal) - C) 4 (two long goals and two center goals) - D) 4 (four long goals)</p> <p>29. What does zone division help prevent during driver control? - A) Scoring blocks - B) Robots colliding with each other - C) Parking - D) Winning</p> <p>30. What is the CENTER GOAL LOWER zone worth? - A) 4 points - B) 6 points - C) 8 points - D) 10 points</p> <p>31. Which of these is NOT on a scouting checklist? - A) Robot speed - B) Driver skill - C) Favorite color - D) Common strategies</p> <p>32. When using the \"Split Strategy,\" what happens in Phase 3 (1:50-2:00)? - A) Both robots score aggressively - B) One defends, one scores - C) Both robots park - D) Robots switch zones</p> <p>33. What makes a volume scoring strategy risky? - A) It takes too long - B) Blocks scatter easily and can be descored - C) It requires complex programming - D) It doesn't earn any points</p> <p>34. How many blocks does the Center Goal hold (upper + lower)? - A) 7 blocks - B) 10 blocks - C) 14 blocks - D) 21 blocks</p> <p>35. If a zone has 5 blocks and your alliance has 3 of them, who controls the zone? - A) No one (tie) - B) Your alliance (3 &gt; 2 = majority) - C) Opponent - D) Both alliances split points</p>"},{"location":"06-competition-strategy/04-review-qa/#section-3-fill-in-the-blank-10-questions","title":"Section 3: Fill in the Blank (10 Questions)","text":"<p>Complete each statement with the correct word or number.</p> <ol> <li> <p>The Push Back field measures _ feet by _ feet.</p> </li> <li> <p>A complete match lasts _ minutes total.</p> </li> <li> <p>The autonomous period lasts _ seconds.</p> </li> <li> <p>Each block scored is worth _ points.</p> </li> <li> <p>If both robots park, you earn _ points (instead of 8 for one robot).</p> </li> <li> <p>The autonomous bonus is worth _ points.</p> </li> <li> <p>To control a zone, you need a _ of blocks (more than opponent).</p> </li> <li> <p>In an alliance, _ teams work together with _ robots total.</p> </li> <li> <p>The Long Goal zone is worth _ points if you control it.</p> </li> <li> <p>You should head to park zone with about _ seconds remaining.</p> </li> </ol>"},{"location":"06-competition-strategy/04-review-qa/#section-4-calculation-problems-10-questions","title":"Section 4: Calculation Problems (10 Questions)","text":"<p>Show your work!</p> <p>46. Block Scoring: Your alliance scored 12 blocks in various goals. How many points is this worth? <pre><code>Calculation: ___ blocks \u00d7 ___ pts = ___ points\n</code></pre></p> <p>47. Zone Control Calculation: Your alliance controls: - 1 Long Goal (10 pts) - Center Goal Upper (8 pts)</p> <p>How many zone points does your alliance have? <pre><code>Calculation: ___ + ___ = ___ zone points\n</code></pre></p> <p>48. Parking Decision: Your alliance has 1 robot parked (8 pts). Getting the second robot to park would add how many ADDITIONAL points? <pre><code>Current: 8 points (1 robot)\nIf 2 robots park: 30 points\nAdditional points gained: ___ - ___ = ___ points\n</code></pre></p> <p>49. Descoring Math: A zone has 5 blocks: 3 Blue, 2 Red. - Blue currently controls the zone (+10 pts Blue)</p> <p>You descore 2 Blue blocks. Now it's: 1 Blue, 2 Red. - Red now controls (+10 pts Red)</p> <p>What is the TOTAL point swing for your Red alliance? <pre><code>Blue loses: ___ zone points\nRed gains: ___ zone points\nTotal swing: ___ points\n</code></pre></p> <p>50. Match Score Calculation: Calculate your alliance's total score: - Blocks scored: 18 - Long Goal zones controlled: 2 - Center Upper zone: Yes (controlled) - Center Lower zone: No - Robots parked: 2 - Autonomous bonus: Yes</p> <pre><code>Blocks: ___ \u00d7 3 = ___\nLong goals: ___ \u00d7 10 = ___\nCenter upper: ___ \u00d7 8 = ___\nCenter lower: ___\nParking: ___\nAutonomous: ___\nTOTAL: ___ points\n</code></pre> <p>51. Points Per Second: You have 5 seconds left. You can either: - A) Score 1 block (3 pts) - B) Help partner park (30 pts total - you already have 1 parked for 8 pts)</p> <p>Which option gives more points? <pre><code>Option A: ___ points\nOption B additional: ___ - ___ = ___ points\nBetter option: ___\n</code></pre></p> <p>52. Zone Control Majority: A Long Goal has 10 blocks: 6 Red, 4 Blue. How many blocks does Blue need to ADD to tie? To win control? <pre><code>Current: Red 6, Blue 4\nTo tie: Blue needs ___ blocks (equal to Red)\nTo win: Blue needs ___ blocks (more than Red)\n</code></pre></p> <p>53. Autonomous Win Point: Your alliance must meet ALL these requirements: - \u2611 Score 7+ blocks (you scored 8) - \u2611 Score in 3+ goals (you scored in 2) - \u2611 Clear 3+ loader blocks (you cleared 4) - \u2610 Not touching park barrier (you're clear)</p> <p>Did you earn the Autonomous Win Point? <pre><code>Answer: ___ (Yes/No)\nReason: _______________\n</code></pre></p> <p>54. Strategy Comparison: In 20 seconds, your robot can either: - Score 5 blocks (at 3 pts each) - Get to park zone (ensuring both robots park: 30 pts vs 8 pts)</p> <p>Calculate which is better: <pre><code>Option A (scoring): ___ \u00d7 ___ = ___ points\nOption B (double park bonus): ___ - ___ = ___ additional points\nBetter choice: ___\n</code></pre></p> <p>55. Maximum Score Theory: What's the theoretical maximum score for an alliance? - All 44 blocks in goals: ___ \u00d7 3 = ___ - Control all zones (2 Long + Upper + Lower): ___ + ___ + ___ + ___ = ___ - Both robots parked: ___ - Autonomous bonus: ___ <pre><code>MAXIMUM POSSIBLE: ___ points\n</code></pre></p>"},{"location":"06-competition-strategy/04-review-qa/#section-5-scenario-based-questions-8-questions","title":"Section 5: Scenario-Based Questions (8 Questions)","text":"<p>Read each scenario and answer the question.</p> <p>56. Autonomous Collision: Your partner's autonomous routine goes to the center of the field. Your routine also goes to the center. What should you do?</p> <p>A) Keep both routines the same B) Change one routine to go left or right instead C) Skip autonomous entirely D) Both robots should stop immediately</p> <p>57. Zone Defense: Your alliance controls a Long Goal with 4 Red blocks and 1 Blue block. The opponent is approaching to descore. What should the defending robot do?</p> <p>A) Ignore them and score more blocks elsewhere B) Defend the goal and block the opponent C) Leave and go park D) Descore their blocks first</p> <p>58. End-Game Decision: There are 15 seconds left. One robot is parked (8 pts). The other robot is far from the park zone with 3 blocks it could score (9 pts). What should it do?</p> <p>A) Score all 3 blocks for 9 points B) Head to park zone (total would be 30 pts instead of 8) C) Descore opponent blocks D) Stop moving</p> <p>59. Partner Evaluation: You're matched with a partner team. Their robot is slow but has a strong pusher. Your robot is fast but weak at pushing. How should you divide roles?</p> <p>A) Both robots try to score quickly B) Your fast robot scores, partner's strong robot defends C) Your robot defends, partner scores D) Both robots park immediately</p> <p>60. Descoring Opportunity: A Long Goal has 4 Blue blocks, 0 Red blocks. Blue controls it (+10 pts). You have time to either score 3 Red blocks there OR descore 3 Blue blocks.</p> <p>Which gives your alliance the BIGGER advantage and why?</p> <p>61. Scouting Information: You scouted an opponent team and noticed they ALWAYS forget to park at the end. How can you use this information?</p> <p>A) Ignore it - it doesn't affect your strategy B) Make sure your alliance parks to gain a 30-point advantage C) Tell them they should park D) Forget to park too</p> <p>62. Communication Breakdown: During a match, the venue is very loud and your partner can't hear you. You need to signal that it's time to park. What should you do?</p> <p>A) Shout louder B) Use a pre-planned hand signal (like open palm) C) Keep scoring and hope they figure it out D) Stop your robot and wait</p> <p>63. Tie-Breaker Zone: A center lower zone has 4 blocks: 2 Red, 2 Blue (tie - no one controls). You have time to add 1 block. Is it worth it?</p> <p>A) No, one block doesn't matter B) Yes, adding 1 Red block gives Red control (+6 pts) C) No, it only adds 3 points D) Yes, but only if it's a Blue block</p>"},{"location":"06-competition-strategy/04-review-qa/#section-6-match-the-terms-16-pairs","title":"Section 6: Match the Terms (16 Pairs)","text":"<p>Match each term (1-16) with its correct definition (A-P).</p> # Term Definition 1 Autonomous A. Removing opponent blocks from goals 2 Driver Control B. Working with another team for a match 3 Descoring C. The 15-second pre-programmed period 4 Zone Control D. Fast scoring of many blocks 5 Alliance E. The 1:45 human-controlled period 6 Volume Scoring F. Having majority of blocks in a zone 7 Parking G. Both robots in park zone for 30 pts 8 Double Park H. Watching other teams to learn strengths/weaknesses 9 Long Goal I. Placing robot in alliance park zone 10 Center Goal J. Worth 10 pts for zone control 11 Scouting K. Has upper (8 pts) and lower (6 pts) sections 12 End Game L. The last 10-15 seconds of a match 13 Role Specialization M. Signals like open palm for \"parking\" 14 Hand Signals N. One robot scores, one defends 15 Zone Division O. Splitting field into left/right for each robot 16 Autonomous Bonus P. 10 points for winning autonomous period <p>Your Answers: <pre><code>1: ___  2: ___  3: ___  4: ___\n5: ___  6: ___  7: ___  8: ___\n9: ___  10: ___ 11: ___ 12: ___\n13: ___ 14: ___ 15: ___ 16: ___\n</code></pre></p>"},{"location":"06-competition-strategy/04-review-qa/#section-7-field-diagram-challenges-3-diagrams","title":"Section 7: Field Diagram Challenges (3 Diagrams)","text":""},{"location":"06-competition-strategy/04-review-qa/#diagram-1-field-layout","title":"Diagram 1: Field Layout","text":"<p>Label the following on the field diagram: - A. Park Zone (Red) - B. Park Zone (Blue) - C. Long Goal (Left) - D. Long Goal (Right) - E. Center Goal - F. Loader (Red) - G. Loader (Blue)</p> <pre><code>    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    \u2551                                                              \u2551\n    \u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2551\n    \u2551  \u2502              \u2502    \u2502              \u2502    \u2502              \u2502   \u2551\n    \u2551  \u2502   [___]      \u2502    \u2502    [___]     \u2502    \u2502    [___]     \u2502   \u2551\n    \u2551  \u2502              \u2502    \u2502              \u2502    \u2502              \u2502   \u2551\n    \u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2551\n    \u2551                                                              \u2551\n    \u2551         \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593                \u2551\n    \u2551                     (88 blocks)                              \u2551\n    \u2551                                                              \u2551\n    \u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2551\n    \u2551  \u2502 [___]  \u2502                                  \u2502 [___]  \u2502     \u2551\n    \u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2551\n    \u2551                                                              \u2551\n    \u2551  \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557                          \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557     \u2551\n    \u2551  \u2551   [___]    \u2551                          \u2551   [___]    \u2551     \u2551\n    \u2551  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d                          \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d     \u2551\n    \u2551                                                              \u2551\n    \u2551  [RED ALLIANCE]                          [BLUE ALLIANCE]    \u2551\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n</code></pre>"},{"location":"06-competition-strategy/04-review-qa/#diagram-2-zone-control","title":"Diagram 2: Zone Control","text":"<p>Look at this goal and answer:</p> <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 \ud83d\udd34 \ud83d\udd34 \ud83d\udd34 \ud83d\udd35 \ud83d\udd35 \ud83d\udd35 \ud83d\udd35  \u2502  LONG GOAL\n    \u2502                      \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ul> <li>How many Red blocks? ___</li> <li>How many Blue blocks? ___</li> <li>Who controls this zone? ___</li> <li>What is this worth to the controlling alliance? ___ points</li> </ul>"},{"location":"06-competition-strategy/04-review-qa/#diagram-3-match-timeline","title":"Diagram 3: Match Timeline","text":"<p>Fill in the missing information:</p> <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                      MATCH TIMELINE                        \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502   AUTONOMOUS     \u2502          DRIVER CONTROL                 \u2502\n    \u2502   ___ seconds    \u2502         ___ min ___ seconds             \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502 ____________     \u2502  Drivers control robots                 \u2502\n    \u2502 No human control \u2502  Full control of robot                  \u2502\n    \u2502 ___ pt bonus     \u2502  Main scoring period                    \u2502\n    \u2502 available        \u2502                                         \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Total Match Time: ___ minutes\n</code></pre>"},{"location":"06-competition-strategy/04-review-qa/#answer-key","title":"Answer Key","text":""},{"location":"06-competition-strategy/04-review-qa/#section-1-true-or-false","title":"Section 1: True or False","text":"# Answer Explanation 1 F Field is 12' \u00d7 12', not 10' \u00d7 10' 2 T Correct: 15 sec autonomous + 1:45 driver = 2:00 total 3 F Each block is worth 3 points, not 5 4 T 88 blocks total, 44 per alliance (red and blue) 5 F Descoring IS allowed in Push Back! 6 T Majority (more than opponent) = zone control 7 T Double park = 30 points (vs 8 for single) 8 T Autonomous bonus = 10 points 9 F Need 7+ blocks (plus other requirements) for AWP 10 T Upper = 8 pts, Lower = 6 pts 11 T Long goals hold up to 14 blocks each 12 F Ties mean NO ONE gets zone points 13 T 10-second rule: head to park! 14 F NO human communication during autonomous 15 T Scouting helps plan strategy <p>Score: ___ / 15</p>"},{"location":"06-competition-strategy/04-review-qa/#section-2-multiple-choice","title":"Section 2: Multiple Choice","text":"# Answer Explanation 16 C 2 minutes (15 sec + 1:45) 17 C 3 points per block 18 C Long Goal zone = 10 points 19 B Single robot park = 8 points 20 A 7+ blocks, 3+ goals, 3+ loader, no barrier 21 B Volume Scoring = push many blocks at once 22 B Descoring = removing opponent blocks from goals 23 C Stop scoring and park with 10 seconds left 24 B Center Upper = 8 points 25 B Defender focuses on goal defense and descoring 26 B Hand signals work in noisy environments 27 B Slower robot parks first to have more time 28 B 3 goals: 2 long + 1 center (with upper/lower) 29 B Zone division prevents robot collisions 30 B Center Lower = 6 points 31 C Favorite color is irrelevant to scouting 32 C Phase 3 (1:50-2:00) = both robots park 33 B Blocks scatter easily and can be descored 34 C Center Goal = 7 upper + 7 lower = 14 blocks 35 B Your alliance (3 &gt; 2 = majority = control) <p>Score: ___ / 20</p>"},{"location":"06-competition-strategy/04-review-qa/#section-3-fill-in-the-blank","title":"Section 3: Fill in the Blank","text":"# Answer 36 12 feet by 12 feet 37 2 minutes 38 15 seconds 39 3 points 40 30 points 41 10 points 42 majority 43 2 teams, 2 robots 44 10 points 45 10 seconds <p>Score: ___ / 10</p>"},{"location":"06-competition-strategy/04-review-qa/#section-4-calculation-problems","title":"Section 4: Calculation Problems","text":"<p>46. 12 blocks \u00d7 3 pts = 36 points</p> <p>47. 10 + 8 = 18 zone points</p> <p>48. 30 - 8 = 22 additional points</p> <p>49. Blue loses 10 + Red gains 10 = 20 point swing</p> <p>50. - Blocks: 18 \u00d7 3 = 54 - Long goals: 2 \u00d7 10 = 20 - Center upper: 1 \u00d7 8 = 8 - Center lower: 0 - Parking: 30 - Autonomous: 10 - TOTAL: 122 points</p> <p>51. - Option A: 3 points - Option B: 30 - 8 = 22 additional points - Better: Option B (park)</p> <p>52. - To tie: Blue needs 2 blocks (6-6) - To win: Blue needs 3 blocks (7-6)</p> <p>53. No - Only scored in 2 goals (need 3+)</p> <p>54. - Option A: 5 \u00d7 3 = 15 points - Option B: 30 - 8 = 22 additional points - Better: Option B (park)</p> <p>55. - 44 \u00d7 3 = 132 (blocks) - 10 + 10 + 8 + 6 = 34 (zones) - Parking: 30 - Autonomous: 10 - MAXIMUM: 206 points</p> <p>Score: ___ / 10</p>"},{"location":"06-competition-strategy/04-review-qa/#section-5-scenario-based","title":"Section 5: Scenario-Based","text":"# Answer Explanation 56 B Change one routine to avoid collision 57 B Defend the goal to protect your zone control 58 B Park! Double park (30) &gt; single (8) + 9 = 17 59 B Use each robot's strengths: fast scores, strong defends 60 Scoring is better - Adding 3 Red blocks creates control (3-4 = no control, but 3-4 means Blue still has majority). Actually, descoring is better: removing 3 Blue leaves 1-0, AND denies them 10 pts. Point swing = 20 pts vs scoring 9 pts. Descoring = bigger advantage 61 B Your alliance gains 30 pts by double parking while they get 0 62 B Pre-planned hand signals work in noisy venues 63 B Adding 1 block breaks the tie, giving 6 pts zone control <p>Score: ___ / 8</p>"},{"location":"06-competition-strategy/04-review-qa/#section-6-match-the-terms","title":"Section 6: Match the Terms","text":"<pre><code>1: C   (Autonomous = 15-sec pre-programmed)\n2: E   (Driver Control = 1:45 human-controlled)\n3: A   (Descoring = removing opponent blocks)\n4: F   (Zone Control = majority of blocks)\n5: B   (Alliance = working with another team)\n6: D   (Volume Scoring = fast, many blocks)\n7: I   (Parking = placing robot in park zone)\n8: G   (Double Park = both robots, 30 pts)\n9: J   (Long Goal = worth 10 pts zone control)\n10: K  (Center Goal = upper 8, lower 6)\n11: H  (Scouting = watching other teams)\n12: L  (End Game = last 10-15 seconds)\n13: N  (Role Specialization = scorer/defender)\n14: M  (Hand Signals = visual communication)\n15: O  (Zone Division = left/right split)\n16: P  (Autonomous Bonus = 10 pts for winning)\n</code></pre> <p>Score: ___ / 16</p>"},{"location":"06-competition-strategy/04-review-qa/#section-7-diagrams","title":"Section 7: Diagrams","text":""},{"location":"06-competition-strategy/04-review-qa/#diagram-1-field-layout_1","title":"Diagram 1: Field Layout","text":"<ul> <li>C = Long Goal (Left) - top left</li> <li>E = Center Goal - top center</li> <li>D = Long Goal (Right) - top right</li> <li>F = Loader (Red) - left side</li> <li>G = Loader (Blue) - right side</li> <li>A = Park Zone (Red) - bottom left</li> <li>B = Park Zone (Blue) - bottom right</li> </ul>"},{"location":"06-competition-strategy/04-review-qa/#diagram-2-zone-control_1","title":"Diagram 2: Zone Control","text":"<ul> <li>Red blocks: 3</li> <li>Blue blocks: 4</li> <li>Control: Blue (4 &gt; 3)</li> <li>Worth: 10 points (Long Goal zone)</li> </ul>"},{"location":"06-competition-strategy/04-review-qa/#diagram-3-match-timeline_1","title":"Diagram 3: Match Timeline","text":"<ul> <li>Autonomous: 15 seconds</li> <li>Driver Control: 1 min 45 seconds</li> <li>Pre-programmed (no human control)</li> <li>10 pt bonus available</li> <li>Total: 2 minutes</li> </ul> <p>Score: ___ / 3 diagrams</p>"},{"location":"06-competition-strategy/04-review-qa/#score-yourself","title":"Score Yourself","text":"Section Your Score Max True/False ___ 15 Multiple Choice ___ 20 Fill in Blank ___ 10 Calculations ___ 10 Scenarios ___ 8 Match Terms ___ 16 Diagrams ___ 3 TOTAL ___ 82"},{"location":"06-competition-strategy/04-review-qa/#score-guide","title":"Score Guide","text":"Percentage Rating Next Steps 90-100% Excellent! Ready for competition! 80-89% Good Review missed concepts, then proceed 70-79% Needs Work Re-read tutorials, focus on weak areas Below 70% Study More Go through all three tutorials again"},{"location":"06-competition-strategy/04-review-qa/#key-concepts-summary","title":"Key Concepts Summary","text":""},{"location":"06-competition-strategy/04-review-qa/#essential-numbers-to-remember","title":"Essential Numbers to Remember","text":"<ul> <li>Field: 12' \u00d7 12'</li> <li>Blocks: 88 total (44 each)</li> <li>Match: 2 minutes (15 sec auto + 1:45 driver)</li> <li>Block scored: 3 points</li> <li>Long Goal zone: 10 points</li> <li>Center Upper zone: 8 points</li> <li>Center Lower zone: 6 points</li> <li>Single park: 8 points</li> <li>Double park: 30 points</li> <li>Autonomous bonus: 10 points</li> </ul>"},{"location":"06-competition-strategy/04-review-qa/#critical-strategy-points","title":"Critical Strategy Points","text":"<ol> <li>Descoring is allowed - removing opponent blocks is legal</li> <li>Zone control requires MAJORITY - ties give no points</li> <li>Double park is huge - 30 pts is almost always worth it</li> <li>10-second rule - stop scoring and park at 1:50</li> <li>AWP needs ALL 4 requirements - 7+ blocks, 3+ goals, 3+ loader, no barrier</li> </ol>"},{"location":"06-competition-strategy/04-review-qa/#alliance-coordination-essentials","title":"Alliance Coordination Essentials","text":"<ol> <li>Pre-match: Discuss autonomous, roles, zones, end-game</li> <li>During match: Use hand signals in noisy venues</li> <li>Zone division: Each robot owns left or right</li> <li>End game: Both robots MUST park for 30 pts</li> </ol> <p>\u2190 Previous: Alliance Coordination | Next: Advanced Topics \u2192</p>"},{"location":"07-advanced/01-pid-control/","title":"Tutorial 7.1: PID Control (Advanced)","text":"<p>Time: ~25 minutes Prerequisites: All previous tutorials Level: Bonus/Advanced</p>"},{"location":"07-advanced/01-pid-control/#what-is-pid","title":"What is PID?","text":"<p>PID stands for Proportional-Integral-Derivative. It's a control algorithm that helps robots move more accurately by adjusting power based on how far you are from your target.</p>"},{"location":"07-advanced/01-pid-control/#real-world-analogies","title":"Real-World Analogies","text":""},{"location":"07-advanced/01-pid-control/#the-thermostat-analogy","title":"The Thermostat Analogy","text":"<p>Your home thermostat is a simple controller:</p> <pre><code>    SET TEMPERATURE: 70\u00b0F\n\n    Room is 60\u00b0F     \u2192 Heater ON (big correction)\n    Room is 68\u00b0F     \u2192 Heater ON (small correction)\n    Room is 70\u00b0F     \u2192 Heater OFF (at target!)\n    Room is 72\u00b0F     \u2192 AC ON (overshoot correction)\n</code></pre> <p>PID does the same thing, but smarter!</p>"},{"location":"07-advanced/01-pid-control/#the-video-game-analogy","title":"The Video Game Analogy","text":"<p>In racing games, when you approach a checkpoint: - Far away: Full speed ahead! - Getting closer: Start slowing down - Almost there: Gentle tap on brakes - At checkpoint: Perfect stop</p> <p>That's exactly what PID does for your robot!</p>"},{"location":"07-advanced/01-pid-control/#the-basketball-shot-analogy","title":"The Basketball Shot Analogy","text":"<p>When shooting free throws: - Miss by 2 feet short: Add LOTS more power next shot - Miss by 6 inches short: Add a little more power - Perfect shot: Same power! - Overshoot by 6 inches: Reduce power slightly</p> <p>PID adjusts motor power the same way you adjust your shot!</p>"},{"location":"07-advanced/01-pid-control/#the-driving-analogy","title":"The Driving Analogy","text":"<p>When approaching a stop sign: - 100 feet away: Full speed - 50 feet away: Start braking - 10 feet away: Light brake - At line: Stopped perfectly</p> <p>If you only knew \"GO\" and \"STOP\" (bang-bang), you'd either stop too early or slam into the intersection!</p>"},{"location":"07-advanced/01-pid-control/#pid-overview-flowchart","title":"PID Overview Flowchart","text":"<pre><code>flowchart LR\n    subgraph \"PID Controller\"\n        A[\"Target\\n(90\u00b0)\"] --&gt; B[\"Calculate\\nError\"]\n        C[\"Current\\n(85\u00b0)\"] --&gt; B\n        B --&gt; D[\"Error\\n= 5\u00b0\"]\n        D --&gt; E[\"P Term\\nKp \u00d7 Error\"]\n        D --&gt; F[\"I Term\\nKi \u00d7 Sum\"]\n        D --&gt; G[\"D Term\\nKd \u00d7 Change\"]\n        E --&gt; H[\"Add\\nTerms\"]\n        F --&gt; H\n        G --&gt; H\n        H --&gt; I[\"Motor\\nPower\"]\n    end\n\n    style A fill:#c8e6c9,stroke:#2e7d32\n    style C fill:#bbdefb,stroke:#1565c0\n    style D fill:#fff3e0,stroke:#ef6c00\n    style I fill:#f8bbd9,stroke:#c2185b</code></pre>"},{"location":"07-advanced/01-pid-control/#why-do-we-need-pid","title":"Why Do We Need PID?","text":""},{"location":"07-advanced/01-pid-control/#bang-bang-vs-pid-control-comparison","title":"Bang-Bang vs PID Control Comparison","text":"<pre><code>flowchart TB\n    subgraph \"Bang-Bang Control (Bad)\"\n        A1[\"Heading: 0\u00b0\"] --&gt; A2[\"Motors ON\\n100%\"]\n        A2 --&gt; A3[\"Heading: 85\u00b0\"]\n        A3 --&gt; A4[\"Motors ON\\n100%\"]\n        A4 --&gt; A5[\"Heading: 90\u00b0\"]\n        A5 --&gt; A6[\"Motors OFF\"]\n        A6 --&gt; A7[\"OVERSHOOT!\\n95\u00b0\"]\n        A7 --&gt; A8[\"Turn back...\"]\n        A8 --&gt; A9[\"UNDERSHOOT!\\n88\u00b0\"]\n        A9 --&gt; A10[\"Oscillates\\nforever\"]\n    end\n\n    style A7 fill:#ffcdd2,stroke:#c62828\n    style A9 fill:#ffcdd2,stroke:#c62828\n    style A10 fill:#ffcdd2,stroke:#c62828</code></pre> <pre><code>flowchart TB\n    subgraph \"PID Control (Good)\"\n        B1[\"Heading: 0\u00b0\"] --&gt; B2[\"Motors at\\n80%\"]\n        B2 --&gt; B3[\"Heading: 50\u00b0\"]\n        B3 --&gt; B4[\"Motors at\\n40%\"]\n        B4 --&gt; B5[\"Heading: 85\u00b0\"]\n        B5 --&gt; B6[\"Motors at\\n5%\"]\n        B6 --&gt; B7[\"Heading: 90\u00b0\"]\n        B7 --&gt; B8[\"Motors at\\n0%\"]\n        B8 --&gt; B9[\"Smooth stop!\"]\n    end\n\n    style B9 fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/01-pid-control/#the-key-difference","title":"The Key Difference","text":"Control Type Behavior Result Bang-Bang Full power until target Overshoot, oscillate PID Power proportional to distance Smooth, accurate stop"},{"location":"07-advanced/01-pid-control/#the-p-in-pid-proportional","title":"The P in PID: Proportional","text":"<p>Proportional means the correction is proportional to the error. The farther you are from the target, the bigger the correction!</p>"},{"location":"07-advanced/01-pid-control/#error-calculation-flowchart","title":"Error Calculation Flowchart","text":"<pre><code>flowchart LR\n    A[\"Target\\n90\u00b0\"] --&gt; C{\"-\"}\n    B[\"Current\\n30\u00b0\"] --&gt; C\n    C --&gt; D[\"Error\\n= 60\u00b0\"]\n    D --&gt; E[\"\u00d7 Kp\\n(0.5)\"]\n    E --&gt; F[\"Correction\\n= 30%\"]\n\n    style A fill:#c8e6c9,stroke:#2e7d32\n    style B fill:#bbdefb,stroke:#1565c0\n    style D fill:#fff3e0,stroke:#ef6c00\n    style F fill:#f8bbd9,stroke:#c2185b</code></pre>"},{"location":"07-advanced/01-pid-control/#the-p-formula","title":"The P Formula","text":"<pre><code>Error = Target - Current\n\nCorrection = Kp \u00d7 Error\n\nWhere Kp is a tuning constant (like 0.5)\n</code></pre> <p>Think of Kp as a \"sensitivity dial\": - Kp = 0.1 \u2192 Very gentle, slow response - Kp = 0.5 \u2192 Balanced response - Kp = 2.0 \u2192 Very aggressive, may overshoot</p>"},{"location":"07-advanced/01-pid-control/#example-p-controller-for-turning","title":"Example: P Controller for Turning","text":"<pre><code>def turn_to_heading(target_heading):\n    \"\"\"Turn to a specific heading using P control.\"\"\"\n    Kp = 0.5  # Tuning constant\n\n    while True:\n        current = inertial_sensor.heading()\n        error = target_heading - current\n\n        # Handle wraparound (0-360)\n        if error &gt; 180:\n            error -= 360\n        if error &lt; -180:\n            error += 360\n\n        # If close enough, stop\n        if abs(error) &lt; 2:\n            left_motors.stop()\n            right_motors.stop()\n            break\n\n        # Calculate correction\n        correction = Kp * error\n\n        # Apply to motors (turn in place)\n        left_motors.spin(FORWARD, correction, PERCENT)\n        right_motors.spin(FORWARD, -correction, PERCENT)\n\n        wait(20, MSEC)\n</code></pre>"},{"location":"07-advanced/01-pid-control/#tuning-kp","title":"Tuning Kp","text":"<pre><code>flowchart TB\n    subgraph \"Kp Effects Comparison\"\n        direction TB\n\n        A[\"Kp = 0.1\\n(Too Low)\"]\n        A1[\"\u274c Slow response\"]\n        A2[\"\u274c May not reach target\"]\n        A3[\"\u274c Friction wins\"]\n\n        B[\"Kp = 0.5-1.0\\n(Just Right)\"]\n        B1[\"\u2705 Quick response\"]\n        B2[\"\u2705 Minimal overshoot\"]\n        B3[\"\u2705 Accurate stop\"]\n\n        C[\"Kp = 2.0\\n(Too High)\"]\n        C1[\"\u274c Fast but overshoots\"]\n        C2[\"\u274c Oscillates\"]\n        C3[\"\u274c Jerky movement\"]\n\n        A --&gt; A1 --&gt; A2 --&gt; A3\n        B --&gt; B1 --&gt; B2 --&gt; B3\n        C --&gt; C1 --&gt; C2 --&gt; C3\n    end\n\n    style A fill:#ffcdd2,stroke:#c62828\n    style A1 fill:#ffcdd2,stroke:#c62828\n    style A2 fill:#ffcdd2,stroke:#c62828\n    style A3 fill:#ffcdd2,stroke:#c62828\n    style B fill:#c8e6c9,stroke:#2e7d32\n    style B1 fill:#c8e6c9,stroke:#2e7d32\n    style B2 fill:#c8e6c9,stroke:#2e7d32\n    style B3 fill:#c8e6c9,stroke:#2e7d32\n    style C fill:#ffcdd2,stroke:#c62828\n    style C1 fill:#ffcdd2,stroke:#c62828\n    style C2 fill:#ffcdd2,stroke:#c62828\n    style C3 fill:#ffcdd2,stroke:#c62828</code></pre>"},{"location":"07-advanced/01-pid-control/#what-each-symptom-means","title":"What Each Symptom Means","text":"Symptom Cause Fix Robot never reaches target Kp too low Increase Kp Robot oscillates around target Kp too high Decrease Kp Robot stops perfectly Kp just right Keep it!"},{"location":"07-advanced/01-pid-control/#the-i-in-pid-integral","title":"The I in PID: Integral","text":"<p>Integral accumulates error over time. It fixes steady-state error - when the robot gets close but can't quite reach the target.</p>"},{"location":"07-advanced/01-pid-control/#the-friction-problem","title":"The Friction Problem","text":"<pre><code>flowchart LR\n    subgraph \"P-Only Problem\"\n        A[\"Target: 90\u00b0\\nCurrent: 88\u00b0\"] --&gt; B[\"Error = 2\u00b0\"]\n        B --&gt; C[\"Correction =\\n0.5 \u00d7 2 = 1%\"]\n        C --&gt; D[\"1% power\\ncan't overcome\\nfriction!\"]\n    end\n\n    style D fill:#ffcdd2,stroke:#c62828</code></pre>"},{"location":"07-advanced/01-pid-control/#the-i-term-solution","title":"The I Term Solution","text":"<pre><code>flowchart TB\n    subgraph \"Integral Accumulation\"\n        A[\"Error = 2\u00b0\\nCycle 1\"] --&gt; B[\"integral = 2\"]\n        B --&gt; C[\"Error = 2\u00b0\\nCycle 2\"]\n        C --&gt; D[\"integral = 4\"]\n        D --&gt; E[\"Error = 2\u00b0\\nCycle 3\"]\n        E --&gt; F[\"integral = 6\"]\n        F --&gt; G[\"...\"]\n        G --&gt; H[\"Error = 2\u00b0\\nCycle 10\"]\n        H --&gt; I[\"integral = 20\"]\n        I --&gt; J[\"Now Ki \u00d7 20\\nOVERCOMES\\nfriction!\"]\n    end\n\n    style J fill:#c8e6c9,stroke:#2e7d32</code></pre> <p>Think of it like pushing a heavy box: - One small push (P) isn't enough - But 10 small pushes adding up (I) finally moves it!</p>"},{"location":"07-advanced/01-pid-control/#pi-controller","title":"PI Controller","text":"<pre><code>def turn_to_heading_pi(target_heading):\n    \"\"\"Turn using PI control.\"\"\"\n    Kp = 0.5\n    Ki = 0.01  # Small integral gain\n\n    integral = 0\n\n    while True:\n        current = inertial_sensor.heading()\n        error = target_heading - current\n\n        # Handle wraparound\n        if error &gt; 180:\n            error -= 360\n        if error &lt; -180:\n            error += 360\n\n        # Accumulate error\n        integral += error\n\n        # Stop condition\n        if abs(error) &lt; 2:\n            left_motors.stop()\n            right_motors.stop()\n            break\n\n        # PI calculation\n        correction = (Kp * error) + (Ki * integral)\n\n        left_motors.spin(FORWARD, correction, PERCENT)\n        right_motors.spin(FORWARD, -correction, PERCENT)\n\n        wait(20, MSEC)\n</code></pre> <p>For beginners: Skip the I term at first! P-only often works well enough.</p>"},{"location":"07-advanced/01-pid-control/#the-d-in-pid-derivative","title":"The D in PID: Derivative","text":"<p>Derivative predicts future error based on rate of change.</p> <pre><code>    Error is decreasing rapidly?\n    \u2192 Don't overcorrect, you're about to reach target!\n\n    Error is increasing?\n    \u2192 Something's wrong, add more correction!\n</code></pre>"},{"location":"07-advanced/01-pid-control/#full-pid-optional","title":"Full PID (Optional)","text":"<pre><code>def turn_to_heading_pid(target_heading):\n    \"\"\"Full PID control (advanced).\"\"\"\n    Kp = 0.5\n    Ki = 0.01\n    Kd = 0.1\n\n    integral = 0\n    previous_error = 0\n\n    while True:\n        current = inertial_sensor.heading()\n        error = target_heading - current\n\n        # Handle wraparound\n        if error &gt; 180:\n            error -= 360\n        if error &lt; -180:\n            error += 360\n\n        # Calculate I and D terms\n        integral += error\n        derivative = error - previous_error\n        previous_error = error\n\n        # Stop condition\n        if abs(error) &lt; 2:\n            left_motors.stop()\n            right_motors.stop()\n            break\n\n        # Full PID\n        correction = (Kp * error) + (Ki * integral) + (Kd * derivative)\n\n        left_motors.spin(FORWARD, correction, PERCENT)\n        right_motors.spin(FORWARD, -correction, PERCENT)\n\n        wait(20, MSEC)\n</code></pre>"},{"location":"07-advanced/01-pid-control/#pid-tuning-guide","title":"PID Tuning Guide","text":""},{"location":"07-advanced/01-pid-control/#step-by-step-tuning-flowchart","title":"Step-by-Step Tuning Flowchart","text":"<pre><code>flowchart TD\n    START[\"START HERE\\nKp = 0.5, Ki = 0, Kd = 0\\n(P-only control)\"]\n    START --&gt; TEST1\n\n    TEST1{\"Does robot\\nOVERSHOOT?\"}\n    TEST1 --&gt;|\"YES\"| FIX1[\"Decrease Kp\\n(try 0.3)\"]\n    TEST1 --&gt;|\"NO\"| TEST2\n    FIX1 --&gt; TEST1\n\n    TEST2{\"Is robot\\nTOO SLOW?\"}\n    TEST2 --&gt;|\"YES\"| FIX2[\"Increase Kp\\n(try 0.7)\"]\n    TEST2 --&gt;|\"NO\"| TEST3\n    FIX2 --&gt; TEST1\n\n    TEST3{\"Does robot\\nNOT REACH target?\\n(steady-state error)\"}\n    TEST3 --&gt;|\"YES\"| FIX3[\"Add small Ki\\n(try 0.01)\"]\n    TEST3 --&gt;|\"NO\"| DONE1[\"P-only works!\\nYou're done!\"]\n    FIX3 --&gt; TEST4\n\n    TEST4{\"Does robot now\\nOVERSHOOT more?\"}\n    TEST4 --&gt;|\"YES\"| FIX4[\"Decrease Ki\\n(try 0.005)\"]\n    TEST4 --&gt;|\"NO\"| DONE2[\"PI works!\\nYou're done!\"]\n    FIX4 --&gt; TEST4\n\n    style START fill:#e3f2fd,stroke:#1565c0\n    style DONE1 fill:#c8e6c9,stroke:#2e7d32\n    style DONE2 fill:#c8e6c9,stroke:#2e7d32\n    style FIX1 fill:#fff3e0,stroke:#ef6c00\n    style FIX2 fill:#fff3e0,stroke:#ef6c00\n    style FIX3 fill:#fff3e0,stroke:#ef6c00\n    style FIX4 fill:#fff3e0,stroke:#ef6c00</code></pre>"},{"location":"07-advanced/01-pid-control/#quick-reference-starting-values","title":"Quick Reference Starting Values","text":"Robot Type Kp Start Ki Start Notes Turning in place 0.5-1.0 0.01 Most common Driving straight 0.3-0.5 0.005 Less aggressive Arm movement 0.2-0.4 0.01 Avoid jerky motion"},{"location":"07-advanced/01-pid-control/#summary","title":"Summary","text":"Term What It Does When to Use P Correction proportional to error Always (start here) I Fixes steady-state error If robot can't reach target D Dampens oscillation If robot overshoots"},{"location":"07-advanced/01-pid-control/#pid-in-push-back-competition","title":"PID in Push Back Competition","text":"<p>PID control is essential for competitive Push Back robots. Here's how each use case helps you score more points:</p>"},{"location":"07-advanced/01-pid-control/#accurate-autonomous-turns","title":"Accurate Autonomous Turns","text":"<pre><code>def push_back_autonomous():\n    \"\"\"\n    Use PID for precise turns to line up with goals.\n    Accurate turns = More blocks in the goal!\n    \"\"\"\n    # Turn exactly 45\u00b0 to face the long goal\n    turn_to_heading_p(45)  # P controller\n\n    # Drive forward and push blocks\n    drivetrain.drive_for(FORWARD, 600, MM)\n\n    # Turn exactly 90\u00b0 to face center goal\n    turn_to_heading_p(135)\n\n    # More accurate turns = More points!\n</code></pre>"},{"location":"07-advanced/01-pid-control/#straight-line-block-pushing","title":"Straight-Line Block Pushing","text":"<pre><code>def push_blocks_straight():\n    \"\"\"\n    Use PID to drive STRAIGHT while pushing blocks.\n    Without PID, blocks push you off course!\n    \"\"\"\n    start_heading = inertial_sensor.heading()\n    Kp = 0.5\n\n    while distance_to_goal &gt; 100:\n        # Calculate heading error\n        current = inertial_sensor.heading()\n        error = start_heading - current\n\n        # Handle wraparound\n        if error &gt; 180: error -= 360\n        if error &lt; -180: error += 360\n\n        correction = Kp * error\n\n        # Apply correction to stay straight\n        left_motors.spin(FORWARD, 50 + correction, PERCENT)\n        right_motors.spin(FORWARD, 50 - correction, PERCENT)\n\n        wait(20, MSEC)\n</code></pre>"},{"location":"07-advanced/01-pid-control/#precise-parking","title":"Precise Parking","text":"<pre><code>flowchart LR\n    A[\"Far from\\npark zone\"] --&gt; B[\"Fast\\napproach\"]\n    B --&gt; C[\"Getting\\nclose\"]\n    C --&gt; D[\"Slow\\ndown\"]\n    D --&gt; E[\"Almost\\nthere\"]\n    E --&gt; F[\"Gentle\\nstop\"]\n    F --&gt; G[\"PARKED!\\n8-30 pts \ud83c\udfaf\"]\n\n    style G fill:#c8e6c9,stroke:#2e7d32</code></pre> <pre><code>def pid_park():\n    \"\"\"\n    Use PID to park smoothly in the zone.\n    Smooth parking = No rolling out of zone!\n    \"\"\"\n    target_distance = 50  # Stop 50mm from back wall\n    Kp = 0.3  # Gentle for parking\n\n    while True:\n        dist = distance_sensor.object_distance(MM)\n        error = dist - target_distance\n\n        if abs(error) &lt; 10:  # Within 10mm\n            drivetrain.stop()\n            return True  # Parked!\n\n        speed = Kp * error\n        speed = max(-30, min(30, speed))  # Slow for parking\n\n        drivetrain.drive(FORWARD, speed, PERCENT)\n        wait(20, MSEC)\n</code></pre>"},{"location":"07-advanced/01-pid-control/#progressive-exercises","title":"Progressive Exercises","text":""},{"location":"07-advanced/01-pid-control/#beginner-p-only-turn","title":"Beginner: P-Only Turn","text":"<p>Goal: Make the robot turn to exactly 90\u00b0 using P control.</p> <pre><code>def turn_to_90():\n    Kp = 0.5\n    target = 90\n\n    inertial_sensor.calibrate()\n    wait(3, SECONDS)\n\n    while True:\n        error = target - inertial_sensor.heading()\n\n        if abs(error) &lt; 2:\n            break\n\n        correction = Kp * error\n\n        # YOUR CODE: Apply correction to motors\n        # Hint: left_motors.spin(FORWARD, correction, PERCENT)\n        # Hint: right_motors.spin(FORWARD, -correction, PERCENT)\n\n        wait(20, MSEC)\n\n    # YOUR CODE: Stop the motors\n</code></pre> <p>Success criteria: Robot turns smoothly and stops at 90\u00b0 \u00b12\u00b0</p>"},{"location":"07-advanced/01-pid-control/#intermediate-add-wraparound-handling","title":"Intermediate: Add Wraparound Handling","text":"<p>Goal: Handle the 0-360\u00b0 boundary problem.</p> <p>Problem: What if current = 350\u00b0 and target = 10\u00b0? - Simple math: error = 10 - 350 = -340\u00b0 (wrong!) - Correct: The shortest turn is +20\u00b0 (right!)</p> <pre><code>def turn_to_heading(target):\n    Kp = 0.5\n\n    while True:\n        current = inertial_sensor.heading()\n        error = target - current\n\n        # YOUR CODE: Add wraparound handling\n        # If error &gt; 180, subtract 360\n        # If error &lt; -180, add 360\n\n        if abs(error) &lt; 2:\n            left_motors.stop()\n            right_motors.stop()\n            break\n\n        correction = Kp * error\n        left_motors.spin(FORWARD, correction, PERCENT)\n        right_motors.spin(FORWARD, -correction, PERCENT)\n\n        wait(20, MSEC)\n</code></pre> <p>Test cases: - Turn from 10\u00b0 to 350\u00b0 (should turn left 20\u00b0, not right 340\u00b0) - Turn from 350\u00b0 to 10\u00b0 (should turn right 20\u00b0, not left 340\u00b0)</p>"},{"location":"07-advanced/01-pid-control/#challenge-pi-control-for-accurate-parking","title":"Challenge: PI Control for Accurate Parking","text":"<p>Goal: Use PI control to overcome friction and park accurately.</p> <p>Scenario: Your robot needs to park exactly 100mm from the back wall. P-only control stops 5mm short because of friction.</p> <pre><code>def pi_park(target_distance=100):\n    Kp = 0.3\n    Ki = 0.01\n    integral = 0\n    tolerance = 5  # mm\n\n    while True:\n        current = distance_sensor.object_distance(MM)\n        error = current - target_distance\n\n        # YOUR CODE: Accumulate integral\n        # integral += error\n\n        if abs(error) &lt; tolerance:\n            drivetrain.stop()\n            return True\n\n        # YOUR CODE: Calculate PI correction\n        # correction = (Kp * error) + (Ki * integral)\n\n        # Limit speed for parking\n        correction = max(-30, min(30, correction))\n\n        drivetrain.drive(FORWARD, correction, PERCENT)\n        wait(20, MSEC)\n</code></pre> <p>Bonus challenge: Add \"integral windup protection\" - reset integral when error changes sign!</p>"},{"location":"07-advanced/01-pid-control/#common-mistakes-with-pid","title":"Common Mistakes with PID","text":""},{"location":"07-advanced/01-pid-control/#mistake-1-wrong-kp-sign","title":"Mistake 1: Wrong Kp Sign","text":"<pre><code># WRONG: Negative Kp causes wrong direction!\ncorrection = -0.5 * error  # Robot turns away from target!\n\n# RIGHT: Positive Kp\ncorrection = 0.5 * error   # Robot turns toward target\n</code></pre>"},{"location":"07-advanced/01-pid-control/#mistake-2-missing-wraparound-handling","title":"Mistake 2: Missing Wraparound Handling","text":"<pre><code># WRONG: No wraparound - robot spins 340\u00b0 instead of 20\u00b0\nerror = target - current\n\n# RIGHT: Handle 0-360 boundary\nerror = target - current\nif error &gt; 180:\n    error -= 360\nelif error &lt; -180:\n    error += 360\n</code></pre>"},{"location":"07-advanced/01-pid-control/#mistake-3-no-stop-condition","title":"Mistake 3: No Stop Condition","text":"<pre><code># WRONG: Loop never ends!\nwhile True:\n    error = target - inertial_sensor.heading()\n    correction = Kp * error\n    left_motors.spin(FORWARD, correction, PERCENT)\n    # No break condition! Robot vibrates forever!\n\n# RIGHT: Stop when close enough\nwhile True:\n    error = target - inertial_sensor.heading()\n    if abs(error) &lt; 2:  # Tolerance of 2\u00b0\n        left_motors.stop()\n        right_motors.stop()\n        break\n    # ... rest of code\n</code></pre>"},{"location":"07-advanced/01-pid-control/#mistake-4-correction-too-powerful","title":"Mistake 4: Correction Too Powerful","text":"<pre><code># WRONG: No speed limiting - motors max out\ncorrection = Kp * error  # Could be 100%+ !\n\n# RIGHT: Clamp correction to safe range\ncorrection = Kp * error\ncorrection = max(-50, min(50, correction))  # Limit to \u00b150%\n</code></pre>"},{"location":"07-advanced/01-pid-control/#mistake-5-starting-with-full-pid","title":"Mistake 5: Starting with Full PID","text":"<pre><code># WRONG: Start with all three terms\nKp = 0.5\nKi = 0.1\nKd = 0.5  # Too complex to tune!\n\n# RIGHT: Start P-only, add terms as needed\nKp = 0.5\nKi = 0    # Add later if needed\nKd = 0    # Rarely needed for VEX\n</code></pre>"},{"location":"07-advanced/01-pid-control/#how-pid-connects-to-push-back","title":"How PID Connects to Push Back","text":"Push Back Task PID Use Why It Helps Autonomous turns P control for heading Accurate alignment with goals Straight driving P control for heading correction Blocks don't push you off course Goal approach P control for distance Stop at right distance to push Parking PI control for precision Guarantee those 8-30 points! Block pushing P control while driving Maintain heading under load"},{"location":"07-advanced/01-pid-control/#push-back-points-gained-with-pid","title":"Push Back Points Gained with PID","text":"<pre><code>flowchart LR\n    subgraph \"Without PID\"\n        A1[\"Miss 2 goals\\n-6 points\"] --&gt; B1[\"Overshoot park\\n-8 points\"]\n        B1 --&gt; C1[\"Push blocks\\ncrooked\"] --&gt; D1[\"Lose zone\\ncontrol\"]\n    end\n\n    subgraph \"With PID\"\n        A2[\"Hit all goals\\n+6 points\"] --&gt; B2[\"Perfect park\\n+8 points\"]\n        B2 --&gt; C2[\"Straight\\npushing\"] --&gt; D2[\"Win zone\\ncontrol!\"]\n    end\n\n    style A1 fill:#ffcdd2,stroke:#c62828\n    style B1 fill:#ffcdd2,stroke:#c62828\n    style A2 fill:#c8e6c9,stroke:#2e7d32\n    style B2 fill:#c8e6c9,stroke:#2e7d32\n    style D2 fill:#c8e6c9,stroke:#2e7d32</code></pre> <p>Bottom line: PID can easily add 15-20 points to your match score through: - More accurate autonomous routines - Reliable parking - Better zone control</p> <p>\u2190 Previous: Alliance Coordination | Next: Sensor Integration \u2192 | Review Q&amp;A</p>"},{"location":"07-advanced/02-sensor-integration/","title":"Tutorial 7.2: Sensor Integration (Advanced)","text":"<p>Time: ~20 minutes Prerequisites: Tutorial 7.1: PID Control Level: Bonus/Advanced</p>"},{"location":"07-advanced/02-sensor-integration/#why-use-sensors","title":"Why Use Sensors?","text":"<p>Sensors are your robot's eyes, ears, and sense of direction. Without them, your robot is guessing. With them, it knows.</p>"},{"location":"07-advanced/02-sensor-integration/#real-world-analogies","title":"Real-World Analogies","text":""},{"location":"07-advanced/02-sensor-integration/#eyes-and-ears-for-your-robot","title":"Eyes and Ears for Your Robot","text":"<p>Just like you use your senses to navigate: - Eyes \u2192 Distance sensor, Optical sensor (see obstacles and colors) - Ears \u2192 Not applicable, but sensors \"listen\" to the world - Balance \u2192 Inertial sensor (like your inner ear for orientation) - GPS in phone \u2192 GPS sensor (knows exact position)</p>"},{"location":"07-advanced/02-sensor-integration/#car-sensors-you-already-know","title":"Car Sensors You Already Know","text":"Car Feature Robot Equivalent What It Does Backup camera beeps Distance sensor Detects how far from objects Dashboard compass Inertial sensor Tracks which direction you're facing Phone GPS GPS sensor Knows exact position on field Color-sorting machine Optical sensor Identifies block colors"},{"location":"07-advanced/02-sensor-integration/#video-game-comparison","title":"Video Game Comparison","text":"<pre><code>WITHOUT SENSORS (like playing blindfolded):\n    \"I pressed forward for 2 seconds... I think I'm near the goal?\"\n\nWITH SENSORS (like playing with eyes open):\n    \"I can SEE the goal is 100mm away. I'll stop when I reach it!\"\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#open-loop-vs-closed-loop-control","title":"Open-Loop vs Closed-Loop Control","text":"<pre><code>flowchart LR\n    subgraph \"Open-Loop (Guessing)\"\n        A1[\"Command:\\ndrive 500mm\"] --&gt; B1[\"Robot moves\"]\n        B1 --&gt; C1[\"Hope it\\nworked?\"]\n    end\n\n    subgraph \"Closed-Loop (Sensors)\"\n        A2[\"Command:\\ndrive until\\n500mm\"] --&gt; B2[\"Robot moves\"]\n        B2 --&gt; C2[\"Sensor:\\n487mm...\"]\n        C2 --&gt; D2[\"Keep going\"]\n        D2 --&gt; E2[\"Sensor:\\n500mm\"]\n        E2 --&gt; F2[\"STOP!\"]\n        C2 -.-&gt; B2\n    end\n\n    style C1 fill:#ffcdd2,stroke:#c62828\n    style F2 fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/02-sensor-integration/#inertial-sensor-imu","title":"Inertial Sensor (IMU)","text":"<p>The most useful sensor for competition robots! It's like your robot's inner ear - it knows which way it's facing even if the wheels slip.</p>"},{"location":"07-advanced/02-sensor-integration/#how-the-inertial-sensor-works","title":"How the Inertial Sensor Works","text":"<pre><code>flowchart TB\n    subgraph \"Inertial Sensor (IMU)\"\n        A[\"3-Axis Gyroscope\"] --&gt; D[\"Tracks Rotation\"]\n        B[\"3-Axis Accelerometer\"] --&gt; E[\"Tracks Movement\"]\n        D --&gt; F[\"Heading: 0-360\u00b0\"]\n        E --&gt; G[\"Tilt Detection\"]\n    end\n\n    style F fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/02-sensor-integration/#calibration-process","title":"Calibration Process","text":"<pre><code>flowchart LR\n    A[\"Call\\ncalibrate()\"] --&gt; B[\"Robot must\\nbe STILL!\"]\n    B --&gt; C[\"Wait 3\\nseconds\"]\n    C --&gt; D[\"Sensor\\nready \u2705\"]\n\n    style B fill:#fff3e0,stroke:#ef6c00\n    style D fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/02-sensor-integration/#setup","title":"Setup","text":"<pre><code># In robot_config.py\ninertial_sensor = Inertial(Ports.PORT5)\n\n# Before using (in autonomous) - CRITICAL!\ninertial_sensor.calibrate()\nwait(3, SECONDS)  # Wait for calibration! Robot must be STILL!\n</code></pre> <p>Important: If the robot moves during calibration, all readings will be wrong!</p>"},{"location":"07-advanced/02-sensor-integration/#heading-vs-rotation","title":"Heading vs Rotation","text":"<pre><code>flowchart TB\n    subgraph \"heading() - Compass Style\"\n        H1[\"0\u00b0\"] --&gt; H2[\"90\u00b0\"] --&gt; H3[\"180\u00b0\"] --&gt; H4[\"270\u00b0\"] --&gt; H5[\"359\u00b0\"]\n        H5 --&gt; H6[\"0\u00b0 (resets!)\"]\n    end\n\n    subgraph \"rotation() - Total Turns\"\n        R1[\"0\u00b0\"] --&gt; R2[\"90\u00b0\"] --&gt; R3[\"180\u00b0\"] --&gt; R4[\"360\u00b0\"]\n        R4 --&gt; R5[\"720\u00b0 (2 full turns)\"]\n        R5 --&gt; R6[\"Keeps counting...\"]\n    end\n\n    style H6 fill:#fff3e0,stroke:#ef6c00\n    style R6 fill:#c8e6c9,stroke:#2e7d32</code></pre> <pre><code># Heading: 0-360 degrees (resets at 360) - like a compass\nheading = inertial_sensor.heading()\n\n# Rotation: Continuous (-\u221e to +\u221e) - counts total rotation\nrotation = inertial_sensor.rotation()\n</code></pre> <p>When to use which: - <code>heading()</code> \u2192 \"Face north\" (absolute direction) - <code>rotation()</code> \u2192 \"Turn exactly 720\u00b0\" (2 full spins)</p>"},{"location":"07-advanced/02-sensor-integration/#accurate-turning","title":"Accurate Turning","text":"<pre><code>def turn_to_heading(target):\n    \"\"\"Turn to exact heading using inertial sensor.\"\"\"\n    Kp = 0.8\n\n    while True:\n        current = inertial_sensor.heading()\n        error = target - current\n\n        # Handle 0-360 wraparound\n        if error &gt; 180:\n            error -= 360\n        elif error &lt; -180:\n            error += 360\n\n        if abs(error) &lt; 2:\n            drivetrain.stop()\n            return\n\n        speed = Kp * error\n        speed = max(-50, min(50, speed))  # Limit speed\n\n        left_motors.spin(FORWARD, speed, PERCENT)\n        right_motors.spin(FORWARD, -speed, PERCENT)\n\n        wait(20, MSEC)\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#straight-line-driving","title":"Straight-Line Driving","text":"<pre><code>def drive_straight(distance_mm):\n    \"\"\"Drive straight using inertial sensor for correction.\"\"\"\n    start_heading = inertial_sensor.heading()\n    Kp = 0.5\n\n    drivetrain.set_drive_velocity(50, PERCENT)\n    drivetrain.drive(FORWARD)\n\n    start_position = left_motor_front.position(DEGREES)\n    target_degrees = distance_mm / WHEEL_TRAVEL_MM * 360\n\n    while True:\n        # Check distance\n        current_position = left_motor_front.position(DEGREES)\n        if current_position - start_position &gt;= target_degrees:\n            drivetrain.stop()\n            return\n\n        # Heading correction\n        current_heading = inertial_sensor.heading()\n        error = start_heading - current_heading\n\n        if error &gt; 180:\n            error -= 360\n        elif error &lt; -180:\n            error += 360\n\n        correction = Kp * error\n\n        left_motors.set_velocity(50 + correction, PERCENT)\n        right_motors.set_velocity(50 - correction, PERCENT)\n\n        wait(20, MSEC)\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#distance-sensor","title":"Distance Sensor","text":"<p>Detects objects in front of the robot - like a bat using echolocation or a car's parking sensors!</p>"},{"location":"07-advanced/02-sensor-integration/#how-it-works","title":"How It Works","text":"<pre><code>flowchart LR\n    subgraph \"Distance Sensor\"\n        A[\"Sends laser\\nbeam\"] --&gt; B[\"Beam bounces\\noff object\"]\n        B --&gt; C[\"Sensor measures\\ntime\"]\n        C --&gt; D[\"Calculates\\ndistance\"]\n    end\n\n    E[\"Object\"] -.-&gt; B\n\n    style D fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/02-sensor-integration/#the-parking-sensor-analogy","title":"The Parking Sensor Analogy","text":"<p>Just like your car beeps faster as you get closer to an obstacle:</p> Distance Car Beeping Robot Action &gt; 500mm No beeps Drive fast 300-500mm Slow beeps Slow down 100-300mm Fast beeps Drive carefully &lt; 100mm Constant beep! STOP!"},{"location":"07-advanced/02-sensor-integration/#setup_1","title":"Setup","text":"<pre><code># In robot_config.py\ndistance_sensor = Distance(Ports.PORT6)\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#basic-usage","title":"Basic Usage","text":"<pre><code># Read distance in millimeters\ndist = distance_sensor.object_distance(MM)\n\n# Check if object is present\nif distance_sensor.is_object_detected():\n    print(\"Something is there!\")\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#distance-sensor-decision-flowchart","title":"Distance Sensor Decision Flowchart","text":"<pre><code>flowchart TD\n    A[\"Read distance\"] --&gt; B{\"dist &gt; 500mm?\"}\n    B --&gt;|\"YES\"| C[\"Drive fast\\n(80%)\"]\n    B --&gt;|\"NO\"| D{\"dist &gt; 200mm?\"}\n    D --&gt;|\"YES\"| E[\"Medium speed\\n(50%)\"]\n    D --&gt;|\"NO\"| F{\"dist &gt; 100mm?\"}\n    F --&gt;|\"YES\"| G[\"Slow speed\\n(30%)\"]\n    F --&gt;|\"NO\"| H[\"STOP!\"]\n\n    C --&gt; A\n    E --&gt; A\n    G --&gt; A\n\n    style H fill:#ffcdd2,stroke:#c62828</code></pre>"},{"location":"07-advanced/02-sensor-integration/#stop-before-wall","title":"Stop Before Wall","text":"<pre><code>def drive_until_wall(stop_distance=100):\n    \"\"\"Drive forward until wall is detected.\"\"\"\n    drivetrain.drive(FORWARD)\n\n    while True:\n        dist = distance_sensor.object_distance(MM)\n\n        if dist &lt; stop_distance:\n            drivetrain.stop()\n            return\n\n        wait(20, MSEC)\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#wall-following","title":"Wall Following","text":"<pre><code>def follow_wall(target_distance=200):\n    \"\"\"Follow wall at constant distance.\"\"\"\n    Kp = 0.2\n\n    while True:\n        dist = distance_sensor.object_distance(MM)\n        error = target_distance - dist\n\n        correction = Kp * error\n\n        # Adjust steering\n        left_speed = 50 + correction\n        right_speed = 50 - correction\n\n        left_motors.spin(FORWARD, left_speed, PERCENT)\n        right_motors.spin(FORWARD, right_speed, PERCENT)\n\n        wait(20, MSEC)\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#optical-sensor","title":"Optical Sensor","text":"<p>Detects colors - useful for block detection! Think of it like sorting M&amp;Ms by color - the sensor can tell red from blue!</p>"},{"location":"07-advanced/02-sensor-integration/#how-it-works_1","title":"How It Works","text":"<pre><code>flowchart LR\n    subgraph \"Optical Sensor\"\n        A[\"LED shines\\nlight\"] --&gt; B[\"Light reflects\\noff object\"]\n        B --&gt; C[\"Sensor reads\\ncolor wavelength\"]\n        C --&gt; D[\"Returns\\ncolor!\"]\n    end\n\n    style A fill:#fff3e0,stroke:#ef6c00\n    style D fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/02-sensor-integration/#the-mm-sorting-analogy","title":"The M&amp;M Sorting Analogy","text":"<p>Imagine sorting candy by color: 1. Shine a light on the candy 2. Look at what color bounces back 3. Put red in one pile, blue in another 4. Reject any other colors</p> <p>That's exactly what your robot does with blocks!</p>"},{"location":"07-advanced/02-sensor-integration/#setup_2","title":"Setup","text":"<pre><code># In robot_config.py\noptical_sensor = Optical(Ports.PORT7)\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#basic-usage_1","title":"Basic Usage","text":"<pre><code># Turn on LED for color detection - REQUIRED!\noptical_sensor.set_light_power(100)\noptical_sensor.set_light(LedStateType.ON)\n\n# Check for nearby object\nif optical_sensor.is_near_object():\n    color = optical_sensor.color()\n\n    if color == Color.RED:\n        print(\"Red block!\")\n    elif color == Color.BLUE:\n        print(\"Blue block!\")\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#block-color-sorting-flowchart","title":"Block Color Sorting Flowchart","text":"<pre><code>flowchart TD\n    A[\"Object near\\nsensor?\"] --&gt;|\"YES\"| B[\"Read color\"]\n    A --&gt;|\"NO\"| A\n\n    B --&gt; C{\"color ==\\nour alliance?\"}\n    C --&gt;|\"YES (RED)\"| D[\"Intake\\nFORWARD\"]\n    C --&gt;|\"NO (BLUE)\"| E[\"Intake\\nREVERSE\"]\n\n    D --&gt; F[\"Block\\ncollected!\"]\n    E --&gt; G[\"Block\\nejected!\"]\n\n    style D fill:#c8e6c9,stroke:#2e7d32\n    style E fill:#ffcdd2,stroke:#c62828</code></pre>"},{"location":"07-advanced/02-sensor-integration/#block-sorting","title":"Block Sorting","text":"<pre><code>def grab_our_blocks_only(our_color):\n    \"\"\"Only intake blocks of our alliance color.\"\"\"\n    while True:\n        if optical_sensor.is_near_object():\n            detected_color = optical_sensor.color()\n\n            if detected_color == our_color:\n                intake_motor.spin(FORWARD)\n                wait(500, MSEC)\n                intake_motor.stop()\n            else:\n                # Wrong color - eject!\n                intake_motor.spin(REVERSE)\n                wait(300, MSEC)\n                intake_motor.stop()\n\n        wait(50, MSEC)\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#gps-sensor","title":"GPS Sensor","text":"<p>Knows exact field position! It's like Google Maps for your robot - it knows exactly where on the field it is!</p>"},{"location":"07-advanced/02-sensor-integration/#how-gps-works-in-vex","title":"How GPS Works in VEX","text":"<pre><code>flowchart LR\n    subgraph \"GPS System\"\n        A[\"Field strips\\n(bar code)\"] --&gt; B[\"Camera on\\nrobot\"]\n        B --&gt; C[\"Reads position\\nfrom strips\"]\n        C --&gt; D[\"Reports X, Y\\ncoordinates\"]\n    end\n\n    style D fill:#c8e6c9,stroke:#2e7d32</code></pre> <p>The GPS sensor uses special field strips around the arena. It's like reading a QR code to know exactly where you are!</p>"},{"location":"07-advanced/02-sensor-integration/#the-phone-gps-analogy","title":"The Phone GPS Analogy","text":"Phone GPS VEX GPS \"You are on Main Street\" \"You are at X=500, Y=-300\" \"Turn left in 100 feet\" \"Turn 45\u00b0 and drive 200mm\" \"You have arrived\" \"X=0, Y=0 (center of field)\""},{"location":"07-advanced/02-sensor-integration/#field-coordinate-system","title":"Field Coordinate System","text":"<pre><code>flowchart TB\n    subgraph \"VEX Field (1800mm \u00d7 1800mm)\"\n        A[\"(-900, 900)\\nTop Left\"] --- B[\"(0, 900)\\nTop Center\"] --- C[\"(900, 900)\\nTop Right\"]\n        A --- D[\"(-900, 0)\\nLeft\"]\n        B --- E[\"(0, 0)\\nCENTER\"]\n        C --- F[\"(900, 0)\\nRight\"]\n        D --- G[\"(-900, -900)\\nBottom Left\"]\n        E --- H[\"(0, -900)\\nBottom Center\"]\n        F --- I[\"(900, -900)\\nBottom Right\"]\n    end\n\n    style E fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/02-sensor-integration/#setup_3","title":"Setup","text":"<pre><code># In robot_config.py\ngps_sensor = Gps(Ports.PORT8)\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#reading-position","title":"Reading Position","text":"<pre><code># X and Y position on field (in mm from center)\nx = gps_sensor.x_position(MM)\ny = gps_sensor.y_position(MM)\n\n# Heading from GPS (also available!)\nheading = gps_sensor.heading()\n\nprint(f\"Robot at: ({x}, {y}) facing {heading}\u00b0\")\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#return-to-position","title":"Return to Position","text":"<pre><code>def go_to_position(target_x, target_y):\n    \"\"\"Navigate to specific field coordinates.\"\"\"\n    while True:\n        current_x = gps_sensor.x_position(MM)\n        current_y = gps_sensor.y_position(MM)\n\n        # Calculate distance to target\n        dx = target_x - current_x\n        dy = target_y - current_y\n        distance = (dx**2 + dy**2) ** 0.5\n\n        if distance &lt; 50:  # Within 50mm\n            drivetrain.stop()\n            return\n\n        # Calculate angle to target\n        import math\n        target_angle = math.degrees(math.atan2(dy, dx))\n\n        # Turn toward target\n        turn_to_heading(target_angle)\n\n        # Drive toward target\n        drivetrain.drive_for(FORWARD, min(distance, 300), MM)\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#combining-sensors","title":"Combining Sensors","text":"<p>The real power of sensors comes from using them together! Each sensor has strengths - combine them for a smarter robot.</p>"},{"location":"07-advanced/02-sensor-integration/#sensor-fusion-flowchart","title":"Sensor Fusion Flowchart","text":"<pre><code>flowchart TD\n    subgraph \"Multi-Sensor Autonomous\"\n        A[\"Start\"] --&gt; B[\"Calibrate\\nInertial\"]\n        B --&gt; C[\"Drive forward\"]\n        C --&gt; D{\"Distance sensor:\\nobject &lt; 200mm?\"}\n        D --&gt;|\"NO\"| C\n        D --&gt;|\"YES\"| E[\"Optical:\\ncheck color\"]\n        E --&gt; F{\"Our alliance\\ncolor?\"}\n        F --&gt;|\"YES\"| G[\"Intake: grab block\"]\n        F --&gt;|\"NO\"| H[\"Back away\"]\n        G --&gt; I[\"GPS: return\\nto start\"]\n        H --&gt; I\n        I --&gt; J[\"Done!\"]\n    end\n\n    style G fill:#c8e6c9,stroke:#2e7d32\n    style H fill:#fff3e0,stroke:#ef6c00</code></pre>"},{"location":"07-advanced/02-sensor-integration/#which-sensor-for-what","title":"Which Sensor for What?","text":"<pre><code>flowchart TD\n    Q[\"What do you need?\"] --&gt; A{\"Need to know\\nHEADING?\"}\n    A --&gt;|\"YES\"| A1[\"Inertial Sensor\"]\n    A --&gt;|\"NO\"| B{\"Need to know\\nDISTANCE to object?\"}\n    B --&gt;|\"YES\"| B1[\"Distance Sensor\"]\n    B --&gt;|\"NO\"| C{\"Need to know\\nCOLOR?\"}\n    C --&gt;|\"YES\"| C1[\"Optical Sensor\"]\n    C --&gt;|\"NO\"| D{\"Need to know\\nPOSITION on field?\"}\n    D --&gt;|\"YES\"| D1[\"GPS Sensor\"]\n    D --&gt;|\"NO\"| E[\"Maybe you don't\\nneed a sensor?\"]\n\n    style A1 fill:#e3f2fd,stroke:#1565c0\n    style B1 fill:#fff3e0,stroke:#ef6c00\n    style C1 fill:#f8bbd9,stroke:#c2185b\n    style D1 fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/02-sensor-integration/#smart-autonomous-example","title":"Smart Autonomous Example","text":"<pre><code>def smart_autonomous():\n    \"\"\"Autonomous using multiple sensors.\"\"\"\n\n    # 1. Calibrate inertial (required first!)\n    inertial_sensor.calibrate()\n    wait(3, SECONDS)\n\n    # 2. Drive until we see a goal (Distance sensor)\n    while distance_sensor.object_distance(MM) &gt; 200:\n        drive_straight(100)  # Uses Inertial for correction\n\n    # 3. Check block color before scoring (Optical sensor)\n    if optical_sensor.is_near_object():\n        if optical_sensor.color() == our_alliance_color:\n            # Score it!\n            intake_motor.spin(FORWARD)\n            wait(500, MSEC)\n        else:\n            # Wrong color, back away\n            drivetrain.drive_for(REVERSE, 200, MM)\n\n    # 4. Return to starting position (GPS sensor)\n    go_to_position(0, -500)\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#sensor-combination-examples","title":"Sensor Combination Examples","text":"Sensors Combined Use Case Inertial + Distance Drive straight until reaching wall Inertial + GPS Navigate to coordinates accurately Distance + Optical Approach block and check color All four Full autonomous navigation"},{"location":"07-advanced/02-sensor-integration/#summary","title":"Summary","text":"Sensor Measures Best For Inertial Heading, rotation Accurate turns, straight driving Distance Distance to objects Wall detection, stopping Optical Color, proximity Block sorting, line following GPS Field position Navigation, return-to-position"},{"location":"07-advanced/02-sensor-integration/#sensors-in-push-back-competition","title":"Sensors in Push Back Competition","text":"<p>Each sensor helps you score more points in the Push Back game!</p>"},{"location":"07-advanced/02-sensor-integration/#inertial-sensor-for-accurate-autonomous","title":"Inertial Sensor for Accurate Autonomous","text":"<pre><code>def push_back_auto_with_inertial():\n    \"\"\"\n    Autonomous that uses inertial for precise movements.\n    Accurate turns = More blocks in goals!\n    \"\"\"\n    inertial_sensor.calibrate()\n    wait(3, SECONDS)\n\n    # Drive straight toward first block cluster\n    drive_straight_with_correction(600)\n\n    # Turn exactly 45\u00b0 to face long goal\n    turn_to_heading(45)\n\n    # Push blocks into goal\n    drivetrain.drive_for(FORWARD, 400, MM)\n\n    # Back up and turn to face center\n    drivetrain.drive_for(REVERSE, 200, MM)\n    turn_to_heading(90)\n\n    # Continue to next goal...\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#distance-sensor-for-goal-approach","title":"Distance Sensor for Goal Approach","text":"<pre><code>def approach_goal_safely():\n    \"\"\"\n    Use distance sensor to stop at perfect pushing distance.\n    Too close = can't push effectively\n    Too far = blocks don't reach goal\n    \"\"\"\n    OPTIMAL_PUSH_DISTANCE = 100  # mm\n\n    while distance_sensor.object_distance(MM) &gt; OPTIMAL_PUSH_DISTANCE:\n        drivetrain.drive(FORWARD, 50, PERCENT)\n        wait(20, MSEC)\n\n    drivetrain.stop()\n    return True  # Ready to push!\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#optical-sensor-for-block-selection","title":"Optical Sensor for Block Selection","text":"<pre><code>flowchart LR\n    A[\"Block\\napproaches\"] --&gt; B{\"Optical:\\nWhat color?\"}\n    B --&gt;|\"RED\"| C{\"Our alliance\\n= RED?\"}\n    B --&gt;|\"BLUE\"| D{\"Our alliance\\n= BLUE?\"}\n    C --&gt;|\"YES\"| E[\"Grab it!\"]\n    C --&gt;|\"NO\"| F[\"Eject!\"]\n    D --&gt;|\"YES\"| E\n    D --&gt;|\"NO\"| F\n\n    style E fill:#c8e6c9,stroke:#2e7d32\n    style F fill:#ffcdd2,stroke:#c62828</code></pre> <pre><code>def smart_intake(our_alliance_color):\n    \"\"\"\n    Only intake blocks of our alliance color!\n    Scoring opponent's blocks helps THEM!\n    \"\"\"\n    if optical_sensor.is_near_object():\n        block_color = optical_sensor.color()\n\n        if block_color == our_alliance_color:\n            intake_motor.spin(FORWARD)\n            wait(500, MSEC)\n            intake_motor.stop()\n            return True  # Got our block!\n        else:\n            intake_motor.spin(REVERSE)\n            wait(300, MSEC)\n            intake_motor.stop()\n            return False  # Rejected opponent's block\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#gps-for-skills-autonomous","title":"GPS for Skills Autonomous","text":"<pre><code>def skills_with_gps():\n    \"\"\"\n    Use GPS to navigate efficiently across entire field.\n    Skills = 60 seconds to cover whole field!\n    \"\"\"\n    # Phase 1: Score at long goal\n    go_to_position(-600, 200)\n    push_blocks_into_goal()\n\n    # Phase 2: Score at center\n    go_to_position(0, 0)\n    push_blocks_into_goal()\n\n    # Phase 3: Score at far goal\n    go_to_position(600, 200)\n    push_blocks_into_goal()\n\n    # Phase 4: PARK! (GPS ensures we hit the zone)\n    go_to_position(0, -700)  # Park zone coordinates\n    drivetrain.stop()\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#progressive-exercises","title":"Progressive Exercises","text":""},{"location":"07-advanced/02-sensor-integration/#beginner-stop-before-wall","title":"Beginner: Stop Before Wall","text":"<p>Goal: Use distance sensor to stop before hitting a wall.</p> <pre><code>def drive_until_wall():\n    \"\"\"Drive forward and stop 150mm from wall.\"\"\"\n\n    while distance_sensor.object_distance(MM) &gt; 150:\n        drivetrain.drive(FORWARD, 50, PERCENT)\n        wait(20, MSEC)\n\n    drivetrain.stop()\n    print(\"Stopped at:\", distance_sensor.object_distance(MM), \"mm\")\n</code></pre> <p>Success criteria: Robot stops consistently at 150mm \u00b120mm</p>"},{"location":"07-advanced/02-sensor-integration/#intermediate-drive-straight-with-inertial-correction","title":"Intermediate: Drive Straight with Inertial Correction","text":"<p>Goal: Drive in a straight line using inertial sensor for heading correction.</p> <pre><code>def drive_straight_500mm():\n    \"\"\"Drive 500mm in a straight line using heading correction.\"\"\"\n    Kp = 0.5\n    start_heading = inertial_sensor.heading()\n\n    # Calculate target based on wheel rotations\n    start_position = left_motor_front.position(DEGREES)\n    target_degrees = 500 / WHEEL_TRAVEL_MM * 360\n\n    while left_motor_front.position(DEGREES) - start_position &lt; target_degrees:\n        current_heading = inertial_sensor.heading()\n        error = start_heading - current_heading\n\n        # YOUR CODE: Handle wraparound\n        # if error &gt; 180: error -= 360\n        # if error &lt; -180: error += 360\n\n        correction = Kp * error\n\n        # YOUR CODE: Apply correction to motors\n        # left_motors.set_velocity(50 + correction, PERCENT)\n        # right_motors.set_velocity(50 - correction, PERCENT)\n\n        left_motors.spin(FORWARD)\n        right_motors.spin(FORWARD)\n        wait(20, MSEC)\n\n    drivetrain.stop()\n</code></pre> <p>Test: Push the robot sideways while it's driving - it should correct itself!</p>"},{"location":"07-advanced/02-sensor-integration/#challenge-block-color-sorting","title":"Challenge: Block Color Sorting","text":"<p>Goal: Create a system that only picks up blocks of your alliance color.</p> <pre><code>def color_sorting_intake():\n    \"\"\"\n    Complete intake system that:\n    1. Detects when a block is near\n    2. Checks the color\n    3. Grabs our color, ejects opponent's color\n    \"\"\"\n    OUR_ALLIANCE = Color.RED  # Change for your alliance\n\n    # YOUR CODE: Turn on optical sensor LED\n    # optical_sensor.set_light_power(100)\n    # optical_sensor.set_light(LedStateType.ON)\n\n    while True:\n        if optical_sensor.is_near_object():\n            detected_color = optical_sensor.color()\n\n            # YOUR CODE: Compare to alliance color\n            # If match: intake FORWARD\n            # If no match: intake REVERSE (eject)\n\n            # YOUR CODE: Run motor for appropriate time\n            # wait() and then stop motor\n\n        wait(50, MSEC)\n</code></pre> <p>Bonus: Display the color on the Brain screen when detected!</p>"},{"location":"07-advanced/02-sensor-integration/#common-mistakes-with-sensors","title":"Common Mistakes with Sensors","text":""},{"location":"07-advanced/02-sensor-integration/#mistake-1-forgetting-to-calibrate-inertial","title":"Mistake 1: Forgetting to Calibrate Inertial","text":"<pre><code># WRONG: Use inertial without calibrating\ndef bad_autonomous():\n    heading = inertial_sensor.heading()  # Random garbage value!\n\n# RIGHT: Always calibrate first\ndef good_autonomous():\n    inertial_sensor.calibrate()\n    wait(3, SECONDS)  # MUST wait!\n    heading = inertial_sensor.heading()  # Accurate!\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#mistake-2-moving-during-calibration","title":"Mistake 2: Moving During Calibration","text":"<pre><code># WRONG: Robot moves during calibration\ndef bad_calibration():\n    inertial_sensor.calibrate()\n    drivetrain.drive(FORWARD)  # Moving while calibrating!\n    wait(3, SECONDS)\n\n# RIGHT: Stay perfectly still\ndef good_calibration():\n    drivetrain.stop()  # Ensure stopped\n    inertial_sensor.calibrate()\n    wait(3, SECONDS)  # Robot is still\n    # NOW safe to move\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#mistake-3-not-waiting-enough-for-calibration","title":"Mistake 3: Not Waiting Enough for Calibration","text":"<pre><code># WRONG: Not enough wait time\ninertial_sensor.calibrate()\nwait(1, SECONDS)  # Too short!\n\n# RIGHT: Full 3 seconds\ninertial_sensor.calibrate()\nwait(3, SECONDS)  # Proper calibration time\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#mistake-4-forgetting-to-turn-on-optical-led","title":"Mistake 4: Forgetting to Turn On Optical LED","text":"<pre><code># WRONG: Optical sensor doesn't work reliably\ncolor = optical_sensor.color()  # Depends on room lighting!\n\n# RIGHT: Turn on LED for consistent lighting\noptical_sensor.set_light_power(100)\noptical_sensor.set_light(LedStateType.ON)\ncolor = optical_sensor.color()  # Consistent!\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#mistake-5-wrong-units","title":"Mistake 5: Wrong Units","text":"<pre><code># WRONG: Mixing up units\ndist = distance_sensor.object_distance(INCHES)  # Oops, wanted MM!\nif dist &gt; 150:  # This is 150 inches, not 150mm!\n\n# RIGHT: Be consistent with units\ndist = distance_sensor.object_distance(MM)\nif dist &gt; 150:  # 150mm as intended\n</code></pre>"},{"location":"07-advanced/02-sensor-integration/#how-sensors-connect-to-push-back","title":"How Sensors Connect to Push Back","text":"Sensor Push Back Use Points Impact Inertial Accurate turns to face goals More blocks in goals (+3 each) Inertial Straight line block pushing Blocks reach goal, not walls Distance Stop at optimal pushing distance Efficient pushing Distance Detect goals and walls Avoid collisions Optical Identify alliance blocks Don't score opponent's blocks! GPS Navigate entire field in Skills Cover all 3 goal areas GPS Return to park zone Guarantee 8-30 points"},{"location":"07-advanced/02-sensor-integration/#sensors-consistent-scores","title":"Sensors = Consistent Scores","text":"<pre><code>flowchart LR\n    subgraph \"Without Sensors\"\n        A1[\"Match 1:\\n45 points\"] --&gt; B1[\"Match 2:\\n28 points\"]\n        B1 --&gt; C1[\"Match 3:\\n52 points\"]\n        C1 --&gt; D1[\"INCONSISTENT\"]\n    end\n\n    subgraph \"With Sensors\"\n        A2[\"Match 1:\\n58 points\"] --&gt; B2[\"Match 2:\\n55 points\"]\n        B2 --&gt; C2[\"Match 3:\\n60 points\"]\n        C2 --&gt; D2[\"CONSISTENT!\"]\n    end\n\n    style D1 fill:#ffcdd2,stroke:#c62828\n    style D2 fill:#c8e6c9,stroke:#2e7d32</code></pre> <p>Bottom line: Sensors make your robot reliable. Reliable robots win tournaments!</p> <p>\u2190 Previous: PID Control | Next: Skills Autonomous \u2192 | Review Q&amp;A</p>"},{"location":"07-advanced/03-skills-autonomous/","title":"Tutorial 7.3: Skills Autonomous (Advanced)","text":"<p>Time: ~20 minutes Prerequisites: Tutorial 7.2: Sensor Integration Level: Bonus/Advanced</p>"},{"location":"07-advanced/03-skills-autonomous/#what-is-skills","title":"What is Skills?","text":"<p>Skills is a special competition format where one robot runs solo for 60 seconds (instead of 15). It's your chance to show off what your robot can do independently!</p>"},{"location":"07-advanced/03-skills-autonomous/#match-vs-skills-comparison","title":"Match vs Skills Comparison","text":"<pre><code>flowchart LR\n    subgraph \"Match Autonomous (15 sec)\"\n        A1[\"Start\"] --&gt; B1[\"Score\\n2-3 blocks\"]\n        B1 --&gt; C1[\"Maybe park\"]\n        C1 --&gt; D1[\"Done!\\n(15 sec)\"]\n    end\n\n    subgraph \"Skills Autonomous (60 sec)\"\n        A2[\"Start\"] --&gt; B2[\"Phase 1:\\nFirst goal\"]\n        B2 --&gt; C2[\"Phase 2:\\nCenter goal\"]\n        C2 --&gt; D2[\"Phase 3:\\nFar goal\"]\n        D2 --&gt; E2[\"Phase 4:\\nPARK!\"]\n        E2 --&gt; F2[\"Done!\\n(60 sec)\"]\n    end\n\n    style D1 fill:#fff3e0,stroke:#ef6c00\n    style F2 fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#real-world-analogies","title":"Real-World Analogies","text":""},{"location":"07-advanced/03-skills-autonomous/#the-restaurant-kitchen-analogy","title":"The Restaurant Kitchen Analogy","text":"<p>Think of Skills like a chef preparing multiple dishes:</p> Kitchen Task Skills Equivalent Prep station 1 (salads) Phase 1: First goal area Prep station 2 (entrees) Phase 2: Center goal area Prep station 3 (desserts) Phase 3: Far goal area Plating and serving Phase 4: PARKING! <p>A good chef times everything so it all comes together. You need to time your Skills routine the same way!</p>"},{"location":"07-advanced/03-skills-autonomous/#video-game-levels-analogy","title":"Video Game Levels Analogy","text":"<p>Skills is like speedrunning through 4 levels of a video game:</p> <pre><code>Level 1 (0-18 sec):  \u2b50\u2b50\u2b50 Easy goals, build your score\nLevel 2 (18-36 sec): \u2b50\u2b50\u2b50 Medium goals, keep going\nLevel 3 (36-52 sec): \u2b50\u2b50\u2b50 Hard goals, clean up\nBoss Level (52-60 sec): PARK for bonus points!\n</code></pre> <p>If you don't reach the boss level (parking), you lose major points!</p>"},{"location":"07-advanced/03-skills-autonomous/#test-taking-strategy-analogy","title":"Test-Taking Strategy Analogy","text":"<p>Managing 60 seconds in Skills is like managing time on a test:</p> <ul> <li>Don't get stuck on one question \u2192 Don't waste time on one stuck phase</li> <li>Answer easy questions first \u2192 Score easy blocks first</li> <li>Save time for review \u2192 Always save time for parking</li> <li>Budget your time \u2192 Time budget for each phase</li> </ul>"},{"location":"07-advanced/03-skills-autonomous/#why-skills-matters","title":"Why Skills Matters","text":"<p>Skills runs determine tournament rankings and qualification for higher-level competitions!</p>"},{"location":"07-advanced/03-skills-autonomous/#skills-scoring-formula","title":"Skills Scoring Formula","text":"<pre><code>flowchart LR\n    A[\"Best Autonomous\\nSkills Score\"] --&gt; C[\"+\"]\n    B[\"Best Driver\\nSkills Score\"] --&gt; C\n    C --&gt; D[\"Combined\\nSkills Ranking\"]\n    D --&gt; E[\"Top teams\\nadvance to Worlds!\"]\n\n    style E fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#planning-a-60-second-routine","title":"Planning a 60-Second Routine","text":""},{"location":"07-advanced/03-skills-autonomous/#visual-time-budget","title":"Visual Time Budget","text":"<pre><code>flowchart LR\n    subgraph \"60 Second Skills Timeline\"\n        A[\"0 sec\\nSTART\"] --&gt; B[\"Phase 1\\n0-18 sec\"]\n        B --&gt; C[\"Phase 2\\n18-36 sec\"]\n        C --&gt; D[\"Phase 3\\n36-52 sec\"]\n        D --&gt; E[\"Phase 4\\n52-60 sec\"]\n        E --&gt; F[\"60 sec\\nDONE\"]\n    end\n\n    B1[\"First goal\\narea\"] -.-&gt; B\n    C1[\"Center goal\\narea\"] -.-&gt; C\n    D1[\"Far goal\\narea\"] -.-&gt; D\n    E1[\"PARK!\"] -.-&gt; E\n\n    style E fill:#c8e6c9,stroke:#2e7d32\n    style E1 fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#time-budget-summary","title":"Time Budget Summary","text":"Phase Time Range Duration Goal Phase 1 0-18 sec 18 sec First goal area Phase 2 18-36 sec 18 sec Center goal area Phase 3 36-52 sec 16 sec Far goal + cleanup Phase 4 52-60 sec 8 sec PARK! <p>Critical: Phase 4 (parking) is NON-NEGOTIABLE. Always budget 8 seconds for parking!</p>"},{"location":"07-advanced/03-skills-autonomous/#field-coverage-strategy","title":"Field Coverage Strategy","text":"<pre><code>flowchart TB\n    subgraph \"Skills Field Strategy\"\n        A[\"START\\nPosition\"]\n\n        G1[\"GOAL 1\\n(Left)\"]\n        G2[\"CENTER\\nGOAL\"]\n        G3[\"GOAL 2\\n(Right)\"]\n\n        P[\"PARK\\nZONE\"]\n\n        A --&gt;|\"Phase 1\\n0-18s\"| G1\n        G1 --&gt;|\"Phase 2\\n18-36s\"| G2\n        G2 --&gt;|\"Phase 3\\n36-52s\"| G3\n        G3 --&gt;|\"Phase 4\\n52-60s\"| P\n    end\n\n    style P fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#key-strategy-points","title":"Key Strategy Points","text":"<ol> <li>Work in sequence - Don't waste time crossing back and forth</li> <li>End near park zone - Phase 3 should position you for Phase 4</li> <li>Don't get greedy - Skip a block if it means missing parking</li> <li>Know your escape routes - Have a path to park from any location</li> </ol>"},{"location":"07-advanced/03-skills-autonomous/#state-machine-pattern","title":"State Machine Pattern","text":"<p>For complex routines, use a state machine - a way to organize code where your robot can be in different \"states\" and transitions between them based on conditions.</p>"},{"location":"07-advanced/03-skills-autonomous/#what-is-a-state-machine","title":"What is a State Machine?","text":"<p>Think of it like a flowchart in code. Your robot is always in ONE state, and it moves to other states based on time or events.</p> <pre><code>stateDiagram-v2\n    [*] --&gt; INIT\n    INIT --&gt; PHASE1: Setup complete\n    PHASE1 --&gt; PHASE2: timer &gt; 18s\n    PHASE2 --&gt; PHASE3: timer &gt; 36s\n    PHASE3 --&gt; PARK: timer &gt; 52s\n    PARK --&gt; DONE: Parked!\n    DONE --&gt; [*]</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#state-machine-flowchart","title":"State Machine Flowchart","text":"<pre><code>flowchart TD\n    START[\"START\\nstate = INIT\"]\n    START --&gt; INIT[\"STATE_INIT\\nSetup &amp; calibrate\"]\n    INIT --&gt; CHECK1{\"timer &gt; 0?\"}\n    CHECK1 --&gt;|\"YES\"| P1[\"STATE_PHASE1\\nFirst goal area\"]\n    P1 --&gt; CHECK2{\"timer &gt; 18s?\"}\n    CHECK2 --&gt;|\"NO\"| P1\n    CHECK2 --&gt;|\"YES\"| P2[\"STATE_PHASE2\\nCenter goal area\"]\n    P2 --&gt; CHECK3{\"timer &gt; 36s?\"}\n    CHECK3 --&gt;|\"NO\"| P2\n    CHECK3 --&gt;|\"YES\"| P3[\"STATE_PHASE3\\nFar goal area\"]\n    P3 --&gt; CHECK4{\"timer &gt; 52s?\"}\n    CHECK4 --&gt;|\"NO\"| P3\n    CHECK4 --&gt;|\"YES\"| PARK[\"STATE_PARK\\nDrive to park!\"]\n    PARK --&gt; DONE[\"STATE_DONE\\nComplete!\"]\n\n    style PARK fill:#c8e6c9,stroke:#2e7d32\n    style DONE fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#state-machine-code","title":"State Machine Code","text":"<pre><code># States - like chapters in a book\nSTATE_INIT = 0\nSTATE_PHASE1 = 1\nSTATE_PHASE2 = 2\nSTATE_PHASE3 = 3\nSTATE_PARK = 4\nSTATE_DONE = 5\n\ndef skills_autonomous():\n    \"\"\"60-second skills autonomous using state machine.\"\"\"\n    state = STATE_INIT  # Start in INIT state\n    timer = Timer()\n\n    while state != STATE_DONE:\n\n        if state == STATE_INIT:\n            # Setup: calibrate sensors, get ready\n            setup_autonomous()\n            timer.reset()\n            state = STATE_PHASE1  # Move to next state\n\n        elif state == STATE_PHASE1:\n            # Score first area\n            phase1_scoring()\n\n            # Time-based transition\n            if timer.time(SECONDS) &gt; 18:\n                state = STATE_PHASE2\n\n        elif state == STATE_PHASE2:\n            # Score second area\n            phase2_scoring()\n\n            if timer.time(SECONDS) &gt; 36:\n                state = STATE_PHASE3\n\n        elif state == STATE_PHASE3:\n            # Score third area\n            phase3_scoring()\n\n            # CRITICAL: Leave time for parking!\n            if timer.time(SECONDS) &gt; 52:\n                state = STATE_PARK\n\n        elif state == STATE_PARK:\n            # Go to park zone - highest priority!\n            drive_to_park()\n            state = STATE_DONE\n\n        wait(20, MSEC)  # Control loop rate\n</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#why-use-a-state-machine","title":"Why Use a State Machine?","text":"Benefit Explanation Organized Clear separation of phases Flexible Easy to skip phases if behind Debuggable Know exactly which state failed Time-aware Easy to check time and transition"},{"location":"07-advanced/03-skills-autonomous/#breaking-into-functions","title":"Breaking Into Functions","text":""},{"location":"07-advanced/03-skills-autonomous/#modular-design","title":"Modular Design","text":"<pre><code>def phase1_scoring():\n    \"\"\"Score blocks in first goal area.\"\"\"\n    # Drive to first block cluster\n    drivetrain.drive_for(FORWARD, 600, MM)\n    wait(100, MSEC)\n\n    # Turn toward goal\n    drivetrain.turn_for(RIGHT, 45, DEGREES)\n    wait(100, MSEC)\n\n    # Push into goal\n    drivetrain.drive_for(FORWARD, 400, MM)\n    wait(100, MSEC)\n\n    # Back up\n    drivetrain.drive_for(REVERSE, 200, MM)\n\n\ndef phase2_scoring():\n    \"\"\"Score blocks in center goal.\"\"\"\n    # Navigate to center\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    wait(100, MSEC)\n\n    drivetrain.drive_for(FORWARD, 800, MM)\n    wait(100, MSEC)\n\n    # Score in center goal\n    drivetrain.turn_for(RIGHT, 45, DEGREES)\n    drivetrain.drive_for(FORWARD, 300, MM)\n\n\ndef phase3_scoring():\n    \"\"\"Score remaining blocks.\"\"\"\n    # Clean up phase\n    drivetrain.drive_for(REVERSE, 300, MM)\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    drivetrain.drive_for(FORWARD, 500, MM)\n\n\ndef drive_to_park():\n    \"\"\"Navigate to park zone.\"\"\"\n    # Calculate path to park\n    # Use GPS if available!\n    drivetrain.turn_for(LEFT, 135, DEGREES)\n    drivetrain.drive_for(FORWARD, 1000, MM)\n</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#using-timers","title":"Using Timers","text":"<pre><code># Create timer\ntimer = Timer()\n\n# Reset timer\ntimer.reset()\n\n# Read time\nelapsed = timer.time(SECONDS)\nelapsed_ms = timer.time(MSEC)\n\n# Example: Time-limited action\ntimer.reset()\nwhile timer.time(SECONDS) &lt; 5:\n    drivetrain.drive(FORWARD)\ndrivetrain.stop()\n</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#error-recovery","title":"Error Recovery","text":"<p>In Skills, things can go wrong - blocks get stuck, robots collide with field elements, etc. Good code handles errors gracefully.</p>"},{"location":"07-advanced/03-skills-autonomous/#error-recovery-analogy-cooking-with-backup-plans","title":"Error Recovery Analogy: Cooking with Backup Plans","text":"<p>Like cooking with backup plans: - Recipe calls for ingredient you're out of \u2192 substitute - Dish is taking too long \u2192 skip to next course - Something burns \u2192 don't serve it, move on</p>"},{"location":"07-advanced/03-skills-autonomous/#error-recovery-flowchart","title":"Error Recovery Flowchart","text":"<pre><code>flowchart TD\n    A[\"Start Phase 1\"] --&gt; B[\"Try action\"]\n    B --&gt; C{\"Success?\"}\n    C --&gt;|\"YES\"| D[\"Continue\"]\n    C --&gt;|\"NO\"| E{\"Timeout?\"}\n    E --&gt;|\"YES\"| F[\"Skip to\\nnext phase\"]\n    E --&gt;|\"NO\"| G[\"Retry once\"]\n    G --&gt; B\n    F --&gt; H[\"Log error\"]\n    H --&gt; I[\"Continue to\\nPhase 2\"]\n    D --&gt; I\n\n    J[\"ALWAYS\\nPARK!\"] --&gt; K[\"Done\"]\n    I --&gt; J\n\n    style F fill:#fff3e0,stroke:#ef6c00\n    style J fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#timeout-protection","title":"Timeout Protection","text":"<pre><code>def safe_drive_for(distance, timeout=3):\n    \"\"\"\n    Drive with timeout protection.\n    Returns True if successful, False if timed out.\n    \"\"\"\n    timer = Timer()\n    timer.reset()\n\n    # Start driving (non-blocking)\n    drivetrain.drive_for(FORWARD, distance, MM, wait=False)\n\n    while drivetrain.is_moving():\n        # Check for timeout\n        if timer.time(SECONDS) &gt; timeout:\n            drivetrain.stop()\n            brain.screen.print(\"TIMEOUT!\")\n            return False  # Failed!\n\n        wait(20, MSEC)\n\n    return True  # Success!\n</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#recovery-actions","title":"Recovery Actions","text":"<pre><code>def skills_with_recovery():\n    \"\"\"Skills with error recovery - NEVER skip parking!\"\"\"\n\n    # Phase 1 with recovery\n    if not phase1_scoring():\n        # Phase 1 failed - skip to phase 2\n        brain.screen.print(\"Phase 1 timeout!\")\n        # DON'T stop - continue to Phase 2!\n\n    # Phase 2 with recovery\n    if not phase2_scoring():\n        brain.screen.print(\"Phase 2 timeout!\")\n        # Still continue!\n\n    # Phase 3 with recovery\n    if not phase3_scoring():\n        brain.screen.print(\"Phase 3 timeout!\")\n\n    # \u26a0\ufe0f ALWAYS try to park - this is NEVER skipped!\n    drive_to_park()\n    brain.screen.print(\"PARKED!\")\n</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#the-golden-rule","title":"The Golden Rule","text":"<pre><code>flowchart LR\n    A[\"Phase 1\\nfails\"] --&gt; B[\"Continue\"]\n    B --&gt; C[\"Phase 2\\nfails\"]\n    C --&gt; D[\"Continue\"]\n    D --&gt; E[\"Phase 3\\nfails\"]\n    E --&gt; F[\"Continue\"]\n    F --&gt; G[\"ALWAYS\\nPARK!\"]\n\n    style G fill:#c8e6c9,stroke:#2e7d32</code></pre> <p>No matter what goes wrong, ALWAYS execute the parking phase!</p>"},{"location":"07-advanced/03-skills-autonomous/#skills-template","title":"Skills Template","text":"<pre><code>def skills_autonomous():\n    \"\"\"\n    60-second Skills Autonomous for Push Back.\n    Template for building your routine.\n    \"\"\"\n    brain.screen.print(\"Skills Started\")\n\n    setup_autonomous()\n    timer = Timer()\n    timer.reset()\n\n    # ========================================\n    # PHASE 1: First Goal (0-18 sec)\n    # ========================================\n    brain.screen.print(\"Phase 1\")\n\n    # YOUR PHASE 1 CODE HERE\n    drivetrain.drive_for(FORWARD, 500, MM)\n    # ...\n\n    # ========================================\n    # PHASE 2: Center Goal (18-36 sec)\n    # ========================================\n    if timer.time(SECONDS) &lt; 36:\n        brain.screen.print(\"Phase 2\")\n\n        # YOUR PHASE 2 CODE HERE\n        # ...\n\n    # ========================================\n    # PHASE 3: Third Goal (36-52 sec)\n    # ========================================\n    if timer.time(SECONDS) &lt; 52:\n        brain.screen.print(\"Phase 3\")\n\n        # YOUR PHASE 3 CODE HERE\n        # ...\n\n    # ========================================\n    # PHASE 4: PARK (52-60 sec)\n    # ========================================\n    brain.screen.print(\"PARKING!\")\n\n    # Navigate to park zone\n    # YOUR PARKING CODE HERE\n    # ...\n\n    brain.screen.print(\"Skills Complete\")\n</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#summary","title":"Summary","text":"Aspect Match Autonomous Skills Autonomous Time 15 seconds 60 seconds Complexity Simple Complex Structure Linear State machine Recovery Limited Essential Parking Optional Critical!"},{"location":"07-advanced/03-skills-autonomous/#skills-in-push-back-competition","title":"Skills in Push Back Competition","text":"<p>Skills runs can make or break your tournament ranking. Here's how to maximize your Push Back Skills score:</p>"},{"location":"07-advanced/03-skills-autonomous/#push-back-skills-point-calculator","title":"Push Back Skills Point Calculator","text":"<pre><code>def calculate_skills_score():\n    \"\"\"Calculate expected Skills score for Push Back.\"\"\"\n\n    # Block scoring (3 points each)\n    blocks_phase1 = 4  # First goal area\n    blocks_phase2 = 4  # Center area\n    blocks_phase3 = 3  # Far goal + cleanup\n    total_blocks = blocks_phase1 + blocks_phase2 + blocks_phase3\n    block_points = total_blocks * 3  # = 33 points\n\n    # Zone control bonuses\n    long_goal_control = 10   # If more blocks than opponent\n    center_control = 8       # Center zone\n    zone_points = long_goal_control + center_control  # = 18 points\n\n    # Parking bonus\n    parking_points = 8  # Solo parking\n\n    total = block_points + zone_points + parking_points\n    print(f\"Expected Skills Score: {total} points\")\n    return total  # = 59 points!\n</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#complete-push-back-skills-autonomous","title":"Complete Push Back Skills Autonomous","text":"<pre><code>def push_back_skills_autonomous():\n    \"\"\"\n    Complete 60-second Skills autonomous for Push Back.\n    Goal: ~50-60 points\n    \"\"\"\n\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    # SETUP\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    brain.screen.print(\"Skills Starting...\")\n    inertial_sensor.calibrate()\n    wait(3, SECONDS)\n\n    timer = Timer()\n    timer.reset()\n\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    # PHASE 1: LONG GOAL (0-18 sec)\n    # Target: 4 blocks + zone control = 22 points\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    brain.screen.print(\"Phase 1: Long Goal\")\n\n    # Drive to first block cluster\n    safe_drive_for(600)\n    turn_to_heading(45)\n\n    # Push blocks into long goal\n    safe_drive_for(400)\n    drivetrain.drive_for(REVERSE, 200, MM)\n\n    # Get more blocks\n    turn_to_heading(90)\n    safe_drive_for(300)\n    turn_to_heading(45)\n    safe_drive_for(300)\n\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    # PHASE 2: CENTER GOALS (18-36 sec)\n    # Target: 4 blocks = 12 points\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    if timer.time(SECONDS) &lt; 36:\n        brain.screen.print(\"Phase 2: Center\")\n\n        # Navigate to center\n        turn_to_heading(90)\n        safe_drive_for(800)\n\n        # Push into center goal\n        turn_to_heading(0)\n        safe_drive_for(400)\n        drivetrain.drive_for(REVERSE, 200, MM)\n\n        # Score additional blocks\n        turn_to_heading(180)\n        safe_drive_for(300)\n\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    # PHASE 3: FAR GOAL (36-52 sec)\n    # Target: 3 blocks = 9 points\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    if timer.time(SECONDS) &lt; 52:\n        brain.screen.print(\"Phase 3: Far Goal\")\n\n        # Cross to far side\n        turn_to_heading(135)\n        safe_drive_for(600)\n\n        # Push into far goal\n        safe_drive_for(300)\n\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    # PHASE 4: PARK! (52-60 sec)\n    # Target: 8 points GUARANTEED\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    brain.screen.print(\"PARKING!\")\n\n    # Calculate path to park zone\n    # (Use GPS if available for accuracy)\n    turn_to_heading(270)\n    safe_drive_for(800)\n\n    # Final positioning\n    drivetrain.stop()\n    brain.screen.print(\"Skills Complete!\")\n</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#skills-score-breakdown","title":"Skills Score Breakdown","text":"<pre><code>flowchart TB\n    subgraph \"Push Back Skills Target Score\"\n        A[\"Phase 1:\\n4 blocks \u00d7 3\\n+ zone bonus\\n= 22 pts\"]\n        B[\"Phase 2:\\n4 blocks \u00d7 3\\n= 12 pts\"]\n        C[\"Phase 3:\\n3 blocks \u00d7 3\\n= 9 pts\"]\n        D[\"Phase 4:\\nParking\\n= 8 pts\"]\n        E[\"TOTAL:\\n~51 points\"]\n    end\n\n    A --&gt; E\n    B --&gt; E\n    C --&gt; E\n    D --&gt; E\n\n    style E fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#progressive-exercises","title":"Progressive Exercises","text":""},{"location":"07-advanced/03-skills-autonomous/#beginner-2-phase-skills-with-timer","title":"Beginner: 2-Phase Skills with Timer","text":"<p>Goal: Create a simple skills routine with timing.</p> <pre><code>def beginner_skills():\n    \"\"\"Simple 2-phase Skills routine.\"\"\"\n    timer = Timer()\n    timer.reset()\n\n    # PHASE 1: Score some blocks (0-30 sec)\n    while timer.time(SECONDS) &lt; 30:\n        # YOUR CODE: Drive forward and push blocks\n        drivetrain.drive_for(FORWARD, 500, MM)\n        drivetrain.drive_for(REVERSE, 200, MM)\n\n    # PHASE 2: PARK! (30-60 sec)\n    # YOUR CODE: Navigate to park zone\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    drivetrain.drive_for(FORWARD, 800, MM)\n\n    drivetrain.stop()\n</code></pre> <p>Success criteria: Robot parks within the 60-second time limit</p>"},{"location":"07-advanced/03-skills-autonomous/#intermediate-4-phase-state-machine","title":"Intermediate: 4-Phase State Machine","text":"<p>Goal: Implement a full state machine with 4 phases.</p> <pre><code>STATE_INIT = 0\nSTATE_PHASE1 = 1\nSTATE_PHASE2 = 2\nSTATE_PHASE3 = 3\nSTATE_PARK = 4\nSTATE_DONE = 5\n\ndef intermediate_skills():\n    \"\"\"4-phase Skills with state machine.\"\"\"\n    state = STATE_INIT\n    timer = Timer()\n\n    while state != STATE_DONE:\n\n        if state == STATE_INIT:\n            # YOUR CODE: Setup and calibrate\n            timer.reset()\n            state = STATE_PHASE1\n\n        elif state == STATE_PHASE1:\n            # YOUR CODE: Score at first goal\n            brain.screen.print(\"Phase 1\")\n\n            if timer.time(SECONDS) &gt; 18:\n                state = STATE_PHASE2\n\n        elif state == STATE_PHASE2:\n            # YOUR CODE: Score at center\n            brain.screen.print(\"Phase 2\")\n\n            if timer.time(SECONDS) &gt; 36:\n                state = STATE_PHASE3\n\n        elif state == STATE_PHASE3:\n            # YOUR CODE: Score at far goal\n            brain.screen.print(\"Phase 3\")\n\n            if timer.time(SECONDS) &gt; 52:\n                state = STATE_PARK\n\n        elif state == STATE_PARK:\n            # YOUR CODE: Drive to park zone\n            brain.screen.print(\"PARKING!\")\n            state = STATE_DONE\n\n        wait(20, MSEC)\n</code></pre> <p>Test: Does the robot transition between phases correctly?</p>"},{"location":"07-advanced/03-skills-autonomous/#challenge-full-skills-with-recovery-and-gps","title":"Challenge: Full Skills with Recovery and GPS","text":"<p>Goal: Complete Skills autonomous with error recovery and GPS parking.</p> <pre><code>def advanced_skills():\n    \"\"\"Full Skills with error recovery and GPS.\"\"\"\n\n    # Setup\n    inertial_sensor.calibrate()\n    wait(3, SECONDS)\n    timer = Timer()\n    timer.reset()\n\n    # Phase 1 with recovery\n    success = phase1_scoring()\n    if not success:\n        brain.screen.print(\"Phase 1 FAILED - continuing\")\n\n    # Phase 2 with recovery\n    if timer.time(SECONDS) &lt; 36:\n        success = phase2_scoring()\n        if not success:\n            brain.screen.print(\"Phase 2 FAILED - continuing\")\n\n    # Phase 3 with recovery\n    if timer.time(SECONDS) &lt; 52:\n        success = phase3_scoring()\n        if not success:\n            brain.screen.print(\"Phase 3 FAILED - continuing\")\n\n    # ALWAYS PARK using GPS for accuracy\n    park_x = 0    # Center X\n    park_y = -700  # Near back wall\n\n    # YOUR CODE: Use go_to_position() with GPS\n    # go_to_position(park_x, park_y)\n\n    drivetrain.stop()\n    brain.screen.print(\"PARKED!\")\n\n\ndef phase1_scoring():\n    \"\"\"Phase 1 with timeout protection.\"\"\"\n    phase_timer = Timer()\n    phase_timer.reset()\n\n    # YOUR CODE: Implement phase 1 with safe_drive_for()\n    # Return False if phase takes too long\n\n    return True  # or False on timeout\n</code></pre> <p>Bonus: Display current state and timer on Brain screen!</p>"},{"location":"07-advanced/03-skills-autonomous/#common-mistakes-with-skills-autonomous","title":"Common Mistakes with Skills Autonomous","text":""},{"location":"07-advanced/03-skills-autonomous/#mistake-1-no-parking-phase","title":"Mistake 1: No Parking Phase","text":"<pre><code># WRONG: Skills without parking\ndef bad_skills():\n    phase1_scoring()\n    phase2_scoring()\n    phase3_scoring()\n    # Where's parking? Lost 8-30 points!\n\n# RIGHT: ALWAYS include parking\ndef good_skills():\n    phase1_scoring()\n    phase2_scoring()\n    phase3_scoring()\n    drive_to_park()  # Never skip this!\n</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#mistake-2-poor-time-budgeting","title":"Mistake 2: Poor Time Budgeting","text":"<pre><code># WRONG: Spending too long on early phases\ndef bad_timing():\n    # Phase 1 takes 45 seconds!\n    while timer.time(SECONDS) &lt; 45:\n        score_blocks()\n    # Only 15 seconds left for phases 2, 3, AND parking!\n\n# RIGHT: Stick to time budget\ndef good_timing():\n    while timer.time(SECONDS) &lt; 18:  # 18 seconds max\n        score_blocks()\n    # Move on even if not done\n</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#mistake-3-no-error-recovery","title":"Mistake 3: No Error Recovery","text":"<pre><code># WRONG: One failure stops everything\ndef fragile_skills():\n    drive_forward(500)  # What if robot gets stuck?\n    # Robot is stuck forever!\n\n# RIGHT: Timeout protection\ndef robust_skills():\n    if not safe_drive_for(500, timeout=3):\n        # Move on if stuck\n        brain.screen.print(\"Skipping...\")\n    # Continue with next action\n</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#mistake-4-blocking-function-calls","title":"Mistake 4: Blocking Function Calls","text":"<pre><code># WRONG: Can't check time while driving\ndrivetrain.drive_for(FORWARD, 1000, MM)  # Blocks for 5+ seconds!\n# Can't check timer during this time\n\n# RIGHT: Non-blocking with monitoring\ndrivetrain.drive_for(FORWARD, 1000, MM, wait=False)\nwhile drivetrain.is_moving():\n    if timer.time(SECONDS) &gt; 52:\n        drivetrain.stop()\n        break  # Time for parking!\n    wait(20, MSEC)\n</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#mistake-5-forgetting-calibration","title":"Mistake 5: Forgetting Calibration","text":"<pre><code># WRONG: No calibration\ndef skills_no_calibrate():\n    turn_to_heading(90)  # Inaccurate!\n\n# RIGHT: Calibrate first\ndef skills_with_calibrate():\n    inertial_sensor.calibrate()\n    wait(3, SECONDS)  # Must wait!\n    turn_to_heading(90)  # Accurate!\n</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#how-skills-connects-to-push-back","title":"How Skills Connects to Push Back","text":"Skills Concept Push Back Application Points Impact Time budgeting Cover all 3 goals More blocks scored State machine Organized 4-phase routine Reliable execution Error recovery Skip stuck blocks, continue Don't waste time Parking phase ALWAYS park at end 8-30 guaranteed points Field coverage Visit all goal areas Zone control bonuses"},{"location":"07-advanced/03-skills-autonomous/#skills-vs-match-strategy","title":"Skills vs Match Strategy","text":"<pre><code>flowchart LR\n    subgraph \"Match (15 sec)\"\n        M1[\"Score 2-3\\nblocks\"] --&gt; M2[\"Maybe\\npark\"]\n        M2 --&gt; M3[\"~15 pts\"]\n    end\n\n    subgraph \"Skills (60 sec)\"\n        S1[\"Phase 1:\\n12 pts\"] --&gt; S2[\"Phase 2:\\n12 pts\"]\n        S2 --&gt; S3[\"Phase 3:\\n9 pts\"]\n        S3 --&gt; S4[\"Park:\\n8 pts\"]\n        S4 --&gt; S5[\"~51 pts\"]\n    end\n\n    style M3 fill:#fff3e0,stroke:#ef6c00\n    style S5 fill:#c8e6c9,stroke:#2e7d32</code></pre>"},{"location":"07-advanced/03-skills-autonomous/#why-skills-matters-for-tournament-success","title":"Why Skills Matters for Tournament Success","text":"<ol> <li>Skills ranking determines tiebreakers</li> <li>Top Skills scores qualify for State/Worlds</li> <li>Consistent Skills shows robot reliability</li> <li>Skills practice improves Match autonomous</li> </ol> <p>Bottom line: A good Skills autonomous can be the difference between qualifying for Worlds and going home!</p> <p>\u2190 Previous: Sensor Integration | Next: Review Q&amp;A \u2192</p>"},{"location":"07-advanced/04-review-qa/","title":"Advanced Topics Q&amp;A: Self-Assessment Guide","text":"<p>For: VEX V5 Push Back Competition Level: Advanced (Tutorials 7.1-7.3)</p> <p>Use this guide to test your understanding of PID control, sensor integration, and skills autonomous programming. Each section has 18 questions covering conceptual understanding, code reading, and Push Back application.</p>"},{"location":"07-advanced/04-review-qa/#section-1-pid-control-18-questions","title":"Section 1: PID Control (18 Questions)","text":""},{"location":"07-advanced/04-review-qa/#conceptual-questions-q1-q6","title":"Conceptual Questions (Q1-Q6)","text":"<p>Q1: What does PID stand for, and what is its purpose in robotics?</p> <p>Q2: Why is \"bang-bang\" control (on/off at 100%) a problem for accurate movements?</p> <p>Q3: In PID, what does the \"P\" (Proportional) term do? How does it respond to error?</p> <p>Q4: What is the role of the \"I\" (Integral) term? When is it most useful?</p> <p>Q5: What does the \"D\" (Derivative) term predict, and how does it help?</p> <p>Q6: If your robot overshoots the target and oscillates back and forth, which tuning constant should you adjust first?</p>"},{"location":"07-advanced/04-review-qa/#code-reading-questions-q7-q12","title":"Code Reading Questions (Q7-Q12)","text":"<p>Q7: Trace through this P controller. What will <code>correction</code> be when <code>current = 30</code> and <code>target = 90</code>?</p> <pre><code>Kp = 0.5\ntarget = 90\ncurrent = 30\nerror = target - current\ncorrection = Kp * error\n</code></pre> <p>Q8: What's wrong with this PID code? (Hint: think about stop conditions)</p> <pre><code>def turn_to_heading(target):\n    Kp = 0.8\n    while True:\n        current = inertial_sensor.heading()\n        error = target - current\n        correction = Kp * error\n        left_motors.spin(FORWARD, correction, PERCENT)\n        right_motors.spin(FORWARD, -correction, PERCENT)\n        wait(20, MSEC)\n</code></pre> <p>Q9: Why do we need heading wraparound handling? What problem does this code solve?</p> <pre><code>if error &gt; 180:\n    error -= 360\nelif error &lt; -180:\n    error += 360\n</code></pre> <p>Q10: In this PI controller, what happens to <code>integral</code> over time if <code>error</code> stays at 2?</p> <pre><code>integral = 0\nwhile True:\n    error = target - current\n    integral += error\n    correction = (Kp * error) + (Ki * integral)\n</code></pre> <p>Q11: What does this line do and why limit the correction value?</p> <pre><code>correction = max(-50, min(50, correction))\n</code></pre> <p>Q12: When should you use P-only control vs. PI control vs. full PID?</p>"},{"location":"07-advanced/04-review-qa/#push-back-application-questions-q13-q18","title":"Push Back Application Questions (Q13-Q18)","text":"<p>Q13: During Push Back autonomous, you need to turn exactly 45\u00b0 to face a goal. Which controller type would you use and why?</p> <p>Q14: Your robot keeps stopping 3\u00b0 short of the target heading. The P controller shows <code>error = 3</code> but <code>correction = 1.5%</code> isn't enough to overcome friction. What should you add?</p> <p>Q15: Design a P controller for Push Back that makes the robot push blocks in a straight line. What sensor would you use, and what would be your target value?</p> <p>Q16: For parking at the end of a Push Back match, would you prefer aggressive PID (high Kp) or gentle PID (low Kp)? Explain your reasoning.</p> <p>Q17: What Kp value range would you start with for a VEX V5 turning P controller? What symptoms would tell you it's too high or too low?</p> <p>Q18: How could PID help your robot align with a goal before pushing blocks during the 15-second autonomous period?</p>"},{"location":"07-advanced/04-review-qa/#section-2-sensor-integration-18-questions","title":"Section 2: Sensor Integration (18 Questions)","text":""},{"location":"07-advanced/04-review-qa/#conceptual-questions-q19-q24","title":"Conceptual Questions (Q19-Q24)","text":"<p>Q19: What's the difference between a robot using <code>drivetrain.drive_for(500, MM)</code> vs. using a distance sensor to drive until reaching a target?</p> <p>Q20: Why must you call <code>inertial_sensor.calibrate()</code> and wait 3 seconds before using the inertial sensor?</p> <p>Q21: What's the difference between <code>inertial_sensor.heading()</code> (0-360\u00b0) and <code>inertial_sensor.rotation()</code> (unbounded)?</p> <p>Q22: Name the four main sensors discussed and what each one measures.</p> <p>Q23: Why does the optical sensor need its LED turned on before detecting colors?</p> <p>Q24: What does the GPS sensor measure, and why is it called \"knowing your position\" rather than \"guessing\"?</p>"},{"location":"07-advanced/04-review-qa/#code-reading-questions-q25-q30","title":"Code Reading Questions (Q25-Q30)","text":"<p>Q25: Trace through this code. If <code>current_heading = 85</code> and <code>start_heading = 90</code>, what is <code>correction</code> when <code>Kp = 0.5</code>?</p> <pre><code>start_heading = 90\ncurrent_heading = 85\nerror = start_heading - current_heading\ncorrection = Kp * error\n</code></pre> <p>Q26: What's the purpose of <code>wait=False</code> in this code?</p> <pre><code>drivetrain.drive_for(FORWARD, distance, MM, wait=False)\nwhile drivetrain.is_moving():\n    # Check for timeout\n    wait(20, MSEC)\n</code></pre> <p>Q27: What does this distance sensor code do? What happens when the robot is far from a wall?</p> <pre><code>while distance_sensor.object_distance(MM) &gt; 150:\n    drivetrain.drive(FORWARD, 50, PERCENT)\n    wait(20, MSEC)\ndrivetrain.stop()\n</code></pre> <p>Q28: In this optical sensor code, what happens if the sensor detects a BLUE block but our alliance is RED?</p> <pre><code>if optical_sensor.is_near_object():\n    detected_color = optical_sensor.color()\n    if detected_color == our_alliance_color:\n        intake_motor.spin(FORWARD)\n    else:\n        intake_motor.spin(REVERSE)  # Eject!\n</code></pre> <p>Q29: What does this GPS navigation code calculate? What's the purpose of <code>math.atan2</code>?</p> <pre><code>dx = target_x - current_x\ndy = target_y - current_y\ndistance = (dx**2 + dy**2) ** 0.5\ntarget_angle = math.degrees(math.atan2(dy, dx))\n</code></pre> <p>Q30: Why do we apply correction to both left and right motors but with opposite signs?</p> <pre><code>left_motors.set_velocity(50 + correction, PERCENT)\nright_motors.set_velocity(50 - correction, PERCENT)\n</code></pre>"},{"location":"07-advanced/04-review-qa/#push-back-application-questions-q31-q36","title":"Push Back Application Questions (Q31-Q36)","text":"<p>Q31: You're building a Push Back autonomous that needs to drive forward until the robot is 100mm from the goal. Which sensor would you use and how?</p> <p>Q32: During autonomous, how could you use the inertial sensor to ensure your robot drives straight while pushing blocks?</p> <p>Q33: In Push Back, teams have red and blue blocks. How would you use the optical sensor to pick up only your alliance color's blocks?</p> <p>Q34: Your robot needs to return to its starting position after scoring to get in position for the next action. Which sensor would give you the most accurate return path?</p> <p>Q35: Design a sensor-based autonomous for Push Back that:    - Drives forward until 150mm from wall    - Turns 90\u00b0 using inertial sensor    - Drives forward until 200mm from next wall    What sensors do you need?</p> <p>Q36: How would you combine the inertial sensor and distance sensor to create a \"smart push\" function that drives straight toward a goal and stops at the right distance?</p>"},{"location":"07-advanced/04-review-qa/#section-3-skills-autonomous-18-questions","title":"Section 3: Skills Autonomous (18 Questions)","text":""},{"location":"07-advanced/04-review-qa/#conceptual-questions-q37-q42","title":"Conceptual Questions (Q37-Q42)","text":"<p>Q37: What's the main difference between Match Autonomous (15 seconds) and Skills Autonomous (60 seconds)?</p> <p>Q38: What is a \"state machine\" and why is it useful for 60-second routines?</p> <p>Q39: Why is the parking phase (final 5-8 seconds) so critical in Skills? What points are at stake?</p> <p>Q40: What does \"error recovery\" mean in Skills autonomous? Why is it more important than in Match autonomous?</p> <p>Q41: How do you use a Timer in VEX V5 Python? What methods are available?</p> <p>Q42: Explain the concept of \"time budgeting\" for a 60-second Skills run.</p>"},{"location":"07-advanced/04-review-qa/#code-reading-questions-q43-q48","title":"Code Reading Questions (Q43-Q48)","text":"<p>Q43: In this state machine, what causes the transition from STATE_PHASE1 to STATE_PHASE2?</p> <pre><code>if state == STATE_PHASE1:\n    phase1_scoring()\n    if timer.time(SECONDS) &gt; 20:\n        state = STATE_PHASE2\n</code></pre> <p>Q44: What's the purpose of <code>wait=False</code> in this timeout protection code?</p> <pre><code>def safe_drive_for(distance, timeout=3):\n    timer = Timer()\n    timer.reset()\n    drivetrain.drive_for(FORWARD, distance, MM, wait=False)\n\n    while drivetrain.is_moving():\n        if timer.time(SECONDS) &gt; timeout:\n            drivetrain.stop()\n            return False\n        wait(20, MSEC)\n    return True\n</code></pre> <p>Q45: Why does the Skills template check <code>if timer.time(SECONDS) &lt; 36:</code> before starting Phase 2?</p> <p>Q46: What happens if Phase 1 fails (returns False) in this recovery code?</p> <pre><code>if not phase1_scoring():\n    brain.screen.print(\"Phase 1 timeout!\")\n# Phase 2 continues...\nif not phase2_scoring():\n    brain.screen.print(\"Phase 2 timeout!\")\n# Always try to park\ndrive_to_park()\n</code></pre> <p>Q47: Trace through this state machine. If the timer shows 55 seconds, what state should the robot be in?</p> <pre><code>STATE_INIT = 0\nSTATE_PHASE1 = 1  # 0-20 sec\nSTATE_PHASE2 = 2  # 20-40 sec\nSTATE_PHASE3 = 3  # 40-55 sec\nSTATE_PARK = 4    # 55-60 sec\n</code></pre> <p>Q48: Why do we use <code>wait(20, MSEC)</code> at the end of our while loops in autonomous code?</p>"},{"location":"07-advanced/04-review-qa/#push-back-application-questions-q49-q54","title":"Push Back Application Questions (Q49-Q54)","text":"<p>Q49: Design a 4-phase time budget for a 60-second Push Back Skills run. Include specific goals for each phase.</p> <p>Q50: In Push Back Skills, there are three goal areas. How would you plan your robot's path to score in all three areas within 60 seconds?</p> <p>Q51: You're programming a Skills autonomous for Push Back. The robot gets stuck on a block at 25 seconds. How would your error recovery handle this?</p> <p>Q52: Why should your Skills routine always include a parking phase, even if you haven't finished scoring? Calculate the point difference.</p> <p>Q53: How would you use state variables to track your scoring progress during a Push Back Skills run?</p> <pre><code>blocks_scored_phase1 = 0\nblocks_scored_phase2 = 0\ncurrent_phase = STATE_INIT\n</code></pre> <p>Q54: Design a Skills strategy that maximizes points in Push Back. Consider:    - Block scoring (3 points each)    - Zone control bonuses (6-10 points)    - Parking bonus (8 or 30 points)</p>"},{"location":"07-advanced/04-review-qa/#answer-key","title":"Answer Key","text":""},{"location":"07-advanced/04-review-qa/#section-1-pid-control","title":"Section 1: PID Control","text":"<p>A1: PID stands for Proportional-Integral-Derivative. It's a control algorithm that helps robots move more accurately by adjusting motor power based on how far away they are from the target (P), how long they've been off target (I), and how fast they're approaching the target (D).</p> <p>A2: Bang-bang control causes overshoot and oscillation. When motors run at 100% until the exact target, the robot has too much momentum to stop precisely. It overshoots, reverses at 100%, undershoots, and keeps oscillating around the target instead of stopping smoothly.</p> <p>A3: The P term provides correction proportional to the error. If you're far from target, you get a big correction. As you get closer, the correction automatically decreases. Formula: <code>correction = Kp \u00d7 error</code>. This creates smooth approaches to targets.</p> <p>A4: The I term accumulates error over time. It's most useful when the P controller can't overcome static friction. If the robot is stuck 2\u00b0 from target and P gives only 1% power (not enough to move), the I term adds up that error until the correction is strong enough to move.</p> <p>A5: The D term predicts future error based on how fast the error is changing. If error is decreasing quickly (you're approaching target fast), D reduces the correction to prevent overshoot. If error is increasing, D adds more correction. It acts like a \"damper\" to smooth out movements.</p> <p>A6: You should decrease Kp first. Oscillation means the proportional response is too aggressive. A lower Kp will make the robot slow down more gradually as it approaches the target, reducing overshoot.</p> <p>A7: <pre><code>error = 90 - 30 = 60\ncorrection = 0.5 \u00d7 60 = 30\n</code></pre> The correction will be 30% motor power.</p> <p>A8: The code is missing a stop condition! The <code>while True</code> loop never breaks, so even when the robot reaches the target, it keeps trying to correct. It needs: <pre><code>if abs(error) &lt; 2:  # Tolerance of 2 degrees\n    left_motors.stop()\n    right_motors.stop()\n    break\n</code></pre></p> <p>A9: Heading wraparound handles the 0-360 degree boundary problem. Example: If current heading is 350\u00b0 and target is 10\u00b0, the simple calculation gives error = 10 - 350 = -340\u00b0. But the shortest turn is actually +20\u00b0! The wraparound code fixes this by converting -340\u00b0 to +20\u00b0 (adding 360).</p> <p>A10: The <code>integral</code> grows by 2 each loop iteration: - Cycle 1: integral = 0 + 2 = 2 - Cycle 2: integral = 2 + 2 = 4 - Cycle 3: integral = 4 + 2 = 6 - And so on...</p> <p>This accumulation eventually provides enough correction to overcome friction or steady-state error.</p> <p>A11: This line clamps the correction to a maximum of \u00b150%. It prevents the motors from going too fast, which could cause: - Wheel slippage - Loss of traction - Dangerous robot speeds - Mechanical stress</p> <p>A12: - P-only: Good for simple movements where you don't need perfect precision (90% of cases) - PI: When the robot consistently stops short of target due to friction - Full PID: When you need both precision AND smooth stopping without oscillation (advanced use)</p> <p>A13: Use P-only control with the inertial sensor. For a 45\u00b0 turn, P control provides smooth deceleration as you approach the target. Formula: <code>error = 45 - current_heading</code>, <code>correction = Kp * error</code>. Start with Kp = 0.5-1.0.</p> <p>A14: Add the I (Integral) term. The I term accumulates the small error over time: 3 + 3 + 3... until the correction is strong enough to overcome friction. Use a small Ki like 0.01 to prevent overshooting.</p> <p>A15: Use the inertial sensor with target = starting heading: <pre><code>start_heading = inertial_sensor.heading()  # Save at start\n# In driving loop:\nerror = start_heading - current_heading\ncorrection = Kp * error\nleft_motors.set_velocity(50 + correction, PERCENT)\nright_motors.set_velocity(50 - correction, PERCENT)\n</code></pre></p> <p>A16: Gentle PID (low Kp) is better for parking because: - You don't need to rush (just get there before time runs out) - Smooth movements reduce the chance of overshooting the park zone - Lower speeds prevent momentum from carrying you out of the zone - More controlled = more reliable parking</p> <p>A17: Start with Kp = 0.5 to 1.0 for VEX V5 turning. - Too high: Robot oscillates around target, overshoots, jerky movements - Too low: Robot turns slowly, may not reach target (especially with friction), sluggish response - Just right: Quick turn that slows smoothly as it approaches target, minimal overshoot</p> <p>A18: PID helps with goal alignment by: 1. Using inertial sensor to measure current heading 2. Calculating error = desired heading toward goal - current heading 3. Applying smooth correction: as robot gets closer to facing the goal, correction decreases 4. Stopping precisely when aligned (error &lt; 2\u00b0)</p> <p>This ensures you're facing the goal accurately before pushing blocks.</p>"},{"location":"07-advanced/04-review-qa/#section-2-sensor-integration","title":"Section 2: Sensor Integration","text":"<p>A19: <code>drive_for(500, MM)</code> is open-loop - it calculates distance from motor rotations and hopes it's accurate. Wheel slip, battery changes, and friction affect it. Using a distance sensor is closed-loop - it continuously measures actual distance to target and stops when you're actually there, regardless of wheel slip.</p> <p>A20: Calibration is necessary because the inertial sensor (IMU) needs to: 1. Find its zero point (level position) 2. Compensate for any sensor drift 3. Set up internal reference for accurate heading readings The 3-second wait ensures calibration completes. Moving during calibration causes bad readings!</p> <p>A21: - heading() returns 0-360\u00b0 and resets at 360\u00b0 (like a compass, good for absolute directions) - rotation() is unbounded (-\u221e to +\u221e) and tracks total rotation (good for counting turns: 720\u00b0 = 2 full rotations)</p> <p>Use heading for \"turn to face north,\" use rotation for \"turn exactly 2 full circles.\"</p> <p>A22: | Sensor | Measures | |--------|----------| | Inertial (IMU) | Heading (direction), rotation, acceleration | | Distance | Distance to objects in millimeters | | Optical | Color, light intensity, proximity | | GPS | X/Y position on field, heading |</p> <p>A23: The optical sensor uses an LED to illuminate objects and measures reflected light to detect color. Without the LED on, the sensor relies on ambient light, which varies and gives inconsistent readings. The LED provides controlled, consistent lighting for accurate color detection.</p> <p>A24: GPS measures your exact X and Y coordinates on the field (in mm from center) plus heading. It \"knows\" position because it uses external reference (the field strip code) rather than calculating from wheel rotations. It's like using a real GPS vs. counting your steps - the GPS directly measures where you are.</p> <p>A25: <pre><code>error = 90 - 85 = 5\ncorrection = 0.5 \u00d7 5 = 2.5\n</code></pre> The correction is 2.5% - meaning the left motors get 52.5% and right motors get 47.5% to correct the drift to the left.</p> <p>A26: <code>wait=False</code> makes the command non-blocking - it starts the movement but immediately returns so your code can continue. This allows you to: - Monitor sensors while moving - Check for timeout conditions - React to obstacles mid-movement Without it, the code waits until movement finishes before continuing.</p> <p>A27: The code drives forward until the wall is 150mm away, then stops. When far from a wall (distance &gt; 150mm), it keeps driving at 50% speed. The <code>wait(20, MSEC)</code> prevents CPU overload. This is useful for approaching goals or walls without crashing.</p> <p>A28: If the sensor detects BLUE but alliance is RED: - <code>detected_color == our_alliance_color</code> evaluates to <code>False</code> - The <code>else</code> branch executes: <code>intake_motor.spin(REVERSE)</code> - The block is ejected instead of picked up</p> <p>This prevents scoring opponent blocks in your goal, which would help the other team!</p> <p>A29: The code calculates: 1. <code>dx, dy</code> = horizontal and vertical distance to target 2. <code>distance</code> = straight-line distance using Pythagorean theorem (\u221a(dx\u00b2 + dy\u00b2)) 3. <code>target_angle</code> = direction to face the target using <code>atan2</code> (arctangent that handles all quadrants correctly)</p> <p><code>atan2(dy, dx)</code> is better than <code>atan(dy/dx)</code> because it handles all four quadrants and avoids division by zero.</p> <p>A30: Opposite signs create differential steering: - To turn right: left motors faster (+correction), right motors slower (-correction) - To turn left: left motors slower (-correction), right motors faster (+correction)</p> <p>If the robot drifts left of target (positive error), the correction makes left motors spin faster, turning the robot right back toward the target.</p> <p>A31: Use the distance sensor: <pre><code>while distance_sensor.object_distance(MM) &gt; 100:\n    drivetrain.drive(FORWARD, 50, PERCENT)\n    wait(20, MSEC)\ndrivetrain.stop()\n</code></pre> This drives until exactly 100mm from the goal, perfect for pushing blocks without ramming the wall.</p> <p>A32: Use inertial sensor for heading correction: <pre><code>start_heading = inertial_sensor.heading()\nwhile pushing:\n    current_heading = inertial_sensor.heading()\n    error = start_heading - current_heading\n    # Apply correction to keep heading constant\n    left_motors.set_velocity(50 + Kp * error, PERCENT)\n    right_motors.set_velocity(50 - Kp * error, PERCENT)\n</code></pre> This keeps the robot driving straight even if it bumps blocks.</p> <p>A33: Use the optical sensor: <pre><code>our_alliance_color = Color.RED  # Set at match start\noptical_sensor.set_light(LedStateType.ON)\n\nif optical_sensor.is_near_object():\n    if optical_sensor.color() == our_alliance_color:\n        intake_motor.spin(FORWARD)  # Pick up!\n    else:\n        intake_motor.spin(REVERSE)  # Eject opponent's block!\n</code></pre></p> <p>A34: The GPS sensor gives the most accurate return path because: - It provides absolute X/Y position on the field - Not affected by wheel slip during the scoring run - Can navigate back to exact starting coordinates - More reliable than dead reckoning from motor encoders</p> <p>A35: You need two sensors: 1. Distance sensor (front-mounted) - for detecting walls 2. Inertial sensor - for accurate 90\u00b0 turn</p> <pre><code># Phase 1: Drive to first wall\nwhile distance_sensor.object_distance(MM) &gt; 150:\n    drive_straight()  # Uses inertial for correction\ndrivetrain.stop()\n\n# Phase 2: Turn 90\u00b0\nturn_to_heading(90)  # Using inertial sensor\n\n# Phase 3: Drive to second wall\nwhile distance_sensor.object_distance(MM) &gt; 200:\n    drive_straight()\ndrivetrain.stop()\n</code></pre> <p>A36: Combine both sensors: <pre><code>def smart_push(target_distance):\n    start_heading = inertial_sensor.heading()\n    Kp = 0.5\n\n    while distance_sensor.object_distance(MM) &gt; target_distance:\n        # Heading correction for straight driving\n        current = inertial_sensor.heading()\n        error = start_heading - current\n        # Handle wraparound\n        if error &gt; 180: error -= 360\n        elif error &lt; -180: error += 360\n\n        correction = Kp * error\n        left_motors.spin(FORWARD, 50 + correction, PERCENT)\n        right_motors.spin(FORWARD, 50 - correction, PERCENT)\n        wait(20, MSEC)\n\n    drivetrain.stop()\n</code></pre></p>"},{"location":"07-advanced/04-review-qa/#section-3-skills-autonomous","title":"Section 3: Skills Autonomous","text":"<p>A37: Key differences: | Aspect | Match Autonomous | Skills Autonomous | |--------|------------------|-------------------| | Time | 15 seconds | 60 seconds | | Complexity | Simple, linear | Complex, multi-phase | | Field Coverage | One area | Entire field | | Partner | Alliance partner helps | Solo - you're alone! | | Scoring Impact | Sets up driver period | Affects tournament ranking |</p> <p>A38: A state machine is a programming pattern where the robot can be in different \"states\" (like PHASE1, PHASE2, PARK) and transitions between them based on conditions (like time or completion). It's useful for 60-second routines because: - Keeps code organized - Easy to skip phases if running late - Clear transitions between tasks - Easier to debug (you know which state failed)</p> <p>A39: Parking is critical because it's guaranteed points: - One robot parked: 8 points - Both robots parked: 30 points</p> <p>Even if you score 5 blocks (15 points) but don't park, an opponent who scores 3 blocks (9 points) and parks both robots (30 points) beats you 39-15! Always budget 5-8 seconds for parking.</p> <p>A40: Error recovery means having a backup plan when something goes wrong. In Skills (60 seconds), there's time to recover: - If Phase 1 takes too long \u2192 skip to Phase 2 - If robot gets stuck \u2192 timeout and try next action - If scoring fails \u2192 proceed to parking anyway</p> <p>In Match (15 seconds), there's no time to recover, so routines are simpler.</p> <p>A41: VEX V5 Timer usage: <pre><code>timer = Timer()      # Create timer\ntimer.reset()        # Start/restart timer at 0\ntime = timer.time(SECONDS)   # Read time in seconds\ntime = timer.time(MSEC)      # Read time in milliseconds\n</code></pre> Use it for phase transitions, timeouts, and tracking total elapsed time.</p> <p>A42: Time budgeting means planning how long each phase should take: <pre><code>60 seconds total:\n\u251c\u2500\u2500 Phase 1 (0-18 sec):  First goal area\n\u251c\u2500\u2500 Phase 2 (18-36 sec): Center area\n\u251c\u2500\u2500 Phase 3 (36-52 sec): Third goal area\n\u2514\u2500\u2500 Phase 4 (52-60 sec): PARKING!\n</code></pre> Always budget from the end (parking first), then allocate remaining time.</p> <p>A43: The transition happens when <code>timer.time(SECONDS) &gt; 20</code> - meaning 20 seconds have passed since the timer was reset. The phase1_scoring() function runs repeatedly until time exceeds 20 seconds, then state changes to STATE_PHASE2.</p> <p>A44: <code>wait=False</code> makes drive_for non-blocking, meaning the code continues to the while loop immediately instead of waiting for the drive to complete. This allows checking for timeout while the robot is still moving. Without it, you couldn't implement timeout protection.</p> <p>A45: The check <code>timer.time(SECONDS) &lt; 36</code> ensures Phase 2 only runs if there's time left. If Phase 1 took too long (used up all the time until second 36), Phase 2 is skipped to save time for parking. It's part of error recovery - better to skip a phase than miss parking.</p> <p>A46: If Phase 1 fails (returns False): 1. \"Phase 1 timeout!\" is printed to the Brain screen 2. Code continues to Phase 2 (no crash or halt) 3. If Phase 2 also fails, another message is printed 4. drive_to_park() always runs - parking is never skipped</p> <p>This is graceful degradation - even if scoring fails, we guarantee the parking points.</p> <p>A47: At 55 seconds, the robot should be in STATE_PARK (Phase 4). According to the time budget: - STATE_PHASE1: 0-20 sec - STATE_PHASE2: 20-40 sec - STATE_PHASE3: 40-55 sec - STATE_PARK: 55-60 sec</p> <p>At exactly 55 seconds, the transition from PHASE3 to PARK should occur.</p> <p>A48: <code>wait(20, MSEC)</code> serves multiple purposes: 1. Prevents CPU overload - without it, the loop runs millions of times per second 2. Matches motor update rate - VEX motors update every ~20ms anyway 3. Allows other code to run - gives the VEX OS time for background tasks 4. Consistent loop timing - makes PID calculations predictable</p> <p>20ms = 50 loops per second, which is plenty fast for smooth control.</p> <p>A49: Push Back Skills 60-second time budget: <pre><code>Phase 1 (0-18 sec): LONG GOAL\n  - Drive to first block cluster\n  - Push 3-4 blocks into long goal\n  - Back up to get next blocks\n  Goal: 9-12 points + zone control (10 points)\n\nPhase 2 (18-36 sec): CENTER GOALS\n  - Navigate to center field\n  - Score in center upper or lower goal\n  - Clear blocks toward goal zones\n  Goal: 9-12 points + zone control (6-8 points)\n\nPhase 3 (36-52 sec): OPPOSITE GOAL\n  - Cross to far side of field\n  - Push remaining blocks\n  - Position for parking\n  Goal: 6-9 points\n\nPhase 4 (52-60 sec): PARKING\n  - Navigate to park zone\n  - Ensure fully inside zone\n  - Stop and wait\n  Goal: 8-30 points guaranteed\n</code></pre></p> <p>A50: Field path strategy: <pre><code>START \u2192 LONG GOAL \u2192 CENTER \u2192 FAR GOAL \u2192 PARK\n\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502   [GOAL 1]    [CENTER]    [GOAL 2] \u2502\n \u2502      \u2191           \u2191           \u2191     \u2502\n \u2502      1st         2nd         3rd   \u2502\n \u2502   (0-18s)     (18-36s)    (36-52s) \u2502\n \u2502                                     \u2502\n \u2502              [PARK]                 \u2502\n \u2502                 \u2191                   \u2502\n \u2502              4th (52-60s)           \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nKey: Work in sequence across field, end near parking zone.\nPlan return path before Phase 3 ends!\n</code></pre></p> <p>A51: Error recovery for stuck robot at 25 seconds: <pre><code>def phase2_scoring():\n    timer = Timer()\n    timer.reset()\n\n    # Try to push blocks\n    if not safe_drive_for(300, timeout=2):\n        # Stuck! Try backing up\n        drivetrain.drive_for(REVERSE, 150, MM)\n\n        # Try alternate route\n        drivetrain.turn_for(RIGHT, 30, DEGREES)\n        safe_drive_for(200, timeout=2)\n\n    # If still stuck after 8 seconds, give up and move on\n    if timer.time(SECONDS) &gt; 8:\n        return False  # Signal to skip to next phase\n\n    return True\n</code></pre></p> <p>At 25 seconds, Phase 2 should be almost done. The timeout protection ensures we don't waste all remaining time on one stuck action.</p> <p>A52: Parking point analysis: - Without parking: 0 points from parking - With 1 robot parked: 8 points guaranteed - With 2 robots parked: 30 points guaranteed</p> <p>Scenario comparison: - Score 8 blocks (24 points) + no parking = 24 points - Score 5 blocks (15 points) + solo parking = 23 points - Score 5 blocks (15 points) + both park = 45 points!</p> <p>Even missing 3 blocks of scoring is worth it for the parking bonus. Always include parking phase!</p> <p>A53: State variables track progress: <pre><code># Initialize at start\nblocks_scored_phase1 = 0\nblocks_scored_phase2 = 0\nblocks_scored_phase3 = 0\ncurrent_phase = STATE_INIT\ntotal_blocks = 0\n\n# Update during phases\ndef phase1_scoring():\n    global blocks_scored_phase1, total_blocks\n\n    push_blocks_to_goal()\n    blocks_scored_phase1 = 4  # Estimate or count\n    total_blocks += blocks_scored_phase1\n\n    brain.screen.print(f\"Phase 1: {blocks_scored_phase1} blocks\")\n    brain.screen.print(f\"Total: {total_blocks} blocks\")\n\n# At end\nestimated_score = total_blocks * 3 + parking_bonus\nbrain.screen.print(f\"Estimated: {estimated_score} points\")\n</code></pre></p> <p>A54: Maximum points Skills strategy for Push Back:</p> <p>Target Score Calculation: - Blocks: 15 blocks \u00d7 3 points = 45 points - Zone control: 1 long goal (10) + 1 center (6-8) = 16-18 points - Parking: 8-30 points</p> <p>Maximum realistic score: ~60-90 points solo</p> <p>Strategy: <pre><code>1. START: Long goal side (easier to control one goal)\n\n2. PHASE 1 (0-18 sec): Secure long goal zone control\n   - Push 4-5 blocks into long goal\n   - Establish zone control = 10 bonus points\n   - Total: ~25 points\n\n3. PHASE 2 (18-36 sec): Center field cleanup\n   - Push blocks toward center goal\n   - Score 3-4 blocks = 9-12 points\n   - Aim for center zone control = 6-8 points\n   - Total: ~40 points\n\n4. PHASE 3 (36-52 sec): Far goal + positioning\n   - Score 2-3 more blocks = 6-9 points\n   - Position near parking zone\n   - Total: ~52 points\n\n5. PHASE 4 (52-60 sec): GUARANTEED PARKING\n   - Navigate to park zone\n   - Solo parking = 8 points\n   - Total: ~60 points\n\nKey Insight: Don't chase the last few blocks if it risks\nmissing parking. The 8-30 point swing is huge!\n</code></pre></p>"},{"location":"07-advanced/04-review-qa/#study-tips","title":"Study Tips","text":""},{"location":"07-advanced/04-review-qa/#for-pid-control","title":"For PID Control:","text":"<ol> <li>Start with P-only control - it works for most cases</li> <li>Add I only when robot consistently stops short</li> <li>Add D only when you see oscillation that Kp reduction doesn't fix</li> <li>Test tuning with your actual robot - every robot is different!</li> </ol>"},{"location":"07-advanced/04-review-qa/#for-sensor-integration","title":"For Sensor Integration:","text":"<ol> <li>Always calibrate inertial sensor before each run</li> <li>Test sensors individually before combining them</li> <li>Use <code>wait=False</code> for movements you want to monitor</li> <li>Remember wraparound for heading calculations</li> </ol>"},{"location":"07-advanced/04-review-qa/#for-skills-autonomous","title":"For Skills Autonomous:","text":"<ol> <li>Time budget from the END (parking first)</li> <li>Use a state machine for complex routines</li> <li>Add timeout protection to every movement</li> <li>Test each phase individually before combining</li> <li>ALWAYS include parking phase!</li> </ol> <p>Good luck with your VEX V5 Push Back competition!</p> <p>\u2190 Previous: Skills Autonomous | Next: Appendix \u2192</p>"},{"location":"appendix/glossary/","title":"Glossary","text":"<p>Technical terms explained simply for 8th graders.</p>"},{"location":"appendix/glossary/#a","title":"A","text":""},{"location":"appendix/glossary/#alliance","title":"Alliance","text":"<p>Two teams that work together during a match. In VEX competitions, you're paired with a different alliance partner for each match.</p>"},{"location":"appendix/glossary/#arcade-drive","title":"Arcade Drive","text":"<p>A control scheme where one joystick controls both forward/backward movement AND turning. The robot mixes these inputs to calculate motor speeds.</p>"},{"location":"appendix/glossary/#autonomous","title":"Autonomous","text":"<p>The 15-second period at the start of each match where robots run pre-programmed code with NO driver input. The robot drives itself!</p>"},{"location":"appendix/glossary/#axis","title":"Axis","text":"<p>A joystick direction. VEX controllers have 4 axes: - Axis 1: Right stick left/right - Axis 2: Right stick up/down - Axis 3: Left stick up/down - Axis 4: Left stick left/right</p>"},{"location":"appendix/glossary/#b","title":"B","text":""},{"location":"appendix/glossary/#boolean","title":"Boolean","text":"<p>A data type that can only be <code>True</code> or <code>False</code>. Used for yes/no decisions in code.</p>"},{"location":"appendix/glossary/#brain","title":"Brain","text":"<p>The VEX V5 Brain - the main computer that runs your robot's code. Has a touchscreen, 21 ports, and a battery connector.</p>"},{"location":"appendix/glossary/#brake","title":"BRAKE","text":"<p>A motor stopping mode where the motor actively resists movement. The robot stops quickly but can still be pushed.</p>"},{"location":"appendix/glossary/#c","title":"C","text":""},{"location":"appendix/glossary/#calibrate","title":"Calibrate","text":"<p>To set a sensor's starting reference point. For example, the inertial sensor needs 3 seconds to calibrate before use.</p>"},{"location":"appendix/glossary/#cartridge","title":"Cartridge","text":"<p>The colored gear insert inside a VEX V5 motor that determines its speed/torque ratio: - Blue (6:1): 600 RPM, low torque - Green (18:1): 200 RPM, medium torque - Red (36:1): 100 RPM, high torque</p>"},{"location":"appendix/glossary/#center-of-gravity","title":"Center of Gravity","text":"<p>The point where a robot's weight is balanced. If this is too high or off-center, the robot may tip over.</p>"},{"location":"appendix/glossary/#coast","title":"COAST","text":"<p>A motor stopping mode where the motor stops applying power but doesn't resist movement. The robot coasts to a stop gradually.</p>"},{"location":"appendix/glossary/#controller","title":"Controller","text":"<p>The handheld device drivers use to control the robot during the driver control period.</p>"},{"location":"appendix/glossary/#d","title":"D","text":""},{"location":"appendix/glossary/#deadband","title":"Deadband","text":"<p>A zone around joystick center (usually 5-10%) where small movements are ignored. Prevents drift when the joystick isn't perfectly centered.</p>"},{"location":"appendix/glossary/#degrees","title":"Degrees","text":"<p>A unit of rotation. A full circle is 360 degrees. Used for motor positions and turns.</p>"},{"location":"appendix/glossary/#derivative-d","title":"Derivative (D)","text":"<p>In PID control, the term that predicts future error based on how fast the error is changing. Helps prevent overshoot.</p>"},{"location":"appendix/glossary/#descoring","title":"Descoring","text":"<p>Removing blocks that your opponent has scored. In Push Back, this is legal and can be a key strategy!</p>"},{"location":"appendix/glossary/#driver-control","title":"Driver Control","text":"<p>The 1 minute 45 second period after autonomous where drivers control their robots using controllers.</p>"},{"location":"appendix/glossary/#drivetrain","title":"Drivetrain","text":"<p>The motors and wheels that move your robot. A 4-motor tank drive uses 4 motors connected to 4 wheels.</p>"},{"location":"appendix/glossary/#e","title":"E","text":""},{"location":"appendix/glossary/#error","title":"Error","text":"<p>In PID control, the difference between where you want to be (target) and where you are (current). Error = Target - Current.</p>"},{"location":"appendix/glossary/#f","title":"F","text":""},{"location":"appendix/glossary/#float","title":"Float","text":"<p>A data type for decimal numbers like 3.14 or -0.5. Used for precise calculations.</p>"},{"location":"appendix/glossary/#force","title":"Force","text":"<p>A push or pull on an object. Measured in Newtons (N). More force = more acceleration (F = m \u00d7 a).</p>"},{"location":"appendix/glossary/#forward","title":"Forward","text":"<p>The direction the front of the robot faces. In code: <code>FORWARD</code> constant.</p>"},{"location":"appendix/glossary/#friction","title":"Friction","text":"<p>The force that resists motion between surfaces. More friction = more traction but harder to slide.</p>"},{"location":"appendix/glossary/#function","title":"Function","text":"<p>A reusable block of code that performs a specific task. Like a recipe you can use over and over.</p>"},{"location":"appendix/glossary/#g","title":"G","text":""},{"location":"appendix/glossary/#gear-ratio","title":"Gear Ratio","text":"<p>The relationship between two connected gears. A 2:1 ratio means the output gear turns once for every 2 turns of the input gear.</p>"},{"location":"appendix/glossary/#gps-sensor","title":"GPS Sensor","text":"<p>A VEX sensor that knows the robot's exact position on the field. Uses a special stripe code on the field perimeter.</p>"},{"location":"appendix/glossary/#h","title":"H","text":""},{"location":"appendix/glossary/#heading","title":"Heading","text":"<p>The direction the robot is facing, measured in degrees (0-360). North = 0\u00b0, East = 90\u00b0, etc.</p>"},{"location":"appendix/glossary/#hold","title":"HOLD","text":"<p>A motor stopping mode where the motor actively maintains its position. The robot stops and resists being pushed.</p>"},{"location":"appendix/glossary/#i","title":"I","text":""},{"location":"appendix/glossary/#inertial-sensor-imu","title":"Inertial Sensor (IMU)","text":"<p>A sensor that measures the robot's rotation and tilt. Essential for accurate autonomous turns.</p>"},{"location":"appendix/glossary/#integer-int","title":"Integer (int)","text":"<p>A data type for whole numbers like 1, 42, or -7. No decimal points.</p>"},{"location":"appendix/glossary/#integral-i","title":"Integral (I)","text":"<p>In PID control, the term that accumulates error over time. Helps reach the target when P alone isn't enough.</p>"},{"location":"appendix/glossary/#j","title":"J","text":""},{"location":"appendix/glossary/#joystick","title":"Joystick","text":"<p>The movable sticks on the controller. Each joystick can move in two directions (X and Y), giving 4 total axes.</p>"},{"location":"appendix/glossary/#k","title":"K","text":""},{"location":"appendix/glossary/#kp-ki-kd","title":"Kp, Ki, Kd","text":"<p>The tuning constants for PID control: - Kp: Proportional gain (how aggressively to correct) - Ki: Integral gain (how fast to accumulate error) - Kd: Derivative gain (how much to dampen changes)</p>"},{"location":"appendix/glossary/#l","title":"L","text":""},{"location":"appendix/glossary/#loop","title":"Loop","text":"<p>Code that repeats. A <code>while True:</code> loop runs forever. A <code>for</code> loop runs a specific number of times.</p>"},{"location":"appendix/glossary/#m","title":"M","text":""},{"location":"appendix/glossary/#millimeters-mm","title":"Millimeters (MM)","text":"<p>A unit of distance. 1000 mm = 1 meter. About the width of a fingernail.</p>"},{"location":"appendix/glossary/#momentum","title":"Momentum","text":"<p>Mass times velocity. A heavier or faster robot has more momentum and is harder to stop.</p>"},{"location":"appendix/glossary/#motor","title":"Motor","text":"<p>A device that converts electrical energy into rotational motion. VEX V5 Smart Motors have built-in sensors for position and speed.</p>"},{"location":"appendix/glossary/#motor-group","title":"Motor Group","text":"<p>Multiple motors controlled together as one unit. Used for left-side and right-side drive motors.</p>"},{"location":"appendix/glossary/#n","title":"N","text":""},{"location":"appendix/glossary/#newton","title":"Newton","text":"<p>The unit of force. Named after Isaac Newton. 1 Newton is about the weight of a small apple.</p>"},{"location":"appendix/glossary/#o","title":"O","text":""},{"location":"appendix/glossary/#omni-wheel","title":"Omni Wheel","text":"<p>A wheel with small rollers around its edge that allow sideways sliding. Great for turning but provides less pushing power.</p>"},{"location":"appendix/glossary/#optical-sensor","title":"Optical Sensor","text":"<p>A VEX sensor that detects colors and proximity. Useful for sorting blocks by alliance color.</p>"},{"location":"appendix/glossary/#overshoot","title":"Overshoot","text":"<p>When the robot goes past its target, then has to correct back. Happens when corrections are too aggressive.</p>"},{"location":"appendix/glossary/#p","title":"P","text":""},{"location":"appendix/glossary/#parameter","title":"Parameter","text":"<p>A value you pass into a function. Like ingredients in a recipe.</p>"},{"location":"appendix/glossary/#parking","title":"Parking","text":"<p>Positioning your robot in a designated zone at the end of a match for bonus points.</p>"},{"location":"appendix/glossary/#percent","title":"PERCENT","text":"<p>A unit for motor speed. 100% = maximum speed, 50% = half speed.</p>"},{"location":"appendix/glossary/#pid-control","title":"PID Control","text":"<p>A control algorithm (Proportional-Integral-Derivative) that makes robot movements more accurate and smooth.</p>"},{"location":"appendix/glossary/#port","title":"Port","text":"<p>A numbered connection point on the V5 Brain (1-21) where you plug in motors and sensors.</p>"},{"location":"appendix/glossary/#proportional-p","title":"Proportional (P)","text":"<p>In PID control, the term that corrects based on current error. Bigger error = bigger correction.</p>"},{"location":"appendix/glossary/#push-back","title":"Push Back","text":"<p>The VEX IQ 2025-2026 competition game. Teams push blocks into goals and control zones to score points.</p>"},{"location":"appendix/glossary/#q","title":"Q","text":""},{"location":"appendix/glossary/#no-terms","title":"(No terms)","text":""},{"location":"appendix/glossary/#r","title":"R","text":""},{"location":"appendix/glossary/#reverse","title":"Reverse","text":"<p>The opposite of forward. In code: <code>REVERSE</code> constant.</p>"},{"location":"appendix/glossary/#reversed-motor","title":"Reversed Motor","text":"<p>A motor where positive velocity spins it backward. Right-side motors are typically reversed because they're mounted as a mirror of the left side.</p>"},{"location":"appendix/glossary/#rpm","title":"RPM","text":"<p>Revolutions Per Minute - how many times a motor shaft completes a full rotation in one minute.</p>"},{"location":"appendix/glossary/#rsid","title":"RSID","text":"<p>In programming, a unique identifier. In VEX code, helps track different parts of the document.</p>"},{"location":"appendix/glossary/#s","title":"S","text":""},{"location":"appendix/glossary/#sensor","title":"Sensor","text":"<p>A device that measures something in the environment (distance, color, rotation, position).</p>"},{"location":"appendix/glossary/#skills","title":"Skills","text":"<p>A competition format where one robot runs solo for 60 seconds instead of playing with an alliance.</p>"},{"location":"appendix/glossary/#spin","title":"Spin","text":"<p>To make a motor rotate continuously. <code>motor.spin(FORWARD)</code> keeps the motor running.</p>"},{"location":"appendix/glossary/#state-machine","title":"State Machine","text":"<p>A programming pattern where code tracks which \"state\" it's in and behaves differently in each state.</p>"},{"location":"appendix/glossary/#string-str","title":"String (str)","text":"<p>A data type for text, like \"Hello!\" or \"Red Team\". Always in quotes.</p>"},{"location":"appendix/glossary/#t","title":"T","text":""},{"location":"appendix/glossary/#tank-drive","title":"Tank Drive","text":"<p>A control scheme where each joystick controls one side of the robot. Left stick = left motors, right stick = right motors.</p>"},{"location":"appendix/glossary/#timeout","title":"Timeout","text":"<p>A safety limit that stops an action if it takes too long. Prevents your robot from getting stuck.</p>"},{"location":"appendix/glossary/#torque","title":"Torque","text":"<p>Rotational force. Higher torque = more pushing power but lower speed.</p>"},{"location":"appendix/glossary/#traction","title":"Traction","text":"<p>How well wheels grip the surface. More traction = better pushing, less slipping.</p>"},{"location":"appendix/glossary/#turn","title":"Turn","text":"<p>Rotation around the robot's center. <code>turn_for(RIGHT, 90, DEGREES)</code> rotates 90\u00b0 clockwise.</p>"},{"location":"appendix/glossary/#u","title":"U","text":""},{"location":"appendix/glossary/#no-terms_1","title":"(No terms)","text":""},{"location":"appendix/glossary/#v","title":"V","text":""},{"location":"appendix/glossary/#variable","title":"Variable","text":"<p>A named container that stores a value. Like a labeled box holding something.</p>"},{"location":"appendix/glossary/#velocity","title":"Velocity","text":"<p>Speed in a specific direction. Can be positive (forward) or negative (reverse).</p>"},{"location":"appendix/glossary/#vex-v5","title":"VEX V5","text":"<p>The current VEX IQ robotics platform with V5 Brain, Smart Motors, and various sensors.</p>"},{"location":"appendix/glossary/#w","title":"W","text":""},{"location":"appendix/glossary/#wait","title":"Wait","text":"<p>A command that pauses code execution. <code>wait(1, SECONDS)</code> pauses for 1 second.</p>"},{"location":"appendix/glossary/#wheel-travel","title":"Wheel Travel","text":"<p>The distance a robot moves in one full wheel rotation. Equals wheel circumference (\u03c0 \u00d7 diameter).</p>"},{"location":"appendix/glossary/#while-loop","title":"While Loop","text":"<p>A loop that runs as long as a condition is true. <code>while True:</code> runs forever.</p>"},{"location":"appendix/glossary/#x-y-z","title":"X, Y, Z","text":""},{"location":"appendix/glossary/#x-axis","title":"X-Axis","text":"<p>Horizontal direction (left/right). On joysticks: Axis 1 and Axis 4.</p>"},{"location":"appendix/glossary/#y-axis","title":"Y-Axis","text":"<p>Vertical direction (up/down). On joysticks: Axis 2 and Axis 3.</p>"},{"location":"appendix/glossary/#zone-control","title":"Zone Control","text":"<p>In Push Back, having the most blocks of your color in a zone to earn bonus points (6-10 points per zone).</p> <p>\u2190 Back to Tutorials</p>"},{"location":"appendix/quick-reference/","title":"Quick Reference","text":"<p>A cheat sheet for VEX V5 Python programming.</p>"},{"location":"appendix/quick-reference/#motor-control","title":"Motor Control","text":"<pre><code># Create motor\nmotor = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\n\n# Spin motor\nmotor.spin(FORWARD)                    # At set velocity\nmotor.spin(FORWARD, 50, PERCENT)       # At 50%\nmotor.spin(REVERSE, 100, RPM)          # At 100 RPM\n\n# Set velocity (then spin)\nmotor.set_velocity(75, PERCENT)\nmotor.spin(FORWARD)\n\n# Stop motor\nmotor.stop()\nmotor.set_stopping(BRAKE)   # BRAKE, COAST, or HOLD\n\n# Read motor values\nmotor.velocity(PERCENT)     # Current speed\nmotor.position(DEGREES)     # Total rotation\nmotor.temperature(CELSIUS)  # Motor temp\n</code></pre>"},{"location":"appendix/quick-reference/#motor-group","title":"Motor Group","text":"<pre><code># Create group\nmotors = MotorGroup(motor1, motor2)\n\n# Same methods as single motor\nmotors.spin(FORWARD, 50, PERCENT)\nmotors.stop()\nmotors.set_velocity(75, PERCENT)\n</code></pre>"},{"location":"appendix/quick-reference/#drivetrain","title":"Drivetrain","text":"<pre><code># Create drivetrain\ndrivetrain = DriveTrain(left_motors, right_motors,\n                        wheel_circumference, track_width,\n                        wheel_base, MM, gear_ratio)\n\n# Autonomous movements\ndrivetrain.drive_for(FORWARD, 500, MM)\ndrivetrain.drive_for(REVERSE, 12, INCHES)\ndrivetrain.turn_for(RIGHT, 90, DEGREES)\ndrivetrain.turn_for(LEFT, 45, DEGREES)\n\n# Settings\ndrivetrain.set_drive_velocity(50, PERCENT)\ndrivetrain.set_turn_velocity(30, PERCENT)\ndrivetrain.set_stopping(BRAKE)\ndrivetrain.set_timeout(3, SECONDS)\n\n# Manual control\ndrivetrain.drive(FORWARD)\ndrivetrain.turn(RIGHT)\ndrivetrain.stop()\n</code></pre>"},{"location":"appendix/quick-reference/#controller","title":"Controller","text":"<pre><code># Create controller\ncontroller = Controller(PRIMARY)\n\n# Read joysticks (-100 to 100)\ncontroller.axis1.position()  # Right X\ncontroller.axis2.position()  # Right Y\ncontroller.axis3.position()  # Left Y\ncontroller.axis4.position()  # Left X\n\n# Check buttons\nif controller.buttonA.pressing():\nif controller.buttonB.pressing():\nif controller.buttonX.pressing():\nif controller.buttonY.pressing():\nif controller.buttonL1.pressing():\nif controller.buttonL2.pressing():\nif controller.buttonR1.pressing():\nif controller.buttonR2.pressing():\n</code></pre>"},{"location":"appendix/quick-reference/#brain","title":"Brain","text":"<pre><code># Create brain\nbrain = Brain()\n\n# Screen output\nbrain.screen.clear_screen()\nbrain.screen.set_cursor(1, 1)\nbrain.screen.print(\"Hello!\")\nbrain.screen.print(str(variable))\n\n# Timer\nbrain.timer.time(SECONDS)\nbrain.timer.reset()\n\n# Battery\nbrain.battery.capacity()\nbrain.battery.voltage()\n</code></pre>"},{"location":"appendix/quick-reference/#sensors","title":"Sensors","text":""},{"location":"appendix/quick-reference/#inertial-imu","title":"Inertial (IMU)","text":"<pre><code>inertial = Inertial(Ports.PORT5)\ninertial.calibrate()\nwait(3, SECONDS)\n\ninertial.heading()      # 0-360 degrees\ninertial.rotation()     # Continuous rotation\ninertial.set_heading(0) # Reset heading\n</code></pre>"},{"location":"appendix/quick-reference/#distance","title":"Distance","text":"<pre><code>distance = Distance(Ports.PORT6)\n\ndistance.object_distance(MM)\ndistance.is_object_detected()\n</code></pre>"},{"location":"appendix/quick-reference/#optical","title":"Optical","text":"<pre><code>optical = Optical(Ports.PORT7)\noptical.set_light_power(100)\noptical.set_light(LedStateType.ON)\n\noptical.color()           # Color.RED, Color.BLUE, etc.\noptical.is_near_object()\noptical.brightness()\n</code></pre>"},{"location":"appendix/quick-reference/#gps","title":"GPS","text":"<pre><code>gps = Gps(Ports.PORT8)\n\ngps.x_position(MM)\ngps.y_position(MM)\ngps.heading()\n</code></pre>"},{"location":"appendix/quick-reference/#waittiming","title":"Wait/Timing","text":"<pre><code>wait(500, MSEC)      # Wait 500 milliseconds\nwait(2, SECONDS)     # Wait 2 seconds\n\n# Timer\ntimer = Timer()\ntimer.reset()\nelapsed = timer.time(SECONDS)\n</code></pre>"},{"location":"appendix/quick-reference/#gear-settings","title":"Gear Settings","text":"Setting RPM Use <code>RATIO_6_1</code> 600 Speed (blue) <code>RATIO_18_1</code> 200 Balanced (green) <code>RATIO_36_1</code> 100 Torque (red)"},{"location":"appendix/quick-reference/#unit-constants","title":"Unit Constants","text":"<pre><code># Distance\nMM, INCHES\n\n# Angle\nDEGREES\n\n# Time\nMSEC, SECONDS\n\n# Direction\nFORWARD, REVERSE, LEFT, RIGHT\n\n# Stopping mode\nBRAKE, COAST, HOLD\n</code></pre>"},{"location":"appendix/quick-reference/#joystick-axis-mapping","title":"Joystick Axis Mapping","text":"<pre><code>    Left Stick:             Right Stick:\n    axis4 (X, left/right)   axis1 (X, left/right)\n    axis3 (Y, up/down)      axis2 (Y, up/down)\n</code></pre>"},{"location":"appendix/quick-reference/#common-patterns","title":"Common Patterns","text":""},{"location":"appendix/quick-reference/#driver-control-loop","title":"Driver Control Loop","text":"<pre><code>while True:\n    left = controller.axis3.position()\n    right = controller.axis2.position()\n\n    left_motors.spin(FORWARD, left, PERCENT)\n    right_motors.spin(FORWARD, right, PERCENT)\n\n    wait(20, MSEC)\n</code></pre>"},{"location":"appendix/quick-reference/#button-toggle","title":"Button Toggle","text":"<pre><code>toggle = False\nlast_press = False\n\nwhile True:\n    current = controller.buttonA.pressing()\n\n    if current and not last_press:\n        toggle = not toggle\n\n    last_press = current\n    wait(20, MSEC)\n</code></pre>"},{"location":"appendix/quick-reference/#deadband","title":"Deadband","text":"<pre><code>def deadband(value, threshold=5):\n    if abs(value) &lt; threshold:\n        return 0\n    return value\n</code></pre> <p>\u2190 Back to Tutorials</p>"},{"location":"appendix/troubleshooting/","title":"Troubleshooting Guide","text":"<p>Common problems and how to fix them.</p>"},{"location":"appendix/troubleshooting/#my-robot-wont-move","title":"\"My Robot Won't Move!\"","text":""},{"location":"appendix/troubleshooting/#checklist","title":"Checklist","text":"<pre><code>flowchart TD\n    Start[\"Robot Won't Move\"] --&gt; B{\"Battery charged?\"}\n    B --&gt;|No| BC[\"Charge battery\"]\n    B --&gt;|Yes| C{\"Code downloaded?\"}\n    C --&gt;|No| CD[\"Download code from brain menu\"]\n    C --&gt;|Yes| M{\"Motors plugged in?\"}\n    M --&gt;|No| MC[\"Check connections\"]\n    M --&gt;|Yes| P{\"Ports correct in code?\"}\n    P --&gt;|No| PC[\"Match robot_config.py\"]\n    P --&gt;|Yes| K{\"Controller connected?\"}\n    K --&gt;|No| KC[\"Check wireless link\"]\n    K --&gt;|Yes| OK[\"All checks passed - investigate further\"]</code></pre>"},{"location":"appendix/troubleshooting/#port-mismatch","title":"Port Mismatch","text":"<pre><code># If motors are on ports 1,2,3,4 but code says 5,6,7,8:\nleft_motor_front = Motor(Ports.PORT1, ...)  # \u2190 Check this!\n</code></pre>"},{"location":"appendix/troubleshooting/#motors-reversed-wrong","title":"Motors Reversed Wrong","text":"<pre><code># If robot spins in circles instead of forward:\n# Right motors should be reversed!\nright_motor = Motor(Ports.PORT3, GearSetting.RATIO_18_1, True)\n#                                                         ^^^^\n</code></pre>"},{"location":"appendix/troubleshooting/#my-robot-moves-slowly","title":"\"My Robot Moves Slowly\"","text":""},{"location":"appendix/troubleshooting/#check-gear-setting","title":"Check Gear Setting","text":"<pre><code># Make sure code matches physical cartridge!\nMotor(port, GearSetting.RATIO_18_1, ...)  # Green = 200 RPM\nMotor(port, GearSetting.RATIO_36_1, ...)  # Red = 100 RPM\n</code></pre>"},{"location":"appendix/troubleshooting/#check-velocity-setting","title":"Check Velocity Setting","text":"<pre><code># Make sure velocity is high enough\nmotor.set_velocity(100, PERCENT)  # Not 10!\n</code></pre>"},{"location":"appendix/troubleshooting/#battery-low","title":"Battery Low","text":"<ul> <li>Check battery percentage on brain screen</li> <li>Swap batteries if below 50%</li> </ul>"},{"location":"appendix/troubleshooting/#my-robot-drifts-when-joystick-is-centered","title":"\"My Robot Drifts When Joystick Is Centered\"","text":""},{"location":"appendix/troubleshooting/#add-deadband","title":"Add Deadband","text":"<pre><code>def deadband(value, threshold=5):\n    if abs(value) &lt; threshold:\n        return 0\n    return value\n\nspeed = deadband(controller.axis3.position())\n</code></pre>"},{"location":"appendix/troubleshooting/#increase-threshold","title":"Increase Threshold","text":"<pre><code># If still drifting, increase threshold\nspeed = deadband(controller.axis3.position(), threshold=10)\n</code></pre>"},{"location":"appendix/troubleshooting/#my-robot-overshoots-when-turning","title":"\"My Robot Overshoots When Turning\"","text":""},{"location":"appendix/troubleshooting/#reduce-turn-velocity","title":"Reduce Turn Velocity","text":"<pre><code>drivetrain.set_turn_velocity(30, PERCENT)  # Lower = more accurate\n</code></pre>"},{"location":"appendix/troubleshooting/#add-wait-after-turn","title":"Add Wait After Turn","text":"<pre><code>drivetrain.turn_for(RIGHT, 90, DEGREES)\nwait(200, MSEC)  # Let robot settle\n</code></pre>"},{"location":"appendix/troubleshooting/#use-inertial-sensor","title":"Use Inertial Sensor","text":"<pre><code># For accurate turns, use inertial sensor + P control\n# See Tutorial 7.1: PID Control\n</code></pre>"},{"location":"appendix/troubleshooting/#code-doesnt-download","title":"\"Code Doesn't Download\"","text":""},{"location":"appendix/troubleshooting/#check-connection","title":"Check Connection","text":"<ol> <li>USB-C cable connected to Brain?</li> <li>VEX Extension active in VS Code?</li> <li>Brain powered on?</li> </ol>"},{"location":"appendix/troubleshooting/#try-restart","title":"Try Restart","text":"<ol> <li>Power off brain</li> <li>Disconnect USB</li> <li>Power on brain</li> <li>Reconnect USB</li> <li>Try download again</li> </ol>"},{"location":"appendix/troubleshooting/#check-file","title":"Check File","text":"<ul> <li>Make sure you're downloading <code>main.py</code></li> <li>Check for syntax errors (red underlines)</li> </ul>"},{"location":"appendix/troubleshooting/#controller-doesnt-work","title":"\"Controller Doesn't Work\"","text":""},{"location":"appendix/troubleshooting/#check-pairing","title":"Check Pairing","text":"<ol> <li>Both brain and controller powered on?</li> <li>Radio dongle plugged into brain?</li> <li>Try re-pairing (hold power buttons on both)</li> </ol>"},{"location":"appendix/troubleshooting/#wired-test","title":"Wired Test","text":"<ul> <li>Connect controller to brain with cable</li> <li>If works wired but not wireless, battery issue</li> </ul>"},{"location":"appendix/troubleshooting/#replace-batteries","title":"Replace Batteries","text":"<ul> <li>Controller takes AA batteries</li> <li>Replace if older than a few months</li> </ul>"},{"location":"appendix/troubleshooting/#common-code-errors","title":"Common Code Errors","text":""},{"location":"appendix/troubleshooting/#indentationerror","title":"IndentationError","text":"<pre><code># WRONG:\ndef my_function():\nprint(\"Hello\")  # Not indented!\n\n# RIGHT:\ndef my_function():\n    print(\"Hello\")  # 4 spaces\n</code></pre>"},{"location":"appendix/troubleshooting/#nameerror","title":"NameError","text":"<pre><code># WRONG:\nprint(Speed)  # Wrong capitalization\n\n# RIGHT:\nprint(speed)  # Match variable name exactly\n</code></pre>"},{"location":"appendix/troubleshooting/#typeerror","title":"TypeError","text":"<pre><code># WRONG:\nprint(\"Speed: \" + speed)  # Can't add string + number\n\n# RIGHT:\nprint(\"Speed: \" + str(speed))  # Convert to string\n</code></pre>"},{"location":"appendix/troubleshooting/#syntaxerror","title":"SyntaxError","text":"<pre><code># WRONG:\nif speed &gt; 50  # Missing colon\n    print(\"Fast\")\n\n# RIGHT:\nif speed &gt; 50:  # Colon required!\n    print(\"Fast\")\n</code></pre>"},{"location":"appendix/troubleshooting/#inertial-sensor-issues","title":"Inertial Sensor Issues","text":""},{"location":"appendix/troubleshooting/#not-calibrated","title":"Not Calibrated","text":"<pre><code>inertial_sensor.calibrate()\nwait(3, SECONDS)  # MUST WAIT for calibration!\n</code></pre>"},{"location":"appendix/troubleshooting/#robot-moving-during-calibration","title":"Robot Moving During Calibration","text":"<ul> <li>Robot must be STILL during calibration</li> <li>Place on flat surface</li> <li>Don't touch for 3 seconds</li> </ul>"},{"location":"appendix/troubleshooting/#heading-drift","title":"Heading Drift","text":"<ul> <li>Normal over time</li> <li>Re-calibrate between matches</li> <li>Use <code>inertial_sensor.set_heading(0)</code> to reset</li> </ul>"},{"location":"appendix/troubleshooting/#distance-sensor-issues","title":"Distance Sensor Issues","text":""},{"location":"appendix/troubleshooting/#reading-zero","title":"Reading Zero","text":"<ul> <li>Object too far? (Max ~2000mm)</li> <li>Object too close? (Min ~50mm)</li> <li>Sensor blocked?</li> </ul>"},{"location":"appendix/troubleshooting/#inconsistent-readings","title":"Inconsistent Readings","text":"<ul> <li>Shiny surfaces reflect poorly</li> <li>Dark objects absorb light</li> <li>Try different target surface</li> </ul>"},{"location":"appendix/troubleshooting/#competition-checklist","title":"Competition Checklist","text":"<pre><code>timeline\n    title Competition Pre-Match Checklist\n    section BEFORE MATCH\n        Battery charged &gt;70%\n        : Controller batteries fresh\n        : Code downloaded\n        : Correct autonomous selected\n        : Motors all working\n        : Sensors calibrated\n    section AT FIELD\n        Controller paired\n        : Alliance color set (if needed)\n        : Starting position correct\n        : Robot in legal position\n    section AFTER AUTONOMOUS\n        Ready to drive immediately\n        : Know the game situation</code></pre>"},{"location":"appendix/troubleshooting/#getting-more-help","title":"Getting More Help","text":"<ol> <li>VEX Forum: www.vexforum.com</li> <li>VEX Knowledge Base: kb.vex.com</li> <li>Ask Your Mentor</li> <li>Check the Glossary (next page)</li> </ol> <p>\u2190 Back to Tutorials | Glossary \u2192</p>"}]}